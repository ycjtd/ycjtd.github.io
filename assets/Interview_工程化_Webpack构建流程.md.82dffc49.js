import{_ as t,c as n,o as s,a as e,b as a}from"./app.58c7925b.js";const w=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"Webpack 构建流程","slug":"webpack-构建流程","link":"#webpack-构建流程","children":[]},{"level":3,"title":"完整版","slug":"完整版","link":"#完整版","children":[]}],"relativePath":"Interview/工程化/Webpack构建流程.md"}'),r={name:"Interview/工程化/Webpack构建流程.md"},c=e("h3",{id:"webpack-构建流程",tabindex:"-1"},[a("Webpack 构建流程 "),e("a",{class:"header-anchor",href:"#webpack-构建流程","aria-hidden":"true"},"#")],-1),o=e("pre",null,[e("code",null,`1. 从入口文件开始解析
2. 查找入口文件引入了哪些js文件，找到依赖关系
3. 递归遍历引入的其它js，生成最终的依赖关系图
4. 将ES6语法转化成ES5
5. 最终生成一个可以在浏览器加载执行的js文件
`)],-1),l=e("h3",{id:"完整版",tabindex:"-1"},[a("完整版 "),e("a",{class:"header-anchor",href:"#完整版","aria-hidden":"true"},"#")],-1),i=e("pre",null,[e("code",null,"1. webpack 从项目的`entry`入口文件开始递归分析，调用所有配置的 `loader`对模块进行编译（因为 webpack 默认只能识别 js 代码，所以如 css 文件、.vue 结尾的文件，必须要通过对应的 loader 解析成 js 代码后，webpack 才能识别）\n2. 利用`babel(babylon)`将 js 代码转化为`ast抽象语法树`，然后通过`babel-traverse`对 ast 进行遍历\n3. 遍历的目的找到文件的`import引用节点`（因为现在我们引入文件都是通过 import 的方式引入，所以找到了 import 节点，就找到了文件的依赖关系）\n4. 同时每个模块生成一个唯一的 id，并将解析过的`模块缓存`起来，如果其他地方也引入该模块，就无需重新解析，最后根据依赖关系生成依赖图谱\n5. 递归遍历所有依赖图谱的模块，组装成一个个包含多个模块的 `Chunk(块)`\n6. 最后将生成的文件输出到 `output` 的目录中\n")],-1),d=[c,o,l,i];function p(_,b,h,k,u,m){return s(),n("div",null,d)}const v=t(r,[["render",p]]);export{w as __pageData,v as default};
