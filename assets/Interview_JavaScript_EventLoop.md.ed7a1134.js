import{_ as e,c as t,o as p,d as o}from"./app.eeaca755.js";const l=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/JavaScript/EventLoop.md"}'),n={name:"Interview/JavaScript/EventLoop.md"},s=o("<p>作为浏览器脚本语言，JavaScript 的主要用途是和用户交互以及操作 DOM，所以只能是单线程，如果不是单线程，会带来很复杂的同步问题，比如一个线程在 DOM 节点上添加内容，另一个线程删除节点，此时浏览器不知道以那个为准。</p><p>同一个时间只能做一件事。所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着</p><p>所有任务可以分成两种，一种是宏任务，另一种是微任务</p><p>宏任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务 微任务指的是，不进入主线程、而进入&quot;微任务队列&quot;的任务</p><p>当前宏任务执行完后，会判断微任务列表中是否有任务。如果有，会把该微任务放到主线程中并执行，如果没有，就继续执行下一个宏任务</p><p><strong>宏任务 微任务</strong></p><p>宏任务：script 全部代码（同步代码也属于宏任务）、setTimeout、setInterval、setImmediate 等</p><p>微任务：Promsie、MutationObserver</p><p><strong>执行过程</strong></p><p>1）代码执行过程中，宏任务和微任务放在不同的任务队列中</p><p>2）当某个宏任务执行完后,会查看微任务队列是否有任务。如果有，执行微任务队列中的所有微任务(注意这里是执行所有的微任务)</p><p>3）微任务执行完成后，会读取宏任务队列中排在最前的第一个宏任务（注意宏任务是一个个取），执行该宏任务，如果执行过程中，遇到微任务，依次加入微任务队列</p><p>4）宏任务执行完成后，再次读取微任务队列里的任务，依次类推。</p><p><strong>async await 事件轮询执行时机</strong></p><p>async 隐式返回 Promise，会产生一个微任务</p><p>await 后面的代码是在微任务时执行</p><p><strong>event loop 和浏览器更新渲染时机</strong></p><p>1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即<code>宏任务 → 微任务 → 渲染更新</code>（先宏任务 再微任务，然后再渲染更新）</p><p>2）宏任务队列中，如果有大量任务等待执行时，将<code>dom的变动作为微任务，能更快的将变化呈现给用户</code>，这样就可以在这一次的事件轮询中更新 dom</p><p><strong>event loop 和 vue nextTick</strong></p><p>1） vue nextTick 的源码实现，优先级判断，总结就是<code>Promise &gt; MutationObserver &gt; setImmediate &gt; setTimeout</code></p><p>2）这里优先使用 Promise，因为根据 event loop 与浏览器更新渲染时机，使用微任务，本次 event loop 轮询就可以获取到更新的 dom</p><p>3）如果使用宏任务，要到下一次 event loop 中，才能获取到更新的 dom</p><p><strong>Node 中的 process.nextTick</strong></p><p>执行顺序早于微任务</p>",25),r=[s];function a(c,i,_,d,m,v){return p(),t("div",null,r)}const u=e(n,[["render",a]]);export{l as __pageData,u as default};
