import{_ as e,c as i,o as t,d as p}from"./app.ba5af232.js";const T=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"为什么会有 TCP/IP 协议？","slug":"为什么会有-tcp-ip-协议","link":"#为什么会有-tcp-ip-协议","children":[]},{"level":3,"title":"什么是 TCP","slug":"什么是-tcp","link":"#什么是-tcp","children":[]},{"level":3,"title":"TCP/IP 网络模型有几层？","slug":"tcp-ip-网络模型有几层","link":"#tcp-ip-网络模型有几层","children":[]},{"level":3,"title":"TCP 头格式有哪些","slug":"tcp-头格式有哪些","link":"#tcp-头格式有哪些","children":[]},{"level":3,"title":"为什么需要 TCP 协议，工作在那一层","slug":"为什么需要-tcp-协议-工作在那一层","link":"#为什么需要-tcp-协议-工作在那一层","children":[]},{"level":3,"title":"三次握手","slug":"三次握手","link":"#三次握手","children":[]},{"level":3,"title":"四次挥手","slug":"四次挥手","link":"#四次挥手","children":[]},{"level":3,"title":"SSL 断开连接后如何恢复","slug":"ssl-断开连接后如何恢复","link":"#ssl-断开连接后如何恢复","children":[]},{"level":3,"title":"TCP 和 UDP 区别","slug":"tcp-和-udp-区别","link":"#tcp-和-udp-区别","children":[]}],"relativePath":"Interview/network/TCP-IP.md"}'),l={name:"Interview/network/TCP-IP.md"},a=p('<h3 id="为什么会有-tcp-ip-协议" tabindex="-1">为什么会有 TCP/IP 协议？ <a class="header-anchor" href="#为什么会有-tcp-ip-协议" aria-hidden="true">#</a></h3><p>同一台设备进程之间进行通信，可以通过管道、共享内存、信号、消息队列等方式，而不同的设备之间想要进行通信，就需要网络进行通信，但是设备是多样性的，为了兼容多种设备，就协商出了一套通用的网络协议</p><h3 id="什么是-tcp" tabindex="-1">什么是 TCP <a class="header-anchor" href="#什么是-tcp" aria-hidden="true">#</a></h3><p>面向连接的、可靠的、基于字节流的传输层通信协议</p><p>面向连接：一对一</p><p>可靠的：保证一个报文一定能到达接收端</p><p>字节流</p><h3 id="tcp-ip-网络模型有几层" tabindex="-1">TCP/IP 网络模型有几层？ <a class="header-anchor" href="#tcp-ip-网络模型有几层" aria-hidden="true">#</a></h3><p><strong>应用层：</strong> 应用层处于最上层，用户能够直接接触到的就是应用层，比如手机和电脑上的软件。应用层的作用主要就是产生数据，将数据传给传输层。应用层工作在系统的用户态，而传输层之下的工作在内核态</p><p><strong>传输层：</strong> 应用层的数据包传输给传输层，传输层为应用层提供网络支持。在传输层有两个传输协议，TCP 和 UDP</p><p>TCP：传输控制协议，使用比较多的传输协议。相比 UDP，具备流量控制（控制发送方向接收方发送数据的速率，防止接收方接收不了，导致数据丢失或网络拥塞。核心思想是发送方和接收方一起维护一个滑动窗口，接收方通过 TCP 报文中的窗口大小字段告诉发送方它的接收能力，发送方根据接收方告知的窗口大小来确定可以发的数据量，发送方不会超过接收方指定的窗口大小发送数据）、超时重传（在发送某一个数据之后就开启一个定时器，在一定的时间内如果没有收到发送的数据包的 ACK 报文，就会重新发送，直到发送成功为止）、拥塞控制（通过观察感知网络的拥塞状态，调整发送速度）等特点，基于这些特点能够保证数据包能够可靠的传输给对方，所有是安全的、可靠的</p><p>UDP：只负责传输数据，不保证数据能否抵达，传输效率比较高，实时性也比较好</p><p>当应用传输的数据非常大的时候，如果直接传输就很不好控制，所有当传输的数据包大于 TCP 最大报文长度的时候，就要将数据包分块，这样的好处就是如果传输过程中有一个丢失或者损坏，只需要重新发送丢失的分块即可，不需要重新发送整个数据包。</p><p>传输层的报文中会携带端口号，接收方根据这个端口号来判断这个报文要传输给那个应用</p><p><strong>网络层：</strong> 完成实际的传输功能，最常使用的是 IP 协议，IP 层将传输层的报文作为数据部分，加上 IP 包头组成 IP 报文，交由网络接口层</p><p><strong>网络接口层：</strong> 在 IP 报文的前面加上 MAC 头部，封装成数据帧发送到网络上</p><h3 id="tcp-头格式有哪些" tabindex="-1">TCP 头格式有哪些 <a class="header-anchor" href="#tcp-头格式有哪些" aria-hidden="true">#</a></h3><p>序列号：在建立连接的时候由计算机生成的随意数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。用来解决网络包乱序的问题</p><p>确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包问题</p><p>控制位：ACK：为 1 时，确认应答的字段变为有效 SYN：表示希望建立连接 FIN：表示今后不会再有数据发送，希望断开连接</p><h3 id="为什么需要-tcp-协议-工作在那一层" tabindex="-1">为什么需要 TCP 协议，工作在那一层 <a class="header-anchor" href="#为什么需要-tcp-协议-工作在那一层" aria-hidden="true">#</a></h3><p>IP 层是不可靠的，不能保证网络包的交付，不保证网络包的按序交付，不保证网络包中数据的完整性。如果需要保证网络数据包的可靠性，需要 TCP 来负责，工作在传输层</p><h3 id="三次握手" tabindex="-1">三次握手 <a class="header-anchor" href="#三次握手" aria-hidden="true">#</a></h3><p>一开始，客户端和服务端都是 CLOSE 状态，先是服务端主动监听某个端口，处于 LISTEN 状态</p><p>客户端随机初始化序列号，把 SYN 标志置为 1，表示当前报文为 SYN 报文，然后把第一个 SYN 报文发送给服务端，向服务端发起连接，客户端处于 SYN_SENT 状态，这个报文不包含应用层数据</p><p>服务端收到客户端的 SYN 报文，服务端随机初始化自己的序列号，将这个序列号填入 TCP 首部的序号字段，把 SYN 和 ACK 置为 1，最后把这个报文发给客户端，服务端处于 SYN_RCVD 状态，这个报文也不包含应用层数据</p><p>客户端收到服务端的报文后，向服务端回应最后一个应答报文，首先将应答报文 TCP 首部 ACK 标志位置为 1，将服务端的 SYN+1 作为确认应答号，最后把报文发给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态，服务端接收到应答报文后，也处于 ESTABLISHED 状态，至此建立连接</p><p>只有第三次可以携带数据</p><h3 id="四次挥手" tabindex="-1">四次挥手 <a class="header-anchor" href="#四次挥手" aria-hidden="true">#</a></h3><ul><li>第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认</li><li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态</li><li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态</li><li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态</li></ul><p>服务端在收到客户端断开连接</p><p>Fin 报文后，并不会立即关闭连接，而是先发送一个</p><p>ACK 包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送</p><p>FIN 报文断开连接，因此需要四次挥手</p><h3 id="ssl-断开连接后如何恢复" tabindex="-1">SSL 断开连接后如何恢复 <a class="header-anchor" href="#ssl-断开连接后如何恢复" aria-hidden="true">#</a></h3><p>通过 session ID：</p><p>使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。</p><p>通过 session ticket：</p><p>另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</p><h3 id="tcp-和-udp-区别" tabindex="-1">TCP 和 UDP 区别 <a class="header-anchor" href="#tcp-和-udp-区别" aria-hidden="true">#</a></h3><ul><li>TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接</li><li>TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠， 面向连接，不会丢失数据因此适合大数据量的交换</li><li>TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低(因 此会出现丢包，对实时的应用比如 IP 电话和视频会议等)</li><li>TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多</li><li>TCP 的首部较大为 20 字节，而 UDP 只有 8 字节</li><li>TCP 是面向连接的可靠性传输，而 UDP 是不可靠的</li></ul>',41),r=[a];function n(s,c,d,h,P,C){return t(),i("div",null,r)}const I=e(l,[["render",n]]);export{T as __pageData,I as default};
