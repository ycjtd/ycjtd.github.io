const e={map:'[{"编程踩坑积累与总结":["0.0","2.0","3.0","7.0","123.0","124.0","126.0"],"test1":["1.0"],"testdddd":["4.0"],"移动端响应式":["5.0"],"响应式布局常用方法":["5.1"],"css":["6.0","10.0","18.0","79.2"],"水平布局":["6.1"],"文本":["6.2"],"单个块级元素":["6.3"],"多个块级元素":["6.4"],"使用绝对定位":["6.5"],"任意个元素":["6.6","6.11"],"垂直居中":["6.7"],"单行":["6.8","37.0"],"多行文本":["6.9"],"单个块元素":["6.10"],"水平垂直居中":["6.12"],"行内":["6.13"],"tabel":["6.14"],"绝对定位":["6.15","6.21"],"绝对居中":["6.16"],"flex":["6.17","6.22","6.24","6.27","21.4","22.0"],"两列布局":["6.18"],"float":["6.19","6.20","6.23","6.26"],"三列布局":["6.25"],"cdn":["11.0","77.9"],"是浏览器的核心部分":["12.0"],"用户输入":["13.0"],"什么是并行处理":["14.0"],"线程":["14.1"],"多进程架构":["14.2"],"是匹配元素之后的选择器":["15.0"],"是什么":["16.0"],"触发条件":["16.1"],"作用":["16.2"],"怎么修改":["17.0"],"产生原因":["17.1"],"解决方案":["17.2"],"合并压缩":["20.0"],"inline":["21.0","21.2"],"block":["21.1"],"none":["21.3"],"采用":["23.0"],"容器属性":["23.1"],"容器成员属性":["23.2"],"margin":["25.0"],"absolute":["26.0"],"fixed":["26.1"],"relative":["26.2"],"static":["26.3"],"inherit":["26.4"],"rem":["27.0"],"图像质量":["28.0"],"transition":["29.0"],"一栏固定宽度":["30.0"],"伪类":["31.0"],"dns":["34.0"],"fouc":["35.0"],"多数显示屏默认频率是":["36.0"],"为什么要清除浮动":["40.0"],"怎么清除":["40.1"],"原理":["41.0","99.1"],"实现":["41.1"],"在标准的":["42.0"],"原因":["43.0"],"解决":["43.1"],"id":["44.0"],"优先级":["44.1"],"前者是标准浏览器中的用法":["45.0"],"为什么需要":["46.0","73.4","89.9"],"a":["47.0"],"h5":["48.0"],"优点":["49.0","70.1"],"定义表单控件的关系":["50.0"],"相同点":["51.0"],"src":["52.0"],"怎么实现浏览器内多个标签的通信":["53.0"],"websocket":["53.1"],"localstorage":["53.2","77.6"],"cookie":["53.3","77.5"],"对语义化的理解":["54.0"],"你是怎么理解语义化的":["54.1"],"常见的语义化标签有哪些":["54.2"],"面试":["55.0"],"作为浏览器脚本语言":["57.0"],"this":["58.0"],"如何阻止事件冒泡和默认事件":["59.0"],"事件捕获和冒泡":["59.1"],"什么是作用域":["60.0"],"作用域的类型":["60.1"],"函数作用域":["60.2"],"块作用域":["60.3"],"var":["60.4"],"作用域链":["60.5"],"闭包":["60.6"],"原型的作用":["61.0"],"原型链":["61.1"],"原型链和作用域链的区别":["61.2"],"proto":["61.3"],"什么是内存泄漏":["62.0"],"内存泄漏的常见原因":["62.1"],"标记清除方法":["62.2"],"引用计数法":["62.3"],"怎么防止内存泄漏":["62.4"],"什么是执行上下文":["63.0"],"执行上下文分类":["63.1"],"执行上下文的特点":["63.2"],"什么是执行栈":["63.3"],"执行上下文的生命周期":["63.4"],"什么是变量对象":["63.5"],"javascript":["64.0","64.7"],"js":["64.1","100.0","101.0","103.0","104.0","105.0","109.0","110.0","111.0","112.0","113.0","114.0","115.0","117.0","118.0","119.0","120.0"],"为什么要新增":["64.2","64.4"],"如果想要复用一个":["64.3"],"null":["64.5","64.6"],"判断数据类型的方法":["64.8"],"怎么判断一个数组":["64.9"],"如何判断一个对象是否为空":["64.10"],"为什么没":["64.11"],"isnan":["64.12"],"object":["64.13"],"为什么":["64.14","91.11","92.1","92.3"],"如何让":["64.15"],"quot":["64.16"],"set":["64.17"],"ajax":["65.0","92.6"],"axios":["65.1"],"检查浏览器中是否缓存过该域名对应的":["67.0"],"区别":["69.0"],"https":["69.1","69.3","84.3"],"混合加密":["69.2"],"对称加密和非对称加密":["69.4"],"怎么实现":["69.5"],"http1":["70.0"],"缺点":["70.2"],"性能":["70.3"],"如何优化":["70.4"],"http2":["70.5"],"有什么优点":["70.6"],"host":["71.0"],"概念":["72.0"],"为什么会有":["73.0"],"什么是":["73.1"],"tcp":["73.2","73.3","73.8"],"三次握手":["73.5"],"四次挥手":["73.6"],"ssl":["73.7"],"简单请求":["75.0"],"短沦陷":["76.0"],"缓存":["77.0"],"强缓存":["77.1"],"协商缓存":["77.2"],"决策指南":["77.3"],"本地存储":["77.4"],"sessionstorage":["77.7"],"indexdb":["77.8"],"懒加载":["78.0"],"防抖与节流":["78.1"],"服务端渲染":["79.0"],"浏览器":["79.1"],"dom":["79.3"],"在网络层面进行优化":["80.0"],"webpack":["80.1","97.0"],"不要让":["80.2"],"处理第三方库":["80.3"],"使用":["80.4"],"构建结果体积压缩":["80.5"],"gzip":["80.6"],"图片优化":["80.7"],"jpeg":["80.8"],"png":["80.9"],"svg":["80.10"],"base64":["80.11"],"webp":["80.12"],"跨站伪造请求":["81.0"],"就是通过把":["82.0"],"xss":["83.0"],"http":["84.0"],"tsl":["84.1"],"对称密钥加密和非对称密钥加密有什么区别":["84.2"],"中间人攻击的过程":["84.4"],"怎么预防中间人攻击":["84.5"],"防护原理":["85.0"],"区分用户是人还是机器":["86.0"],"watch":["87.0","87.3","89.2"],"computed":["87.1","87.2"],"vue":["88.0","88.3","88.8","91.4","91.5","91.6","91.10","92.5","92.10","92.12","92.14","92.17","92.23","92.24","93.2"],"route":["88.1"],"怎么定义动态路由":["88.2"],"hash":["88.4"],"router":["88.5"],"了解":["88.6"],"怎么监听":["88.7","90.2"],"怎么实现路由懒加载":["88.9"],"怎么从零开始实现一个":["88.10"],"proxy":["89.0"],"ref":["89.1"],"composition":["89.3","89.6"],"vue3":["89.4","89.5","89.7","89.8"],"setup":["89.10"],"从":["90.0","92.25"],"vuex":["90.1","90.3"],"pinia":["90.4"],"从零开始实现一个":["90.5"],"数据绑定机制":["91.0"],"template":["91.1"],"怎么监听对象或数组某个属性的变化":["91.2"],"什么是虚拟":["91.3"],"new":["91.7"],"diff":["91.8","91.14"],"响应式数据原理":["91.9"],"nexttick":["91.12"],"v":["91.13","92.2"],"谈谈对":["92.0"],"怎么获取":["92.4"],"对":["92.7","92.9","92.13"],"spa":["92.8"],"既然":["92.11"],"函数式组件的优势和原理":["92.15"],"组件之间通信方式有哪些":["92.16"],"子组件可以直接改父组件的数据吗":["92.18"],"组件和插件有什么区别":["92.19"],"sync":["92.20"],"ssr":["92.21"],"delete":["92.22"],"对生命周期的理解":["93.0"],"什么时候使用":["93.1"],"在那个生命周期中调用异步请求":["93.3"],"babel":["94.0"],"loader":["95.0","95.2"],"手写一个":["95.1"],"常见的":["95.3"],"扩展":["96.0"],"工作原理":["96.1"],"编写一个插件":["96.2"],"完整版":["97.1"],"文件指纹是打包后输出的文件名的后缀":["98.0"],"什么是热更新原理":["99.0"],"接收多个函数为参数":["102.0"],"promise":["107.0"],"race":["107.1"],"retry":["107.2"],"settimeout":["108.0"],"冒泡":["116.0"],"选择排序":["116.1"],"插入排序":["116.2"],"快速排序":["116.3"],"归并排序":["116.4"],"节流":["121.0"],"防抖":["121.1"],"数组":["122.0"],"测试":["125.0","127.0"]},{"0":["6.3","22.0","64.11","89.8","92.25","111.0","116.0","118.0"],"1":["17.2","19.0","22.0","24.0","30.0","32.0","33.0","38.0","39.0","40.1","56.0","58.0","61.3","63.1","63.2","64.9","64.11","64.16","66.0","68.0","70.0","70.4","70.6","72.0","80.3","84.3","88.5","88.9","89.7","90.1","90.3","90.4","90.5","91.10","91.12","92.14","92.15","92.17","92.18","92.19","92.24","92.25","97.1","106.0","111.0","118.0","125.0","127.0"],"2":["56.0","58.0","64.11","64.16","70.4","80.3","92.15","106.0","111.0","116.3"],"3":["58.0","64.16","70.4"],"6":["70.6"],"8":["80.9","93.0"],"24":["80.9"],"28":["66.0"],"100":["38.0"],"304":["77.2"],"tip":["0.0","2.0","3.0","7.0","55.0","123.0","124.0","126.0"],"什么是响应式":["5.0"],"响应式就是将界面设计成能够适应不同的设备":["5.0"],"如果将屏幕看成是容器":["5.0"],"使用":["5.1","6.10","53.2","64.9","73.7","80.3","87.2","88.0","91.9"],"vm":["5.1"],"定制":["5.1"],"rem":["5.1"],"自适应布局":["5.1"],"移动端使用":["5.1"],"布局需要通过":["5.1"],"js":["5.1","10.0","46.0","51.0","61.3","65.0","79.0","92.21","94.0","95.1","96.2","102.0","107.0","107.1","107.2","108.0","116.0","116.1","116.2","116.3","116.4"],"设置不同屏幕宽高比的":["5.1"],"font":["5.1","27.0"],"size":["5.1"],"结合":["5.1"],"单位和":["5.1"],"calc":["5.1"],"常见布局":["6.0"],"行内元素":["6.2","6.9"],"行内块级元素":["6.2","6.9"],"margin":["6.3","6.19","6.26","30.0"],"css":["6.4","6.5","6.6","6.9","6.10","6.11","6.13","6.14","6.15","6.16","6.17","6.19","20.0","24.0","30.0","37.0","38.0","41.1","42.0","92.2","95.3"],"parent":["6.4","6.5","6.10","6.11","6.14","6.15","6.16","6.17","6.21","6.22","6.24","6.26","6.27","91.7","92.16"],"height":["6.5","38.0"],"200px":["6.5","30.0","37.0"],"width":["6.5","30.0","37.0","38.0","41.1"],"定宽":["6.5"],"行内":["6.8"],"行内块":["6.8"],"display":["6.10","6.11","6.17","32.0","33.0","92.2"],"table":["6.10","33.0"],"cell":["6.10","6.14","33.0"],"vertical":["6.10"],"align":["6.10"],"middle":["6.10"],"使用绝对定位":["6.10"],"flex":["6.10","23.0","23.1"],"原理":["6.10","10.0","87.3"],"子绝父相":["6.10","38.0"],"行内块级":["6.13"],"图片":["6.13","51.0"],"左列定宽":["6.18","6.26"],"body":["6.19","6.20","6.21","6.22","6.23","6.24","6.26","6.27"],"div":["6.19","6.20","6.21","6.22","6.23","6.24","6.26","6.27","37.0","113.0"],"overflow":["6.20","6.23"],"html":["6.20","6.21","6.22","6.23","6.24","6.26","6.27","10.0","16.1","42.0","43.1","54.1","79.1","92.21"],"id":["6.21","6.22","6.23","6.24","6.26","6.27","73.7","91.6","111.0","113.0","118.0"],"两列定宽":["6.25"],"left":["6.26","30.0"],"center":["6.26"],"中间定宽":["6.26"],"300ms":["9.0"],"延迟解决的是双击缩放":["9.0"],"双击缩放":["9.0"],"手指在屏幕快速点击两次":["9.0"],"safari":["9.0"],"加载不会阻塞":["10.0"],"dom":["10.0","57.0","59.0","59.1","79.2","91.3","91.8","92.4","92.16","92.21"],"树的解析":["10.0"],"加载会阻塞":["10.0"],"树的渲染":["10.0"],"加载会阻塞后面":["10.0"],"语句的执行":["10.0"],"解析文件":["10.0"],"生成":["10.0"],"tree":["10.0"],"缓存方便":["11.0"],"主要分为两个部分":["12.0"],"渲染引擎和":["12.0"],"javascript":["12.0","57.0","88.9","91.3","95.3"],"url":["13.0","88.4","100.0"],"并回车":["13.0"],"浏览器进程检查":["13.0"],"组装协议":["13.0"],"构成完整的":["13.0"],"浏览器进程通过进程间通信":["13.0"],"ipc":["13.0"],"把":["13.0","95.3"],"请求发送给网络进程":["13.0"],"网络进程接收到":["13.0"],"请求后检查本地缓存是否缓存了该请求资源":["13.0"],"如果有则将该资源返回给浏览器进程":["13.0"],"并行处理就是同一时刻处理多个任务":["14.0"],"vs":["14.1"],"进程":["14.1"],"浏览器进程":["14.2"],"主要负责界面显示":["14.2"],"是匹配相邻元素的选择器":["15.0"],"块级格式化上下文":["16.0"],"根元素":["16.1"],"或包含根元素的元素":["16.1"],"清除浮动":["16.2"],"当一个元素的子元素都是浮动元素时":["16.2"],"chrome":["17.0"],"由于":["17.1","43.0"],"里的":["18.0"],"visibility":["18.0"],"属性有个":["18.0"],"collapse":["18.0"],"属性值":["18.0"],"使元素变成行内元素":["21.0"],"使元素变成块级元素":["21.1"],"block":["21.2"],"不显示":["21.3"],"弹性盒子布局":["21.4"],"实际上是":["22.0"],"grow":["22.0"],"shrink":["22.0"],"和":["22.0","25.0","46.0","56.0","64.5","64.12","64.13","70.6","73.8","77.1","80.9","87.1","88.1","88.4","88.5","89.1","89.2","89.3","89.5","89.6","90.1","92.2","92.3","92.20","92.22"],"basis":["22.0"],"direction":["23.1"],"决定主轴的方向":["23.1"],"row":["23.1"],"reverse":["23.1"],"主轴为水平方向":["23.1"],"起点在左端":["23.1"],"column":["23.1"],"主轴为垂直方向":["23.1"],"起点在上沿":["23.1"],"order":["23.2"],"项目排列顺序":["23.2"],"数值越小越靠前":["23.2"],"默认为":["23.2","30.0"],"import":["24.0"],"是":["24.0","92.13"],"提供的语法规则":["24.0"],"只有导入样式表的作用":["24.0"],"link":["24.0","88.5"],"重叠指的是在垂直方向上":["25.0"],"两个相邻元素的":["25.0"],"发生重叠的情况":["25.0"],"一般来说可以分为四种情形":["25.0"],"第一种是相邻兄弟元素的":["25.0"],"marin":["25.0"],"bottom":["25.0"],"生成绝对定位的元素":["26.0","26.1"],"生成相对定位的元素":["26.2"],"默认值":["26.3"],"规定应该从父元素继承":["26.4"],"单位是根据根元素的":["27.0"],"svg":["28.0"],"使用矢量图形":["28.0"],"可以无限放大而不失真":["28.0"],"canvas":["28.0"],"只能定义两个状态":["29.0"],"右边一栏宽度自适应":["30.0"],"利用浮动":["30.0"],"左边元素定宽":["30.0"],"向左浮动":["30.0"],"float":["30.0"],"右边元素":["30.0"],"宽度设置为":["30.0"],"auto":["30.0"],"撑满整个盒子":["30.0"],"用于当已有元素处于某个状态时":["31.0"],"none":["32.0","92.2"],"把元素隐藏起来":["32.0"],"使元素完全从渲染树中消失":["32.0"],"不占据任何空间":["32.0"],"会改变页面布局":["32.0"],"可以理解为在页面中把该元素删掉":["32.0"],"预解析":["34.0"],"指的是在页面加载过程中":["35.0"],"由于外部样式表加载较慢或延迟":["35.0"],"导致页面先以无样式的方式显示":["35.0"],"然后突然闪烁出样式的现象":["35.0"],"60hz":["36.0"],"就是":["36.0"],"1s":["36.0"],"transform":["38.0"],"box":["38.0"],"background":["38.0"],"color":["38.0"],"red":["38.0"],"100vh":["38.0"],"position":["38.0"],"relative":["38.0"],"元素为行内元素":["39.0"],"设置父元素":["39.0"],"text":["39.0","111.0","118.0"],"clear":["40.1"],"属性":["40.1"],"在浮动元素后添加一个空元素":["40.1"],"相邻边框连接处的均分原理":["41.0"],"test":["41.1"],"盒子模型中":["42.0"],"每个":["42.0"],"元素被表示为一个矩形盒子":["42.0"],"删除":["43.1"],"代码中的空白字符":["43.1"],"选择器":["44.0"],"同一级别":["44.1"],"就近原则":["44.1"],"后者":["45.0"],"ie8":["45.0"],"以下":["45.0"],"async":["46.0"],"defer":["46.0"],"是单线程的":["46.0"],"如果没有":["46.0"],"元素除了导航外":["47.0"],"新特性":["48.0","89.7"],"为了更好的实现语义化":["48.0"],"新增了":["48.0"],"header":["48.0","54.2"],"内容隔离":["49.0"],"当用户选择":["50.0"],"label":["50.0"],"都是告知浏览器提前加载文件":["51.0"],"视频":["51.0","52.0"],"用于替换的当前元素":["52.0"],"用于指定外部资源的地址":["52.0"],"通常用于引入外部文件":["52.0"],"如图片":["52.0"],"音频":["52.0"],"建立":["53.1"],"连接":["53.1"],"const":["53.1","56.0","60.4","100.0","101.0","104.0","116.0","116.2","116.4"],"在一个标签页内使用":["53.2"],"setitem":["53.2"],"key":["53.2","91.6"],"value":["53.2"],"内容":["53.2"],"在另一个标签页里面监听":["53.2"],"storage":["53.2"],"事件":["53.2"],"setinterval":["53.3","108.0"],"将要传递的消息存储在":["53.3"],"语义化的好处":["54.1"],"我认为":["54.1"],"语义化主要指的是我们应该用合适的标签来划分网页内容的结构":["54.1"],"的本质作用其实就是定义网页内容的结构":["54.1"],"页眉":["54.2"],"网站标题":["54.2"],"块级作用域":["56.0"],"引入":["56.0"],"let":["56.0","60.4","114.0","115.0","116.0"],"关键字":["56.0"],"允许在块级作用域中声明变量":["56.0"],"解决了变量提升和作用域污染的问题":["56.0"],"的主要用途是和用户交互以及操作":["57.0"],"所以只能是单线程":["57.0"],"如果不是单线程":["57.0"],"会带来很复杂的同步问题":["57.0"],"比如一个线程在":["57.0"],"节点上添加内容":["57.0"],"另一个线程删除节点":["57.0"],"此时浏览器不知道以那个为准":["57.0"],"同一个时间只能做一件事":["57.0"],"所有任务都需要排队":["57.0"],"前一个任务结束":["57.0"],"才会执行后一个任务":["57.0"],"如果前一个任务耗时很长":["57.0"],"后一个任务就不得不一直等着":["57.0"],"的绑定方式":["58.0"],"默认绑定":["58.0"],"非严格模式下":["58.0"],"指向全局对象":["58.0"],"严格模式下函数内的":["58.0"],"指向":["58.0"],"undefined":["58.0","64.5"],"但是不会改变全局中":["58.0"],"的指向":["58.0"],"隐式绑定":["58.0"],"当函数引用有上下文对象的时候":["58.0"],"比如":["58.0"],"obj":["58.0","103.0","119.0"],"foo":["58.0"],"的调用方式":["58.0"],"内的":["58.0"],"就是说指向调用者":["58.0"],"显示绑定":["58.0"],"标准的":["59.0"],"对象中可以使用事件对象的":["59.0"],"事件捕获阶段":["59.1"],"处于目标阶段":["59.1"],"事件冒泡阶段":["59.1"],"事件流是一个事件沿着特定数据结构传播的过程":["59.1"],"冒泡和捕获是事件流在":["59.1"],"中两种不同的传播方法":["59.1"],"事件捕获":["59.1"],"作用域就是可访问变量的集合":["60.0"],"全局作用域":["60.1"],"指的是声明在函数内部的变量":["60.2"],"块作用域由":["60.3"],"当查找变量的时候":["60.5"],"有权访问另外一个函数作用域中的变量的函数":["60.6"],"主要的就两点":["60.6"],"一是是一个函数":["60.6"],"二是能访问另外一个函数作用域中的变量":["60.6"],"闭包的特性":["60.6"],"可以访问当前函数以外的变量":["60.6"],"即使外部函数已经返回":["60.6"],"闭包仍然能访问外部函数定义的变量":["60.6"],"闭包可以更新外部变量的值":["60.6"],"使用闭包应该注意什么":["60.6"],"内存泄露":["60.6"],"闭包会捕获外部函数的变量":["60.6"],"所以在闭包内部可以访问这些变量":["60.6"],"但是需要注意的是闭包会保持对外部变量的引用":["60.6"],"导致这些变量不会被销毁":["60.6"],"可能导致内存泄露问题":["60.6"],"变量命名冲突":["60.6"],"当闭包内部和外部作用域中存在相同名称的变量的时候":["60.6"],"闭包内部的变量会覆盖外部变量":["60.6"],"所以需要避免变量命名冲突":["60.6"],"闭包的实现原理是什么":["60.6"],"原型被定义为给其它对象提供共享属性的对象":["61.0"],"作用就是当你在访问一个对象上的属性的时候":["61.1"],"原型链是查找对象上的属性":["61.2"],"prototype":["61.3","101.0"],"constructor":["61.3","103.0","104.0","105.0","107.0","112.0"],"对象分为两种":["61.3"],"内存泄漏是指应当被回收的对象没有被正常回收":["62.0"],"创建全局变量":["62.1"],"标记阶段":["62.2"],"将资源被引用的次数保存起来":["62.3"],"及时清除引用":["62.4"],"当前":["63.0"],"全局执行上下文":["63.1"],"只有一个":["63.1"],"是一种":["63.3"],"先进后出":["63.3"],"的数据结构":["63.3"],"主要分为两个阶段":["63.4"],"变量对象是和执行上下文相关的数据作用域":["63.5"],"是什么语言":["64.0"],"都有什么数据类型":["64.1"],"基本数据类型":["64.1"],"string":["64.1"],"symbol":["64.2","64.3"],"主要是为了解决全局变量冲突的问题":["64.2"],"该怎么操作":["64.3"],"bigint":["64.4"],"的区别":["64.5","64.17","65.1","87.1","88.1","89.2","89.6","92.2","92.20"],"是对象吗":["64.6"],"为什么":["64.6"],"数据如何存储":["64.7"],"typeof":["64.8"],"可以判断除了":["64.8"],"null":["64.8"],"之外的原始数据类型":["64.8"],"判断":["64.8"],"instanceof":["64.9"],"方法":["64.9","91.9"],"运算符判断对象是否为数组":["64.9"],"返回布尔值":["64.9"],"object":["64.10","89.0","91.9"],"keys":["64.10"],"number":["64.12"],"is":["64.13","104.0"],"隐式类型转换":["64.14"],"if":["64.15","92.2","92.3","116.3","119.0"],"a":["64.15","113.0"],"map":["64.16","64.17","105.0"],"weakset":["64.17"],"weakmap":["64.17","119.0"],"是一种异步通信的方法":["65.0"],"通过直接由":["65.0"],"脚本向服务器发起":["65.0"],"http":["65.0","69.0","69.1","70.4","70.6","76.0","77.1","77.5"],"通信":["65.0"],"然后根据服务器返回的数据":["65.0"],"更新网页的相应部分":["65.0"],"而不用刷新整个页面的一种方法":["65.0"],"用途":["65.0"],"ajax":["65.1"],"fetch":["65.1"],"cdn":["66.0"],"的基本原理是广泛采用各种缓存服务器":["66.0"],"将这些缓存服务器分布到用户访问相对集中的地区或者网络中":["66.0"],"在用户访问网站的时候":["66.0"],"将其指向距离最近的工作正常的缓存服务器上":["66.0"],"由缓存服务器直接响应用户请求":["66.0"],"主要特点":["66.0"],"本地":["66.0"],"cache":["66.0","77.1","77.3"],"加速":["66.0"],"提高了企业站点":["66.0"],"尤其含有大量图片和静态页面站点":["66.0"],"ip":["67.0","70.3","73.2"],"地址":["67.0"],"如果浏览器缓存中没有命中":["67.0"],"get":["68.0","75.0"],"是从服务器获取指定的资源":["68.0"],"post":["68.0","75.0"],"是超文本传输协议":["69.0"],"明文传输":["69.0"],"存在安全风险的问题":["69.0"],"https":["69.0"],"解决了哪些问题":["69.1"],"存在的问题":["69.1","70.6"],"通过混合加密的方法保证信息的机密性":["69.2"],"握手过程":["69.3"],"第一步":["69.3"],"客户端给出协议版本号":["69.3"],"一个客户端生成的随机数":["69.3"],"对称加密":["69.4"],"对称加密指的就是加密和解密使用同一个秘钥":["69.4"],"所以叫做对称加密":["69.4"],"对称加密只有一个秘钥":["69.4"],"非对称加密":["69.4"],"加密和解密使用不同的秘钥":["69.4"],"一把作为公开的公钥":["69.4"],"另一把作为私钥":["69.4"],"公钥加密的信息":["69.4"],"token":["69.5"],"加密":["69.5"],"需要一个":["69.5"],"简单":["70.1"],"灵活和好扩展":["70.1"],"无状态":["70.2"],"基于":["70.3","80.3"],"tcp":["70.3","70.6","73.0","73.1","73.4"],"使用请求":["70.3"],"应答的通信模式":["70.3"],"在":["70.3","88.2","89.10","90.4","92.5","92.19","93.1"],"主要从以下三个方面来进行考虑":["70.4"],"尽量避免发送":["70.4"],"请求":["70.4","76.0"],"在需要发送":["70.4"],"请求的时候":["70.4"],"考虑如何减少":["70.4"],"请求数":["70.4"],"减少服务器的":["70.4"],"响应的数据大小":["70.4"],"避免发送":["70.4"],"对于一些具有重复性的":["70.4"],"http2":["70.6"],"的出现是为了解决":["70.6"],"http1":["70.6"],"中存在以下问题":["70.6"],"并发连接有限":["70.6"],"比如谷歌浏览器的最大并发连接数是":["70.6"],"个":["70.6"],"而且每一个连接都要经过":["70.6"],"tsl":["70.6"],"握手的耗时":["70.6"],"队头阻塞问题":["70.6"],"同一个连接只能在完成一个":["70.6"],"请求和响应之后":["70.6"],"才能处理下一个请求":["70.6"],"头部巨大而且重复":["70.6"],"因为":["70.6"],"协议是无状态的":["70.6"],"每一个请求都得携带":["70.6"],"客户端发送请求的时候":["71.0"],"用于指定服务器的域名":["71.0"],"当用户在身份认证服务器上登录过一次之后":["72.0"],"即可获取访问单点登录系统中的其它关联系统和应用软件的权限":["72.0"],"实现机制":["72.0"],"当用户第一次访问应用系统":["72.0"],"的时候":["72.0"],"因为还没有登录":["72.0"],"会被引导到认证系统中进行登录":["72.0"],"网络模型有几层":["73.2"],"应用层":["73.2"],"应用层处于最上层":["73.2"],"用户能够直接接触到的就是应用层":["73.2"],"比如手机和电脑上的软件":["73.2"],"应用层的作用主要就是产生数据":["73.2"],"将数据传给传输层":["73.2"],"应用层工作在系统的用户态":["73.2"],"而传输层之下的工作在内核态":["73.2"],"头格式有哪些":["73.3"],"序列号":["73.3"],"在建立连接的时候由计算机生成的随意数作为其初始值":["73.3"],"一开始":["73.5"],"客户端和服务端都是":["73.5"],"close":["73.5"],"状态":["73.5","73.6"],"先是服务端主动监听某个端口":["73.5"],"处于":["73.5"],"listen":["73.5"],"第一次挥手":["73.6"],"客户端发送一个":["73.6"],"fin":["73.6"],"报文":["73.6"],"报文中会指定一个序列号":["73.6"],"此时客户端处于":["73.6"],"wait1":["73.6"],"停止发送数据":["73.6"],"断开连接后如何恢复":["73.7"],"通过":["73.7","95.3"],"session":["73.7"],"udp":["73.8"],"区别":["73.8","92.2"],"是面向连接的":["73.8"],"是无连接的即发送数据前不需要先建立链接":["73.8"],"1xx":["74.0"],"2xx":["74.1"],"成功":["74.1"],"3xx":["74.2"],"表示客户端请求的资源发生了变动":["74.2"],"需要客户端用新的":["74.2"],"4xx":["74.3"],"5xx":["74.4"],"head":["75.0"],"浏览器每隔一段时间向服务器发送":["76.0"],"服务器端在收到请求后":["76.0"],"不论是否有数据更新":["76.0"],"都直接进行":["76.0"],"响应":["76.0"],"这种方式实现的即时通信":["76.0"],"缓存可以减少网络":["77.0"],"io":["77.0"],"消耗":["77.0"],"强缓存是利用":["77.1"],"头中的":["77.1"],"expires":["77.1"],"control":["77.1","77.3"],"两个字段来控制的":["77.1"],"强缓存中":["77.1"],"当请求再次发出时":["77.1"],"浏览器会根据其中的":["77.1"],"判断目标资源是否命中强缓存":["77.1"],"如果命中直接从缓存中获取资源":["77.1"],"不会再与服务端发起通信":["77.1"],"协商缓存依赖于浏览器和服务端之间的通信":["77.2"],"协商缓存机制下":["77.2"],"浏览器需要向服务器去询问缓存的相关信息":["77.2"],"进而判断是重新发起请求":["77.2"],"下载完整的响应":["77.2"],"还是从本地获取缓存的资源":["77.2"],"如果服务端提示资源未改动":["77.2"],"not":["77.2"],"modified":["77.2"],"资源会被重定向到浏览器缓存":["77.2"],"实现协商缓存":["77.2"],"last":["77.2"],"当我们的资源不可复用的时候":["77.3"],"之间为":["77.3"],"为":["77.3"],"no":["77.3"],"store":["77.3","90.1"],"拒绝一切形式的缓存":["77.3"],"否则考虑是否每次都需要向服务器进行缓存有效确认":["77.3"],"如果需要":["77.3"],"设置为":["77.3"],"是一个无状态协议":["77.5"],"服务器接收客户端的请求":["77.5"],"返回一个响应":["77.5"],"持久化的本地存储":["77.6"],"会话级别的存储":["77.7"],"当会话结束":["77.7"],"运行在浏览器上的非关系型数据库":["77.8"],"的缓存和回源机制":["77.9"],"内容分发网络指的是一组分布在各个地区的服务器":["77.9"],"这些服务器存储着数据的副本":["77.9"],"针对图片加载时机的优化":["78.0"],"在一些图片量比较大的网站":["78.0"],"如果尝试在用户打开页面的时候":["78.0"],"本质上都是闭包":["78.1"],"首先是客户端渲染":["79.0"],"在客户端渲染模式下":["79.0"],"服务端会把渲染需要的静态文件发送给客户端":["79.0"],"客户端加载过来之后":["79.0"],"自己在浏览器里跑一遍":["79.0"],"渲染过程":["79.1"],"简单来说就是渲染引擎根据":["79.1"],"文件描述构建相应的数学模型了":["79.1"],"调用浏览器各个模块":["79.1"],"将网页资源代码转换成图像结果":["79.1"],"这个过程就是渲染过程":["79.1"],"解释器":["79.1"],"优化":["79.2","79.3"],"避免使用通配符":["79.2"],"只对需要用到的元素进行选择":["79.2"],"关注可以通过继承实现的属性":["79.2"],"避免重复匹配重复定义":["79.2"],"少用标签选择器":["79.2"],"减少嵌套":["79.2"],"是阻塞渲染的资源":["79.2"],"树和":["79.2"],"cssom":["79.2"],"合并构建成渲染树":["79.2"],"减少":["79.3"],"操作":["79.3","91.8"],"回流":["79.3"],"有三个地方可以进行优化":["80.0"],"分别是":["80.0"],"dns":["80.0"],"loader":["80.2","92.24","95.1","95.3","97.1"],"做太多事情":["80.2"],"dllplugin":["80.3"],"这个插件会把第三方库单独打包到一个文件中":["80.3"],"这个文件就是一个单纯的依赖库":["80.3"],"这个依赖库不会跟着你的业务代码一起被打包":["80.3"],"只有当依赖自身发生版本变化时才会重新打包":["80.3"],"的步骤":["80.3"],"dll":["80.3"],"的配置文件":["80.3"],"打包":["80.3"],"库":["80.3"],"happypack":["80.4"],"将":["80.4"],"loder":["80.4"],"将文件结果可视化":["80.5"],"找出导致体积过大的原因":["80.5"],"包组成可视化工具":["80.5"],"webpack":["80.5","96.0","96.1","97.1"],"bundle":["80.5"],"analyer":["80.5"],"配置方式和普通":["80.5"],"plugin":["80.5"],"一样":["80.5"],"能够以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来":["80.5"],"压缩":["80.6"],"在请求头中通过":["80.6"],"accept":["80.6"],"encoding":["80.6"],"来开启":["80.6"],"图片在所有资源中所占的比重是非常大的":["80.7"],"当下应用比较广泛的":["80.7"],"web":["80.7","82.0"],"图片格式有":["80.7"],"jpg":["80.8"],"有损压缩":["80.8"],"体积小":["80.8","80.10"],"加载快":["80.8"],"是一种无损压缩的高保真的图片格式":["80.9"],"文本文件":["80.10","80.11"],"不失真":["80.10"],"兼容性好":["80.10"],"依赖编码":["80.11"],"小图标解决方案":["80.11"],"和精灵图一样":["80.11"],"都是用于解决小图标的":["80.11"],"精灵图就是将小图标合并到一张图片上":["80.11"],"然后利用":["80.11"],"google":["80.12"],"开发的旨在加快图片加载速度的图片格式":["80.12"],"支持有损压缩和无损压缩":["80.12"],"优点":["80.12"],"具备":["80.12"],"防护原理":["81.0"],"sql":["82.0"],"命令插入到":["82.0"],"cross":["83.0"],"site":["83.0"],"scripting":["83.0"],"是明文传输":["84.0"],"中的加密":["84.1"],"对称密钥加密是最简单的一种加密方式":["84.2"],"加解密都是相同的密钥":["84.2"],"加密过程":["84.3"],"客户端请求网址":["84.3"],"例如www":["84.3"],"客户端请求被劫持":["84.4"],"将所有的请求发送到中间人的服务器":["84.4"],"中间人服务器返回自己的证书":["84.4"],"使用正规厂商的证书":["84.5"],"验证文件类型和大小":["85.0"],"防止恶意破解":["86.0"],"的":["87.0","90.1","91.8"],"deep":["87.0"],"watch":["87.1","90.2"],"的实现":["87.2"],"初始化":["87.2"],"data":["87.2","92.1"],"本质上是为每个监听属性":["87.3"],"setter":["87.3","91.9"],"路由传参":["88.0"],"router":["88.1","88.8"],"怎么获取传过来的参数":["88.2"],"里面":["88.3"],"history":["88.4","88.6"],"路由模式实现原理":["88.4"],"模式":["88.4"],"早期的前端路由的实现就是基于":["88.4"],"location":["88.4"],"来实现的":["88.4"],"其实现原理很简单":["88.4"],"的值就是":["88.4"],"中":["88.4","90.1","90.4","91.6","95.3"],"后面的内容":["88.4"],"比如下面这个网站":["88.4"],"它的":["88.4"],"view":["88.5","92.13"],"是怎么起作用的":["88.5"],"vue":["88.5","88.10","91.7","91.8","91.11","92.0","92.1","92.11","92.19","92.21","92.25","93.0"],"有哪些方法吗":["88.6"],"这个对象在":["88.6"],"html5":["88.6"],"pushstate":["88.7"],"如何保护路由":["88.8"],"当打包构建应用时":["88.9"],"包会变得非常大":["88.9"],"影响页面加载":["88.9"],"路由":["88.10"],"一个":["88.10"],"spa":["88.10","92.7"],"应用的路由需要解决的问题是":["88.10"],"与":["89.0","92.16"],"defineproperty":["89.0","91.9"],"优劣对比":["89.0"],"watcheffect":["89.2"],"api":["89.3","89.6","89.7"],"options":["89.3"],"对":["89.4"],"vue2":["89.4","89.5","91.4","91.9","92.14"],"react":["89.6"],"hooks":["89.6"],"层面":["89.7"],"新特性主要包括":["89.7"],"composition":["89.7"],"速度快的原因":["89.8"],"性能提升体现在哪些方面":["89.8"],"代码层面性能优化主要体现在全新响应式":["89.8"],"ref":["89.9","92.16","92.23"],"toref":["89.9"],"torefs":["89.9"],"为什么需要用":["89.9"],"返回值类型":["89.9"],"会丢失响应式":["89.9"],"如何获取组件实例":["89.10"],"vuex":["90.0","90.2","90.4","90.5"],"actions":["90.1"],"mutations":["90.1"],"有什么区别":["90.1"],"改":["90.1"],"中的状态的唯一方法是提交":["90.1"],"数据的变化":["90.2"],"可以通过":["90.2"],"选项或者":["90.2"],"页面刷新数据丢失怎么解决":["90.3"],"只是在内存保存状态":["90.3"],"刷新之后就会丢失":["90.3"],"有什么优点":["90.4"],"是什么":["90.4","92.24","95.0"],"vue3":["90.4"],"可以使用传统的":["90.4"],"来实现状态管理":["90.4"],"也可以使用最新的":["90.4"],"说说思路":["90.5"],"官方说":["90.5"],"是一个状态管理模式和库":["90.5"],"并确保这些状态以可预期的方式变更":["90.5"],"采用数据劫持结合发布者":["91.0"],"编译":["91.1"],"转换成":["91.1"],"ast":["91.1"],"树":["91.1"],"得到":["91.1"],"render":["91.1"],"函数返回":["91.1"],"set":["91.2","117.0"],"作用是什么":["91.3"],"只是一层真实":["91.3"],"的抽象":["91.3"],"以":["91.3"],"对象作为基础的树":["91.3"],"怎么检测数组的变化":["91.4"],"怎么进行依赖收集":["91.5"],"依赖收集的目的是等数据变化了可以自动更新视图":["91.5"],"的作用和原理":["91.6"],"给每一个":["91.6"],"vnode":["91.6"],"一个唯一的":["91.6"],"可以依靠":["91.6"],"过程做了什么":["91.7"],"内部会初始化组件绑定的事件":["91.7"],"初始化组件的父子关系":["91.7"],"children":["91.7","92.16","113.0","118.0"],"算法原理":["91.8"],"操作是非常昂贵的":["91.8"],"因此我们需要尽量地减少":["91.8"],"这就需要找出本次":["91.8"],"必须更新的节点来更新":["91.8"],"其他的不更新":["91.8"],"这个找出的过程":["91.8"],"就需要应用":["91.8"],"算法":["91.8"],"数据劫持":["91.9"],"观察者模式":["91.9"],"对象内部通过":["91.9"],"definereactive":["91.9"],"来劫持各个属性的":["91.9"],"getter":["91.9"],"只会劫持已经存在的属性":["91.9"],"数组则是通过":["91.9"],"重写数组7个方法":["91.9"],"来实现":["91.9"],"当页面使用对应属性时":["91.9"],"每个属性都拥有自己的":["91.9"],"实例挂载的过程中发生了什么":["91.10"],"挂载过程指的是":["91.10"],"采用异步渲染":["91.11"],"是组件级更新":["91.11"],"实现原理":["91.12","91.13"],"主要是使用了宏任务和微任务":["91.12"],"定义一个异步方法":["91.12"],"多次调用":["91.12"],"会将方法存入到队列中":["91.12"],"通过这个异步方法清空当前队列":["91.12"],"中的回调是在下次":["91.12"],"model":["91.13","92.13","92.20"],"我们在":["91.13"],"算法的时间复杂度":["91.14"],"的理解":["92.0","92.9","92.13","92.21"],"组件中":["92.1"],"show":["92.2"],"隐藏则是为该元素添加":["92.2"],"v":["92.3","92.20"],"for":["92.3","114.0","115.0","116.0"],"初始化页面闪动问题":["92.5"],"请求应该放在":["92.6"],"methods":["92.6"],"页面的理解":["92.7"],"优缺点":["92.7"],"首屏加载慢怎么解决":["92.8"],"什么叫首屏加载时间":["92.8"],"浏览器从响应用户输入网站地址":["92.8"],"keep":["92.9"],"alive":["92.9"],"observable":["92.10"],"通过数据劫持可以精准探测数据变化":["92.11"],"mixin":["92.12"],"使用场景和原理":["92.12"],"在日常的开发中":["92.12"],"mvvm":["92.13"],"viewmodel":["92.13"],"缩写":["92.13"],"也就是把":["92.13"],"组件为什么只有一个根元素":["92.14"],"中组件确实只能有一个根":["92.14"],"函数式组件需要在声明组件是指定":["92.15"],"functional":["92.15"],"true":["92.15"],"不需要实例化":["92.15"],"所以没有":["92.15"],"this":["92.15","101.0","104.0","105.0","107.0","112.0"],"props":["92.16"],"emit":["92.16"],"适用":["92.16"],"父子组件通信":["92.16"],"父组件向子组件传递数据是通过":["92.16"],"prop":["92.16","92.18"],"传递的":["92.16"],"子组件传递数据给父组件是通过":["92.16"],"触发事件来做到的":["92.16"],"vue3废弃":["92.16"],"如果在普通的":["92.16"],"元素上使用":["92.16"],"如何扩展一个组件":["92.17"],"常见的组件扩展方法有":["92.17"],"所有的":["92.18"],"都使得其父子之间形成了一个单向下行绑定":["92.18"],"父级":["92.18"],"组件是什么":["92.19"],"组件就是把图形":["92.19"],"非图形的各种逻辑均抽象为一个统一的概念":["92.19"],"组件":["92.19","92.21"],"来实现开发的模式":["92.19"],"中每一个":["92.19"],"文件都可以视为一个组件":["92.19"],"组件的优势":["92.19"],"降低整个系统的耦合度":["92.19"],"在保持接口不变的情况下":["92.19"],"我们可以替换不同的组件快速完成需求":["92.19"],"是构建客户端应用程序的框架":["92.21"],"默认情况下":["92.21"],"可以在浏览器中输出":["92.21"],"进行生成":["92.21"],"和操作":["92.21"],"然而":["92.21"],"也可以将同一个组件渲染为服务端的":["92.21"],"字符串":["92.21"],"将它们直接发送到浏览器":["92.21"],"最后将这些静态标记":["92.21"],"激活":["92.21"],"为客户端上完全可交互的应用程序":["92.21"],"也就是服务端渲染":["92.21"],"也就是将":["92.21"],"在客户端把标签渲染成":["92.21"],"的作用":["92.23"],"有什么作用":["92.24"],"是用于处理单文件组件":["92.24"],"sfc":["92.24"],"到":["92.25"],"自己构架一个":["92.25"],"项目":["92.25"],"有哪些步骤":["92.25"],"哪些重要插件":["92.25"],"目录结构怎么组织":["92.25"],"创建一个项目我大致会做以下事情":["92.25"],"项目构建":["92.25"],"的生命周期即一个":["93.0"],"实例从被创建到被销毁的过程":["93.0"],"可以分为":["93.0"],"个阶段":["93.0"],"beforecreate":["93.0","93.2"],"实例创建前":["93.0"],"created":["93.0"],"实例创建完成":["93.0"],"beforemount":["93.0"],"挂载前":["93.0"],"mounted":["93.0"],"挂载完成":["93.0"],"beforeupdate":["93.0"],"beforedestory":["93.1"],"的父组件和子组件生命周期钩子函数执行顺序":["93.2"],"加载渲染过程":["93.2"],"父":["93.2"],"可以在":["93.3"],"主要用于将新版本的代码转换为向后兼容的":["94.0"],"语法":["94.0"],"polyfill":["94.0"],"方式":["94.0"],"作用":["95.1"],"将css内容":["95.1"],"的执行顺序":["95.2"],"style":["95.3"],"注入到":["95.3"],"自定义一个名为myplugin插件":["96.2"],"该插件在打包完成后":["96.2"],"构建流程":["97.0"],"从项目的":["97.1"],"entry":["97.1"],"入口文件开始递归分析":["97.1"],"调用所有配置的":["97.1"],"对模块进行编译":["97.1"],"hash":["98.0","119.0"],"和整个项目的构建相关":["98.0"],"开发过程中":["99.0"],"主要是通过":["99.1"],"webscoket":["99.1"],"实现":["99.1"],"建立本地服务器和浏览器的双向通信":["99.1"],"当代码变化后":["99.1"],"重新编译后":["99.1"],"getjson":["100.0"],"function":["100.0","101.0","102.0","103.0","107.2","108.0","109.0","110.0","114.0","115.0","116.0","116.1","116.2","116.3","116.4","119.0","120.0"],"return":["100.0","107.1"],"new":["100.0","105.0","117.0","119.0"],"call":["101.0"],"mycall":["101.0"],"context":["101.0"],"args":["101.0"],"window":["101.0"],"fn":["101.0","107.0","107.2"],"由右向左依次执行函数":["102.0"],"compose":["102.0"],"fns":["102.0"],"myinstanceof":["103.0"],"class":["104.0","105.0","107.0","107.1","112.0"],"lazyman":["104.0"],"name":["104.0"],"tasks":["104.0"],"task":["104.0"],"console":["104.0"],"log":["104.0"],"hi":["104.0"],"缓存淘汰策略":["105.0"],"移除最近最少被访问的数据项":["105.0"],"lrucache":["105.0"],"capacity":["105.0"],"创建一个对象":["106.0"],"该对象的原型指向构造函数的原型":["106.0"],"调用该构造函数":["106.0"],"构造函数的":["106.0"],"resolve时的回调函数列表":["107.0"],"resolvetask":["107.0"],"reject时的回调函数列表":["107.0"],"rejecttask":["107.0"],"state记录当前状态":["107.0"],"共有pending":["107.0"],"fulfilled":["107.0"],"rejected":["107.0"],"3种状态":["107.0"],"all":["107.1"],"promise":["107.1"],"race静态方法":["107.1"],"返回promises列表中第一个执行完的结果":["107.1"],"static":["107.1"],"promises":["107.1"],"param":["107.2"],"方法名":["107.2"],"模拟实现":["108.0"],"mysetinterval":["108.0"],"callback":["108.0","112.0"],"delay":["108.0"],"curry":["110.0"],"节点1":["111.0","118.0"],"parentid":["111.0","118.0"],"这里用0表示为顶级节点":["111.0"],"eventemitter":["112.0"],"创建一个空对象存储事件和对应的回调函数":["112.0"],"events":["112.0"],"实现订阅":["112.0"],"on":["112.0"],"type":["112.0"],"检查是否已经存在该类型的事件订阅":["112.0"],"tag":["113.0"],"attrs":["113.0"],"app":["113.0"],"span":["113.0"],"递归的方法":["114.0","115.0"],"flat":["114.0","115.0"],"arr":["114.0","115.0","116.0","116.2","116.4","117.0"],"res":["114.0","115.0"],"bubblesort":["116.0"],"缓存数组长度":["116.0","116.2"],"len":["116.0","116.2","116.4"],"length":["116.0","116.3","116.4"],"外层循环用于控制从头到尾的比较":["116.0"],"交换到底有多少轮":["116.0"],"i":["116.0"],"内层循环用于完成每一轮遍历过程中的重复比较":["116.0"],"循环遍历数组":["116.1"],"每次都找出当前范围内的最小值":["116.1"],"把它放在当前范围的头部":["116.1"],"然后缩小排序范围":["116.1"],"重复":["116.1"],"直到数组完全有序":["116.1"],"selectsort":["116.1"],"找到元素在它前面那个序列中的正确位置":["116.2"],"insertsort":["116.2"],"定义一个名为sortarray的函数":["116.3"],"它接受一个数组nums作为输入参数":["116.3"],"var":["116.3"],"sortarray":["116.3"],"nums":["116.3"],"如果数组长度小于2":["116.3"],"表示数组已经有序或为空":["116.3"],"直接返回原数组":["116.3"],"将需要被排序的数组从中间分割为两半":["116.4"],"然后再将分割出来的每个子数组各分割为两半":["116.4"],"重复以上操作":["116.4"],"直到单个子数组只有一个元素为止":["116.4"],"从粒度最小的子数组开始":["116.4"],"两两合并":["116.4"],"确保每次合并出来的数组都是有序的":["116.4"],"mergesort":["116.4"],"方法1":["117.0"],"使用set":["117.0"],"方法2":["117.0"],"使用includes":["117.0"],"deepclone":["119.0"],"某个函数在一定时间间隔内只执行一次":["121.0"],"在规定的延迟时间内无视后来产生的函数调用请求":["121.0"],"也不会延长时间":["121.0"],"控制函数执行频率的技术":["121.0"],"确保函数在一定时间间隔内最多执行一次":["121.0"],"以减轻高频率触发函数的性能问题":["121.0"],"一般情况下处理事件监听":["121.0"],"是指某个函数在规定的时间段内":["121.1"],"无论触发多少次回调":["121.1"],"只执行最后":["121.1"],"一般用于处理需要等待一段时间后稳定下来的事件":["121.1"],"比如输入框的输入事件":["121.1"],"滚动事件":["121.1"],"窗口大小调":["121.1"]},{"0":["23.2","41.1","60.6","70.3","102.0","107.1","114.0","115.0","116.3"],"1":["35.0","63.3","63.4","64.15","70.3","73.5","73.6","88.10","97.0","99.1","116.0","116.3","116.4"],"2":["30.0","33.0","39.0","40.1","61.3","63.1","64.9","66.0","68.0","84.3","88.9","90.3","91.12","92.14","92.24","92.25","116.4","118.0"],"3":["56.0","64.11","66.0","84.3","92.15","92.25","106.0"],"4":["58.0"],"5":["58.0","60.6"],"10":["6.26"],"50":["38.0"],"60":["36.0"],"100":["6.26"],"200":["6.26","74.1","77.1"],"256":["80.9"],"这里主要记录后端知识点":["0.0"],"这里主要记录突发奇想":["2.0"],"这里主要记录框架相关知识点":["3.0"],"那么内容就像水一样":["5.0"],"为什么要设计响应式":["5.0"],"首先":["5.0","91.1"],"可以脱离":["5.1"],"的控制":["5.1"],"适用于":["5.1","92.16"],"布局":["5.1","43.1"],"nth":["5.1"],"child":["5.1"],"选择指定元素":["5.1"],"通过":["5.1","58.0","73.3","73.8","91.1","92.15","99.1"],"筛选指定的元素设置样式":["5.1"],"适用于表格着色":["5.1"],"边界元素排版":["5.1"],"使用":["6.2","43.1","62.4","64.3","81.0","92.4"],"text":["6.2","6.4","75.0","88.4"],"align":["6.2","6.4","6.11","33.0","39.0"],"auto":["6.3","6.17"],"必须定宽":["6.3"],"优点":["6.3","40.1","65.0","92.21"],"center":["6.4","6.27","39.0"],"position":["6.5","6.10","6.15","6.16","26.4"],"relative":["6.5","6.10","6.15","6.16"],"父相":["6.5","6.10"],"background":["6.5","30.0"],"color":["6.5","30.0"],"f00":["6.5"],"son":["6.5","6.15","6.16","6.17","38.0"],"parent":["6.6","6.8","6.9","6.13","6.23"],"display":["6.6"],"css":["6.8","6.26","51.0","79.1","80.11","97.1"],"或者用span把所有文字包裹起来":["6.9"],"设置display":["6.9"],"top":["6.10","25.0","88.4"],"right":["6.10","6.21","6.26","30.0"],"bottom":["6.10"],"left":["6.10","6.19","6.20","6.21","6.22","6.23","6.24","6.27"],"的值是相对于父元素尺寸的":["6.10"],"然后":["6.10"],"margin":["6.10","6.17"],"或者":["6.10","92.25"],"transform":["6.10"],"是相对于自身尺寸的":["6.10"],"组合使用达到水平居中的目的":["6.10"],"height":["6.10","6.13","6.14","41.1"],"150px":["6.10","6.13","6.14"],"flex":["6.11","23.2","33.0","43.1"],"items":["6.11"],"width":["6.14","6.26"],"右列自适应":["6.18","6.26"],"id":["6.19","6.20","53.2"],"左列定宽":["6.19","6.20","6.21","6.22","6.27"],"左列不定宽":["6.23","6.24"],"一列自适应":["6.25"],"min":["6.26"],"310px":["6.26"],"防止宽度不够":["6.26"],"子元素换行":["6.26"],"10px":["6.26"],"中间定宽":["6.27"],"这里主要记录前端基础知识":["7.0"],"浏览器就会将网页缩放至原始比例":["9.0"],"当用户点击屏幕一次之后":["9.0"],"浏览器并不会判断用户确实要打开至这个链接":["9.0"],"还是想要进行双击操作":["9.0"],"所以":["9.0","88.10"],"解析":["10.0","13.0","79.1","80.0"],"文件生成":["10.0"],"cssom":["10.0"],"将":["10.0","43.1","79.1"],"和":["10.0","61.3","73.2","77.3","88.6","88.7","91.6","91.8","93.0","93.3"],"结合":["10.0"],"render":["10.0","92.15"],"渲染树":["10.0"],"根据":["10.0","91.8"],"突破浏览器并发限制":["11.0"],"引擎":["12.0"],"渲染引擎":["12.0"],"负责解析网页的":["12.0"],"如果没有":["13.0","57.0"],"网络进程向":["13.0"],"web":["13.0","83.0","92.7"],"服务器发起":["13.0"],"http":["13.0","69.4","70.1","70.3"],"请求":["13.0"],"网络请求":["13.0"],"请求流程如下":["13.0"],"进行":["13.0","92.11"],"dns":["13.0"],"获取服务器":["13.0"],"ip":["13.0","73.0"],"地址":["13.0"],"端口":["13.0"],"端口是通过":["13.0"],"一个进程就是一个程序的运行实例":["14.1"],"启动一个程序的时候":["14.1"],"用户交互":["14.2"],"子进程管理":["14.2"],"同时提供存储功能":["14.2"],"bfc":["16.0","25.0"],"浮动元素":["16.1"],"元素的":["16.1"],"float":["16.1"],"属性不为":["16.1"],"它将会塌陷":["16.2"],"不会正常地包裹子元素":["16.2"],"记住密码后自动填充表单的黄色背景":["17.0"],"chrome":["17.1"],"在":["17.2","59.0","69.0","77.1","91.9","92.3"],"form":["17.2","77.1"],"在不同浏览器下有什么区别":["18.0"],"通常用于表格的行和列":["18.0"],"当用于行上的时候":["18.0"],"该行会被隐藏":["18.0"],"并且不会占据任何空间":["18.0"],"相邻的行自动合并":["18.0"],"新增伪类和伪元素":["19.0"],"通用选择器":["19.0"],"文件":["20.0","24.0","80.3","97.1"],"拥有行内元素的特性":["21.0"],"可以和其它行内元素共占一行":["21.0"],"独占一行":["21.1"],"可以和其他元素共占一行":["21.2"],"三个属性的缩写":["22.0"],"定义项目的的放大比例":["22.0"],"默认为":["22.0"],"如果存在剩余空间":["22.0"],"元素也不会放大":["22.0"],"设置为":["22.0"],"代表会放大":["22.0"],"等分剩余空间":["22.0"],"布局的元素":["23.0"],"起点在下沿":["23.1"],"wrap":["23.1"],"如果主轴排列不下":["23.1"],"通过这个属性判断是否换行":["23.1"],"换行":["23.1"],"在第一行下方":["23.1"],"grow":["23.2"],"如果不换行":["23.2"],"容器宽度不够分的情况":["23.2"],"html":["24.0","43.0","79.2","83.0","92.7"],"提供的标签":["24.0"],"不仅可以加载":["24.0"],"还可以定义":["24.0"],"的值发生重叠":["25.0"],"这种情况下我们可以通过设置其中一个元素为":["25.0"],"来解决":["25.0"],"第二种是父元素的":["25.0"],"和子元素的":["25.0"],"相对于":["26.0"],"相对于浏览器窗口进行定位":["26.1"],"相对于其正常位置进行定位":["26.2"],"没有定位":["26.3"],"size":["27.0"],"来计算":["27.0"],"使用像素图形":["28.0"],"图像不可以无限放大不失真":["28.0"],"编辑和修改":["28.0"],"开始状态和结束状态":["29.0"],"tomato":["30.0"],"gold":["30.0"],"左侧元素设置固定大小":["30.0"],"并左浮动":["30.0"],"右侧元素设置":["30.0"],"为其添加对应的部分":["31.0"],"这个状态是根据用户行为而动态变化的":["31.0"],"非继承属性":["32.0"],"子孙节点消失是因为元素本身从渲染树中消失":["32.0"],"修改子孙节点的属性无法使其显示":["32.0"],"会导致重排":["32.0"],"读屏器不会读取":["32.0"],"元素的内容":["32.0"],"vertial":["33.0"],"middle":["33.0"],"tcp":["34.0","69.0","80.0"],"解决":["35.0"],"将样式表放在文档的":["35.0"],"head":["35.0"],"中":["35.0","53.3","70.3","70.6","92.3"],"刷新":["36.0"],"次":["36.0"],"overflow":["37.0"],"hidden":["37.0"],"white":["37.0"],"space":["37.0"],"green":["38.0"],"200px":["38.0"],"设置了top和left":["38.0"],"之后":["38.0","73.6"],"子元素的左上角位于父盒子的中心位置":["38.0"],"使用transform将子元素向左上移动自身元素的50":["38.0"],"如果元素宽度固定":["39.0"],"可以设置左右":["39.0"],"浮动元素脱离了标准文档流":["40.0"],"对其设置":["40.1"],"both":["40.1"],"简单":["40.1"],"将元素的宽高设置为":["41.0"],"盒子包括四个部分":["42.0"],"内存区域":["42.0"],"content":["42.0","70.6","75.0"],"内边距区域":["42.0"],"padding":["42.0"],"类选择器":["44.0"],"后写的覆盖先写的":["44.1"],"不同级别":["44.1"],"addeventlistener":["45.0"],"可有冒泡":["45.0"],"可有捕获":["45.0"],"或":["46.0"],"属性":["46.0","91.5","91.9"],"浏览器会立即加载并执行相应的脚本":["46.0"],"不会等到后续加载的文档元素":["46.0"],"还有什么作用":["47.0"],"创建内部书签链接":["47.0"],"footer":["48.0"],"nav":["48.0","54.2"],"aside":["48.0"],"article":["48.0"],"允许在一个网页中嵌套另一个网页":["49.0"],"实现内容隔离":["49.0"],"标签时":["50.0"],"浏览器会自动将焦点转到和":["50.0"],"等":["51.0"],"但执行上是有区别的":["51.0"],"区别":["51.0","60.4"],"脚本等":["52.0"],"指向的内容会嵌入到文档中当前标签所在的位置":["52.0"],"常用于":["52.0"],"img":["52.0"],"script":["52.0"],"iframe":["52.0"],"audio":["52.0"],"video":["52.0"],"socket":["53.1"],"new":["53.1","58.0","66.0","91.9","93.0","107.1"],"ws":["53.1"],"your":["53.1"],"标签页1":["53.2"],"input":["53.2"],"name":["53.2"],"lt":["53.2"],"type":["53.2","75.0","90.1"],"quot":["53.2"],"button":["53.2"],"每隔一段时间读取":["53.3"],"一个语义化的文档":["54.1"],"能够使页面的结构更加清晰":["54.1"],"易于理解":["54.1","76.0"],"这样不仅有利于开发者的阅读和理解":["54.1"],"同时也能够使机器对文档内容进行正确的解读":["54.1"],"比如说我们常用的":["54.1"],"导航菜单等":["54.2"],"导航部分":["54.2"],"通常包含网站的主要导航链接":["54.2"],"面试题总结与归纳":["55.0"],"箭头函数":["56.0","58.0"],"使用箭头":["56.0"],"定义函数":["56.0"],"简化了函数的书写":["56.0"],"并且自动绑定了":["56.0"],"this":["56.0","106.0"],"模板字符串":["56.0"],"使用反引号":["56.0"],"包裹字符串":["56.0"],"可以在字符串中使用变量和表达式":["56.0"],"所有任务可以分成两种":["57.0"],"一种是宏任务":["57.0"],"另一种是微任务":["57.0"],"宏任务指的是":["57.0"],"在主线程上排队执行的任务":["57.0"],"只有前一个任务执行完毕":["57.0"],"才能执行下一个任务":["57.0"],"微任务指的是":["57.0"],"不进入主线程":["57.0"],"而进入":["57.0"],"微任务队列":["57.0"],"的任务":["57.0"],"当前宏任务执行完后":["57.0"],"会判断微任务列表中是否有任务":["57.0"],"如果有":["57.0"],"会把该微任务放到主线程中并执行":["57.0"],"就继续执行下一个宏任务":["57.0"],"call":["58.0"],"apply":["58.0"],"bind":["58.0"],"方法直接指定":["58.0"],"的指向对象":["58.0"],"构造函数":["58.0"],"指向新生成的对象":["58.0","106.0"],"指向的是定义这个箭头函数的时候":["58.0"],"外层环境中的":["58.0"],"箭头函数在定义的时候就指定了":["58.0"],"不能改变":["58.0"],"js":["58.0","60.6","80.3","80.5","97.1"],"use":["58.0"],"strict":["58.0"],"var":["58.0","60.6"],"a":["58.0"],"stoppropagation":["59.0"],"方法来阻止冒泡":["59.0"],"当鼠标点击或者触发":["59.1"],"事件时":["59.1"],"浏览器会从根节点开始由外到内进行事件传播":["59.1"],"就是说点击了子元素":["59.1"],"如果父元素通过事件捕获方式注册了对应的事件的话":["59.1"],"会先触发父元素绑定的事件":["59.1"],"事件冒泡":["59.1"],"做大的作用就是隔离变量":["60.0"],"函数作用域和块级作用域":["60.1"],"函数的作用域在函数":["60.2"],"包括":["60.3"],"if":["60.3","77.2","102.0","103.0","105.0","107.0","112.0","114.0","115.0","116.0","116.4"],"没有块级作用域概念":["60.4"],"会先从当前上下文的变量对象中查找":["60.5"],"利用了作用域链的特性":["60.6"],"在当前执行环境下访问某个变量的时候":["60.6"],"如果不存在就一直向外层寻找":["60.6"],"最终寻找到最外层也就是全局作用域":["60.6"],"原始题目":["60.6"],"for":["60.6","64.3","107.1","116.2","117.0"],"i":["60.6","107.1","114.0","115.0"],"settimeout":["60.6","104.0"],"function":["60.6","95.1"],"console":["60.6"],"log":["60.6"],"1s":["60.6"],"后打印出":["60.6"],"个":["60.6"],"函数的实例可以共享原型上的属性和方法":["61.0"],"如果该对象内部不存在这个属性":["61.1"],"作用域链是查找当前上下文中的变量":["61.2"],"普通对象和函数对象":["61.3"],"导致内存占用越来越高":["62.0"],"被遗忘的计时器或回调函数":["62.1"],"闭包":["62.1"],"垃圾回收器从根对象开始遍历":["62.2"],"每一个可以从根对象访问到的对象都会被添加一个标识":["62.2"],"当被引用次数为零时释放":["62.3"],"javascript":["63.0"],"浏览器环境下为":["63.1"],"window":["63.1","66.0"],"单线程":["63.2"],"只在主线程上运行":["63.2"],"用来存储代码运行的所有执行上下文":["63.3"],"当":["63.3"],"创建阶段":["63.4"],"存储了上下文中定义的变量和函数声明":["63.5"],"是一个抽象的概念":["63.5"],"number":["64.1","107.2"],"boolean":["64.1"],"null":["64.1","119.0"],"undefined":["64.1"],"比如定义了一个全局对象":["64.2"],"用来缓存数据":["64.2"],"作用是什么":["64.4"],"支持比":["64.4"],"空值":["64.5"],"语义是表示一个对象被认为的重置为空对象":["64.5"],"不是一个变量最原始的状态":["64.5"],"使用场景":["64.5"],"typeof":["64.6","103.0","119.0"],"object":["64.6","64.8","87.2","103.0","119.0"],"基本数据类型用栈存储":["64.7"],"栈内存的特点的分配固定大小的内存空间":["64.7"],"为":["64.8"],"对于引用类型":["64.8"],"会判断为":["64.8"],"例如":["64.9"],"arr":["64.9","116.1"],"array":["64.9","114.0","115.0"],"constructor":["64.9"],"obj":["64.10"],"怎么解决":["64.11"],"原因":["64.11"],"当计算机计算":["64.11"],"函数的区别":["64.12"],"接收参数后":["64.12"],"的区别":["64.13","89.1"],"两边类型不一致":["64.13"],"会进行强制类型转换再进行比较":["64.13"],"转换过程":["64.14"],"parseint":["64.16"],"答案是多少":["64.16"],"答案":["64.16"],"nan":["64.16"],"第一个参数":["64.16"],"str":["64.16"],"成员不能重复":["64.17"],"只有健值":["64.17"],"没有健名":["64.17"],"有点类似数组":["64.17"],"可以遍历":["64.17"],"方法有":["64.17"],"无刷新获取服务器数据":["65.0"],"通过异步模式":["65.0"],"提升了用户体验":["65.0"],"优化了浏览器和服务器之间的传输":["65.0"],"减少不必要的数据往返":["65.0"],"减少了带宽占用":["65.0"],"在客户端运行":["65.0"],"承担了一部分本来由服务器承担的工作":["65.0"],"是一种技术统称":["65.1"],"基于原生的":["65.1"],"xhr":["65.1","100.0"],"开发":["65.1"],"已经有了":["65.1"],"的访问速度":["66.0"],"并大大提高以上性质站点的稳定性":["66.0"],"镜像服务":["66.0"],"消除了不同运营商之间互联的瓶颈造成的影响":["66.0"],"实现了跨运营商的网络加速":["66.0"],"保证不同网络中的用户都能得到良好的访问质量":["66.0"],"远程加速":["66.0"],"远程访问":["66.0"],"opens":["66.0"],"用户根据":["66.0"],"dns负载均衡":["66.0"],"将继续查找本级":["67.0"],"操作系统":["67.0"],"是否缓存过该":["67.0"],"是根据请求报文对指定的资源做出处理":["68.0"],"请求的参数一般放在":["68.0"],"是为了解决":["69.0"],"不安全的缺陷":["69.0"],"窃听风险":["69.1"],"通信链路上可以获取通信内容":["69.1"],"用户信息容易泄露":["69.1"],"采用对称加密和非对称加密的方式在通信建立前采用非对称加密的方式交换会话密钥":["69.2"],"client":["69.3"],"random":["69.3"],"以及客户端支持的加密方法":["69.3"],"第二步":["69.3"],"只有私钥才能解密":["69.4"],"通过上面的握手过程可知":["69.4"],"https":["69.4","84.0","88.4"],"在证书验证阶段":["69.4"],"使用非对称加密来传输共享秘钥":["69.4"],"之后的传输中都使用对称加密方式":["69.4"],"原因是":["69.4"],"非对称加密的加解密效率是非常低的":["69.4"],"而":["69.4","92.21"],"secret":["69.5"],"随机数":["69.5"],"后端利用":["69.5"],"应用广泛和跨平台":["70.1"],"明文传输":["70.2"],"不安全":["70.2"],"每次发起一个请求":["70.3"],"都要新建一次":["70.3"],"如果每次请求到的数据都是一样的":["70.4"],"就可以把这对请求响应的数据缓存在本地":["70.4"],"下次读取数据的时候":["70.4"],"就可以直接在本地读取数据":["70.4"],"不必再通过网络获取请求":["70.4"],"主要是通过缓存技术实现":["70.4"],"为了避免客户端获取到的数据不是最新的数据":["70.4"],"服务端在返回数据的时候":["70.4"],"会在响应头中放一个过期时间":["70.4"],"当客户端发起请求的时候":["70.4"],"首先会查看响应头的信息":["70.4"],"如果发现缓存的响应是过期的":["70.4"],"就会重新发起网络请求":["70.4"],"减少":["70.4"],"重定向请求":["70.4"],"当服务器上的资源从":["70.4"],"url1":["70.4"],"头部":["70.6"],"特别是对于携带":["70.6"],"cookie":["70.6"],"的头部":["70.6"],"不支持服务器推送消息":["70.6"],"当客户端需要获取通知的时候":["70.6"],"只能通过定时器不断的拉取信息":["70.6"],"针对以上问题":["70.6"],"做了以下优化":["70.6"],"头部压缩":["70.6"],"可以通过指定":["70.6"],"encoding":["70.6"],"字段来对":["70.6"],"body":["70.6"],"来进行压缩":["70.6"],"但是针对":["70.6"],"header":["70.6"],"部分":["70.6"],"没有优化手段":["70.6"],"中有很大固定的字段":["70.6"],"比如":["70.6"],"connection":["71.0"],"用于客户端要求服务器使用":["71.0"],"根据用户提供的登录信息":["72.0"],"认证系统进行身份校验":["72.0"],"如果通过校验":["72.0"],"应该返回给用户一个认证的凭据":["72.0"],"ticket":["72.0"],"用户再访问别的应用的时候就会将这个":["72.0"],"带上":["72.0"],"协议":["73.0","73.4"],"面向连接的":["73.1"],"传输层":["73.2"],"应用层的数据包传输给传输层":["73.2"],"传输层为应用层提供网络支持":["73.2"],"在传输层有两个传输协议":["73.2"],"udp":["73.2"],"传输控制协议":["73.2"],"使用比较多的传输协议":["73.2"],"syn":["73.3","73.5"],"包传给接收端主机":["73.3"],"工作在那一层":["73.4"],"客户端随机初始化序列号":["73.5"],"把":["73.5","104.0"],"标志置为":["73.5"],"表示当前报文为":["73.5"],"报文":["73.5"],"然后把第一个":["73.5"],"等待服务端的确认":["73.6"],"第二次挥手":["73.6"],"服务端收到":["73.6"],"会发送":["73.6"],"ack":["73.6"],"且把客户端的序列号值":["73.6"],"的方式":["73.7"],"每一次的会话都有一个编号":["73.7"],"当对话中断后":["73.7"],"下一次重新连接时":["73.7"],"提供可靠的服务":["73.8"],"也就是说":["73.8"],"连接传送的数据":["73.8"],"无差错":["73.8"],"不丢失":["73.8"],"提示信息":["74.0"],"报文已经收到并且被正常处理":["74.1"],"url":["74.2"],"重新发送请求获取资源":["74.2"],"也就是重定向":["74.2"],"表示客户端发送的报文有误":["74.3"],"服务器无法处理":["74.3"],"客户端请求正确":["74.4"],"但是服务器内部发生了错误":["74.4"],"plain":["75.0"],"本质上还是浏览器发送请求":["76.0"],"服务器接受请求的一个过程":["76.0"],"通过让客户端不断的进行请求":["76.0"],"使得客户端能够模拟实时地收到服务器端的数据的变化":["76.0"],"优缺点":["76.0"],"优点是比较简单":["76.0"],"缺点是这种方式由于需要不断的建立":["76.0"],"提高访问速度":["77.0"],"浏览器缓存是一种操作简单":["77.0"],"效果显著的前端性能优化手段":["77.0"],"通过网络获取内容既速度缓慢又开销巨大":["77.0"],"命中强缓存情况下":["77.1"],"返回的":["77.1"],"状态码为":["77.1"],"disk":["77.1"],"实现强缓存":["77.1"],"过去一直用":["77.1"],"当服务器返回响应的时候":["77.1"],"response":["77.1"],"headers":["77.1","77.2"],"中将过期时间写入":["77.1"],"字段":["77.1"],"是一个时间戳":["77.2"],"如果我们启用了协商缓存":["77.2"],"会在首次请求时随着":["77.2"],"reponse":["77.2"],"返回":["77.2"],"随后每次请求时":["77.2"],"都会带上一个叫":["77.2"],"since":["77.2"],"的时间戳字段":["77.2"],"值是上一次返回的":["77.2"],"否则考虑该资源是否可以被服务器代理缓存":["77.3"],"根据其结果决定是设置为":["77.3"],"private":["77.3"],"还是":["77.3","92.6"],"public":["77.3"],"然后考虑资源的过期时间":["77.3"],"设置对应的":["77.3"],"max":["77.3"],"age":["77.3"],"s":["77.3"],"然后就结束了":["77.5"],"服务器没有记录任何关于客户端的任何信息":["77.5"],"下次请求的时候":["77.5"],"不知道客户端是谁":["77.5"],"存储在其中的数据是永远不会过期的":["77.6"],"页面被关闭的时候":["77.7"],"存储内容也会随之被释放":["77.7"],"一般来说是没有存储上限的":["77.8"],"所有服务器可以根据哪些服务器和用户距离最近":["77.9"],"来满足数据的请求":["77.9"],"缓存":["77.9"],"本都存储带来的性能提升":["77.9"],"就把所有的图片资源加载完毕":["78.0"],"那么很可能会造成白屏":["78.0"],"卡顿等现象":["78.0"],"因为图片太多了":["78.0"],"节流":["78.1"],"生成相应的":["79.0"],"dom":["79.0","79.1","91.12","92.2","92.11","92.23","95.3"],"这种特性使得客户端代码渲染的源代码很简洁":["79.0"],"当用户第一次请求页面时":["79.0"],"由服务器把需要的组件或页面渲染成":["79.0"],"文档经过词法分析输出":["79.1"],"树":["79.1"],"浏览器在构建":["79.2"],"树的过程中":["79.2"],"不会渲染任何已经处理的内容":["79.2"],"即便":["79.2"],"已经解析完毕了":["79.2"],"只要":["79.2"],"没有完毕":["79.2"],"渲染就不会结束":["79.2"],"只有当解析":["79.2"],"当我们对":["79.3"],"的修改引发了":["79.3"],"几何尺寸的变化":["79.3"],"连接和":["80.0"],"比如说":["80.2"],"babel":["80.2"],"webpack":["80.3","80.4","92.24","95.0","99.1"],"config":["80.3"],"打包业务代码":["80.3"],"配置文件":["80.3"],"const":["80.3","80.5","116.1","117.0"],"path":["80.3"],"require":["80.3","80.5"],"由单进程转换成多进程":["80.4"],"是单线程的":["80.4"],"bundleanalyzerplugin":["80.5"],"analyzer":["80.5"],"module":["80.5"],"exports":["80.5"],"plugins":["80.5"],"服务端压缩":["80.6"],"客户端解压":["80.6"],"一般情况下":["80.6"],"如果处理的是具备一定规模的项目":["80.6"],"jpeg":["80.7"],"jpg":["80.7","80.12"],"png":["80.7","80.12"],"webp":["80.7"],"不支持透明":["80.8"],"最大的特点就是有损压缩":["80.8"],"这种压缩算法很高效":["80.8"],"所有":["80.8"],"代表的是二进制的位数":["80.9"],"最多支持":["80.9"],"是一种基于":["80.10"],"xml":["80.10"],"语法的图像格式":["80.10"],"的背景定位来显示其中每一部分的技术":["80.11"],"的出现":["80.11"],"也是为了减少加载网页图片时对服务器的请求次数":["80.11"],"从而提升网站性能":["80.11"],"是一种用于传输":["80.11"],"一样的优点":["80.12"],"可以显示动态图片":["80.12"],"缺点":["80.12"],"对除":["80.12"],"表单递交或输入域名或页面请求的查询字符串":["82.0"],"最终达到欺骗服务器执行恶意的":["82.0"],"命令":["82.0"],"攻击指的是攻击者往":["83.0"],"页面里插入恶意":["83.0"],"对称加密":["84.1"],"好处是加解密效率快":["84.2"],"但是不安全":["84.2"],"如果有人拿到了这个密钥谁都可以进行解密":["84.2"],"baidu":["84.3"],"com":["84.3"],"服务端存储着公钥和私钥":["84.3"],"客户端创建随机数":["84.4"],"使用中间人证书中的公钥进行加密发送给中间人服务器":["84.4"],"中间人使用私钥对随机数解密并构造对称加密":["84.4"],"慎用免费的":["84.5"],"存储上传的文件在非":["85.0"],"通过要求用户输入验证码":["86.0"],"true":["87.0"],"是怎么实现的":["87.0"],"本质是一个具备缓存的":["87.1"],"watcher":["87.1","87.3","91.9"],"依赖的属性发生变化就会更新视图":["87.1"],"适用于计算比较消耗性能的计算场景":["87.1"],"当表达式过于复杂时":["87.1"],"defineproperty":["87.2","91.4"],"把这些属性全部转为":["87.2"],"getter":["87.2"],"setter":["87.2"],"创建了一个":["87.3"],"当被监听的属性更新时":["87.3"],"调用传入的回调函数":["87.3"],"query":["88.0"],"方法传入的参数使用":["88.0"],"当前":["88.1"],"router":["88.2","88.3"],"目录下的":["88.2"],"link":["88.3"],"的值为":["88.4"],"search":["88.4"],"interview":["88.4"],"poetries":["88.4"],"路由模式的实现主要是基于下面几个特性":["88.4"],"值只是客户端的一种状态":["88.4"],"也就是说当向服务器端发出请求时":["88.4"],"部分不会被发送":["88.4"],"值的改变":["88.4"],"都会在浏览器的访问历史中增加一个记录":["88.4"],"中两个重要组件":["88.5"],"的时候新加入两个":["88.6"],"api":["88.6","89.8","90.2","90.5"],"pushstate":["88.6"],"中保护路由的方法叫做路由守卫":["88.8"],"主要用来通过跳转或取消的方式守卫导航":["88.8"],"路由守卫有三个级别":["88.8"],"全局":["88.8"],"路由独享":["88.8"],"利用路由懒加载我们能把不同路由对应的组件分割成不同的代码块":["88.9"],"然后当路由被访问的时候才加载对应组件":["88.9"],"这样会更加高效":["88.9"],"是一种优化手段":["88.9"],"页面跳转内容改变同时不刷新":["88.10"],"同时路由还需要以插件形式存在":["88.10"],"首先我会定义一个":["88.10"],"createrouter":["88.10"],"存在的问题":["89.0"],"不能监听数组的变化":["89.0"],"reactive":["89.1"],"需要手动指定要监视的数据和回调函数":["89.2"],"具有更高的灵活性和定制性":["89.2"],"有什么不同":["89.3"],"在逻辑组织和逻辑复用方面":["89.3"],"是优于":["89.3"],"有什么优势":["89.4"],"性能更好":["89.4","89.8"],"生命周期有什么区别":["89.5"],"options":["89.5"],"的":["89.6","90.4","92.24"],"setup":["89.6","89.9"],"相当于":["89.6"],"created":["89.6","93.2","93.3"],"beforecreate":["89.6"],"的合集":["89.6"],"sfc":["89.7"],"语法糖":["89.7"],"teleport":["89.7"],"传送门":["89.7"],"fragments":["89.7"],"片段":["89.7"],"emits":["89.7"],"基于":["89.8"],"proxy":["89.8"],"实现":["89.8"],"如在":["89.9"],"computed":["89.9","91.7","93.0"],"合成函数":["89.9"],"都有可能返回值类型":["89.9"],"vue":["89.9","90.4","91.9","91.12","91.13","92.9","92.16","92.22","93.1"],"如不定义":["89.9"],"和其他":["89.10"],"中获取的数据能直接更改吗":["90.0"],"mutation":["90.1"],"非常类似于事件":["90.1"],"每个":["90.1"],"都有一个字符串的类型":["90.1"],"和一个":["90.1"],"回调函数":["90.1"],"handler":["90.1"],"action":["90.1"],"方法监听状态":["90.2"],"可以使用":["90.2"],"提供的":["90.2"],"store":["90.2","90.5"],"subscribe":["90.2"],"如果要持久化就要存起来":["90.3"],"localstorage":["90.3"],"就很合适":["90.3"],"提交":["90.3"],"我们来看看官网如何解释":["90.4"],"是":["90.4","92.9"],"的存储库":["90.4"],"它允许您跨组件":["90.4"],"页面共享状态":["90.4"],"实际上":["90.4"],"就是":["90.4"],"可见要实现一个":["90.5"],"要实现一个":["90.5"],"存储全局状态":["90.5"],"要提供修改状态所需":["90.5"],"commit":["90.5"],"订阅者模式的方式":["91.0"],"vnode":["91.1"],"compile":["91.1"],"编译器把":["91.1"],"编译成":["91.1"],"用对象的属性来描述节点":["91.3"],"最终可以通过一系列操作使这棵树映射到真实环境上":["91.3"],"创建虚拟":["91.3"],"是为了更好将虚拟的节点渲染到页面视图中":["91.3"],"所以虚拟":["91.3"],"对象的节点与真实":["91.3"],"中并没有使用":["91.4"],"每个属性都有自己的":["91.5"],"dep":["91.5","91.9"],"更准确":["91.6"],"更快的拿到":["91.6"],"oldvnode":["91.6"],"中对应的节点":["91.6"],"更新组件时判断两个节点是否相同":["91.6"],"相同就复用":["91.6"],"不相同就删除旧的创建新的":["91.6"],"react":["91.6"],"root":["91.7"],"初始化响应式数据":["91.7"],"data":["91.7","91.9","93.0","107.0"],"props":["91.7"],"watch":["91.7","93.0"],"method":["91.7"],"算法是平级比较":["91.8"],"不考虑跨级比较的情况":["91.8"],"内部采用":["91.8"],"深度递归的方式":["91.8"],"双指针":["91.8"],"头尾都加指针":["91.8"],"的方式进行比较":["91.8"],"简单来说":["91.8"],"算法有以下过程":["91.8"],"同级比较":["91.8"],"再比较子节点":["91.8"],"key":["91.8","105.0"],"tag":["91.8"],"标签名判断":["91.8"],"存放他所依赖的":["91.9"],"依赖收集":["91.9"],"当属性变化后会通知自己对应的":["91.9"],"去更新":["91.9"],"派发更新":["91.9"],"进行初始化的时候":["91.9"],"首先会对用户传入的":["91.9"],"数据进行初始化":["91.9"],"observer":["91.9"],"app":["91.10"],"mount":["91.10"],"过程":["91.10"],"如果不采用异步更新":["91.11"],"那么每次更新数据都会对当前组件进行重新渲染":["91.11"],"所以为了性能":["91.11"],"更新循环结束之后执行延迟回调":["91.12"],"用于获得更新后的":["91.12"],"有个异步更新策略":["91.12"],"意思是如果数据变化":["91.12"],"不会立刻更新":["91.12"],"项目中主要使用":["91.13"],"两个树的完全":["91.14"],"是一套用于构建用户界面的渐进式框架":["92.0"],"必须是函数":["92.1"],"根实例对象":["92.1"],"可以是对象也可以是函数":["92.1"],"元素依旧还在":["92.2"],"if显示隐藏是将dom元素整个添加或删除":["92.2"],"编译过程":["92.2"],"切换有一个局部编译":["92.2"],"缺陷的过程":["92.2"],"切换过程中合适地销毁和重建内部的事件监听和子组件":["92.2"],"不建议一起使用":["92.3"],"vue2":["92.3"],"ref":["92.4"],"初始化之前":["92.5"],"由于":["92.5"],"vuex":["92.6"],"单页面应用":["92.7"],"只在":["92.7"],"页面初始化的时候加载相应的":["92.7"],"到首屏内容渲染完成的时间":["92.8"],"整个网页不一定要全部渲染完成":["92.8"],"但是需要展示当前视窗需要的内容":["92.8"],"内置的一个组件":["92.9"],"可以实现组件缓存":["92.9"],"当组件切换时不会对当前组件进行卸载":["92.9"],"一般结合路由和动态组件一起使用":["92.9"],"有了解过吗":["92.10"],"为什么还需要虚拟":["92.11"],"我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码":["92.12"],"这些代码的功能相对独立":["92.12"],"可以通过":["92.12"],"mvc":["92.13"],"中的":["92.13"],"controller":["92.13"],"演变成":["92.13"],"层代表数据模型":["92.13"],"也就是前端声明的静态数据或者是通过网络请求获取的数据":["92.13"],"代表":["92.13"],"但":["92.14"],"vue3":["92.14","92.25"],"中组件已经可以多根节点了":["92.14"],"之所以需要这样是因为":["92.14"],"函数的第二个参数":["92.15"],"context":["92.15"],"来代替":["92.15"],"没有生命周期钩子函数":["92.15"],"不能使用计算属性":["92.15"],"引用指向的就是":["92.16"],"元素":["92.16","92.23"],"如果用在子组件上":["92.16"],"引用就指向组件实例":["92.16"],"访问访问父组件的属性或方法":["92.16"],"访问子组件的属性或方法":["92.16"],"eventbus":["92.16"],"on":["92.16"],"父子":["92.16"],"隔代":["92.16"],"兄弟组件通信":["92.16"],"这种方法通过一个空的":["92.16"],"实例作为中央事件总线":["92.16"],"事件中心":["92.16"],"用它来触发事件和监听事件":["92.16"],"mixins":["92.17"],"slots":["92.17"],"extends":["92.17"],"的更新会向下流动到子组件中":["92.18"],"但是反过来则不行":["92.18"],"这样会防止从子组件意外变更父级组件的状态":["92.18"],"从而导致你的应用的数据流向难以理解":["92.18"],"另外":["92.18"],"每次父级组件发生变更时":["92.18"],"例如输入框":["92.19"],"可以替换为日历":["92.19"],"时间":["92.19"],"范围等组件作具体的实现":["92.19"],"调试方便":["92.19"],"由于整个系统是通过组件组合起来的":["92.19"],"在出现问题的时候":["92.19"],"可以用排除法直接移除组件":["92.19"],"或者根据报错的组件快速定位问题":["92.19"],"之所以能够快速定位":["92.19"],"是因为每个组件之间低耦合":["92.19"],"职责单一":["92.19"],"所以逻辑会比分析整个系统要简单":["92.19"],"提高可维护性":["92.19"],"由于每个组件的职责单一":["92.19"],"修饰符可以实现父子组件之间的双向绑定":["92.20"],"并且可以实现子组件同步修改父组件的值":["92.20"],"相比较与":["92.20"],"的工作放在服务端完成":["92.21"],"然后再把":["92.21"],"直接返回给客户端":["92.21"],"有着更好的":["92.21"],"seo":["92.21"],"并且首屏加载速度更快":["92.21"],"因为":["92.21","97.1"],"spa":["92.21"],"页面的内容是通过":["92.21"],"ajax":["92.21"],"获取":["92.21","92.23"],"而搜索引擎爬取工具并不会等待":["92.21"],"异步完成后再抓取页面内容":["92.21"],"所以在":["92.21"],"中是抓取不到页面通过":["92.21"],"获取到的内容":["92.21"],"是直接由服务端返回已经渲染好的页面":["92.21"],"数据已经包含在页面中":["92.21"],"所以搜索引擎爬取工具可以抓取渲染好的页面":["92.21"],"single":["92.24"],"file":["92.24"],"component":["92.24"],"因为有了":["92.24"],"引入必要插件":["92.25"],"代码规范":["92.25"],"提交规范":["92.25"],"常用库和组件":["92.25"],"目前":["92.25"],"项目我会用":["92.25"],"vite":["92.25"],"create":["92.25"],"创建项目":["92.25"],"更新前":["93.0"],"updated":["93.0"],"更新完成":["93.0"],"beforedestory":["93.0"],"销毁前":["93.0"],"destoryed":["93.0"],"销毁完成":["93.0"],"之后触发的第一个钩子":["93.0"],"在当前阶段中":["93.0"],"methods":["93.0"],"实例销毁之前被调用":["93.1"],"可以执行一些清理和释放资源的工作":["93.1"],"beforemount":["93.2"],"子":["93.2"],"以便能够运行在各版本的浏览器或其他环境中":["94.0"],"基本原理":["94.0"],"首先将源码转成抽象语法树":["94.0"],"然后对语法树进行处理生成新的语法树":["94.0"],"最后将新语法树生成新的":["94.0"],"只能处理":["95.0"],"通过style标签插入到页面中":["95.1"],"source为要处理的css源文件":["95.1"],"相同优先级的":["95.2"],"操作去加载":["95.3"],"加载":["95.3"],"sass":["95.3"],"功能":["96.0"],"通过内部的事件流机制保证了插件的有序性":["96.1"],"在控制台输出":["96.2"],"打包已完成":["96.2"],"class":["96.2"],"myplugin":["96.2"],"从入口文件开始解析":["97.0"],"默认只能识别":["97.1"],"代码":["97.1"],"所以如":["97.1"],"只要项目文件有修改":["98.0"],"整个项目构建的":["98.0"],"代码发生变动后":["99.0"],"通知浏览器请求更新的模块":["99.1"],"替换原有的模块":["99.1"],"dev":["99.1"],"server":["99.1"],"promise":["100.0"],"resolve":["100.0","107.0","107.1"],"reject":["100.0","107.1"],"res":["101.0"],"delete":["101.0"],"return":["101.0","107.0","110.0","116.3","116.4","119.0"],"allpy":["101.0"],"myapply":["101.0"],"首先需要判断参数是否为空":["102.0"],"length":["102.0","107.1","114.0","115.0","116.1","116.2"],"next":["104.0"],"push":["104.0"],"放到调用栈清空之后执行":["104.0"],"取值的时候":["105.0"],"如果缓存中存在该键值对":["105.0"],"先删除再重新插入":["105.0"],"表示最近访问":["105.0"],"get":["105.0"],"判断构造函数是否有返回值":["106.0"],"如果有返回值且返回值是一个对象或方法":["106.0"],"就返回这个值":["106.0"],"state":["107.0"],"pending":["107.0"],"let":["107.0","107.1","116.2","117.0"],"value":["107.0"],"state状态只能改变一次":["107.0"],"resolve和reject只会触发一种":["107.0"],"delay":["107.2"],"延迟的时间":["107.2"],"times":["107.2"],"interval":["108.0"],"首先执行回调函数":["108.0"],"timer":["108.0"],"sleep":["109.0"],"fn":["110.0"],"通过这个字段来确定子父级":["111.0"],"转成":["111.0"],"如果不存在":["112.0"],"初始化为一个数组":["112.0"],"else":["112.0"],"如果已经存在":["112.0"],"把上诉虚拟dom转化成下方真实dom":["113.0"],"交换":["116.0"],"j":["116.0"],"若相邻元素前面的数比后面的大":["116.0"],"交换两者":["116.0"],"缓存数组长度":["116.1"],"len":["116.1"],"定义":["116.1"],"minindex":["116.1"],"缓存当前区间最小值的索引":["116.1"],"注意是索引":["116.1"],"temp":["116.2"],"用来保存当前需要插入的元素":["116.2"],"i用于标识每次被插入的元素的索引":["116.2"],"num":["116.3"],"调用quicksort函数进行快速排序":["116.3"],"传递数组nums":["116.3"],"左边界0和右边界nums":["116.3"],"1作为参数":["116.3"],"quicksort":["116.3"],"定义名为quicksort的快速排序函数":["116.3"],"处理边界情况":["116.4"],"计算分割点":["116.4"],"mid":["116.4"],"math":["116.4"],"floor":["116.4"],"递归分割左子数组":["116.4"],"然后合并为有序数组":["116.4"],"uniarr":["117.0"],"item":["117.0"],"of":["117.0"],"pipe":["120.0"],"functions":["120.0"],"滚动事件":["121.0"],"窗口大小调整等需要频繁触发的操":["121.0"],"核心思想是通过设置一个时间间隔":["121.0"],"只有在这个时间间隔内首次触发函数后":["121.0"],"才允许再次触发":["121.0"],"而在这个时间间隔内":["121.0"],"数再次被触发":["121.0"],"则会被":["121.0"],"核心思想就是当函数被触发后":["121.1"],"设置一个定时器":["121.1"],"在一定时间内如果函数再次被触发":["121.1"],"就取消之前的定时器":["121.1"],"重新设置时器":["121.1"],"只有当一定时间内没有再次触发函数时":["121.1"],"定时器才会触发函数":["121.1"],"这里主要记录编程遇到的问题":["123.0"],"这里主要记录项目中的关键技术":["124.0"],"这里主要记录面试遇到的真题":["126.0"]},{"0":["41.0","64.10","104.0","116.1","116.4"],"1":["57.0","91.8","94.0","116.2"],"2":["19.0","24.0","32.0","35.0","38.0","57.0","63.2","64.15","88.5","89.7","90.1","90.2","90.5","92.17","92.19","97.0"],"3":["33.0","39.0","40.1","64.9","88.9"],"4":["56.0","66.0","92.15"],"5":["56.0"],"8":["80.11"],"10":["58.0"],"16":["36.0"],"24":["80.8"],"36":["64.16"],"50":["6.5","6.10","70.6","121.1"],"70":["80.6"],"90":["70.6"],"301":["13.0","74.2"],"302":["70.4"],"400":["74.3"],"500":["74.4"],"1000":["60.6"],"1600":["80.9"],"电脑":["5.0"],"笔记本":["5.0"],"手机":["5.0"],"平板等智能设备在不断增加":["5.0"],"writing":["5.1"],"mode":["5.1"],"排版竖文":["5.1"],"调整文本排版方向":["5.1"],"适用于竖行文字":["5.1"],"文言文":["5.1"],"诗词":["5.1"],"text":["5.1","37.0"],"align":["5.1"],"last":["5.1","77.3"],"对齐两端文本":["5.1"],"设置文本两端对齐":["5.1"],"center":["6.2","6.11","33.0"],"优点":["6.2"],"兼容性比较好":["6.2"],"兼容性好":["6.3"],"缺点":["6.3","40.1","65.0","92.21"],"son":["6.4","6.10"],"display":["6.4","6.14"],"inline":["6.4","6.9"],"absolute":["6.5","6.10","6.15","6.16","38.0"],"子绝":["6.5","6.10"],"left":["6.5","38.0","116.3"],"父元素宽度一半":["6.5"],"这里等同于left":["6.5"],"100px":["6.5","6.26","30.0"],"flex":["6.6"],"justify":["6.6","23.1"],"height":["6.8","6.9","6.26","30.0"],"150px":["6.8","6.9"],"block转换成图片的方式解决":["6.9"],"父元素高度一半":["6.10"],"这里等同于":["6.10"],"75px":["6.10"],"translatey":["6.10"],"自身高度一半":["6.10"],"或":["6.11","6.17","79.2","80.11"],"line":["6.13"],"行高的值与height相等":["6.13"],"200px":["6.14","6.26"],"table":["6.14"],"top":["6.15","38.0","41.1"],"margin":["6.16","38.0","39.0","42.0"],"right":["6.19","6.20","6.22","6.23","6.24","6.27","116.3"],"右列自适应":["6.19","6.20","6.21","6.22","6.23","6.24","6.27"],"css":["6.21","89.7","92.7"],"position":["6.21","16.1"],"left和":["6.26"],"center间隔":["6.26"],"500px":["6.26"],"background":["6.26"],"color":["6.26"],"f00":["6.26"],"safair":["9.0"],"浏览器会等待":["9.0"],"用来判断是否再次点击了屏幕":["9.0"],"怎么解决":["9.0"],"渲染绘制":["10.0"],"将像素渲染到屏幕上":["10.0","79.1"],"解析和":["10.0"],"解析是两个并行的进程":["10.0"],"所以这也解释了为什么":["10.0"],"的解析":["10.0"],"然而":["10.0"],"由于":["10.0"],"是依赖于":["10.0"],"解压":["11.0"],"html":["12.0","50.0","79.0","80.11"],"图像等内容":["12.0"],"负责处理网页的布局":["12.0"],"计算":["12.0"],"解析获取的吗":["13.0"],"这里有个疑问":["13.0"],"利用":["13.0"],"地址和服务器建立":["13.0"],"tcp":["13.0"],"连接":["13.0","76.0"],"构建请求头信息":["13.0"],"发送请求头信息":["13.0"],"服务器响应后":["13.0"],"网络进程接收响应头和响应信息":["13.0"],"并解析响应内容":["13.0"],"网络进程解析响应流程":["13.0"],"检查状态码":["13.0"],"如果是":["13.0"],"操作系统会为该程序创建一块内存":["14.1"],"用来存放代码":["14.1"],"运行中的数据和一个执行任务的主线程":["14.1"],"渲染进程":["14.2"],"将":["14.2"],"是一个独立的渲染区域":["16.0"],"none":["16.1"],"绝对定位元素":["16.1"],"创建一个":["16.2"],"bfc":["16.2","30.0"],"可以解决这个问题":["16.2"],"默认会给自动填充的":["17.1"],"input":["17.1","91.13"],"标签上直接关闭了表单的自动填充":["17.2"],"autocomplete":["17.2"],"当用于列上的时候":["18.0"],"该列会被隐藏":["18.0"],"但任会占据空间":["18.0"],"不会导致相邻元素合并":["18.0"],"当一个元素的":["18.0"],"新增盒子模型":["19.0"],"使用字体图标和":["20.0"],"svg":["20.0","80.7"],"不会独占一行":["21.0"],"不能改变":["21.0"],"在不设置自己的宽度的情况下":["21.1"],"块级元素会默认填满父级元素的宽度":["21.1"],"可以设置":["21.2"],"为":["22.0","39.0"],"n":["22.0"],"的项目":["22.0"],"占据的空间":["22.0"],"放大的比例":["22.0"],"是":["22.0"],"称为":["23.0"],"在第一行上方":["23.1"],"flow":["23.1"],"和":["23.1","54.1","60.3","64.8","69.0","80.10","87.3","91.7","91.10","92.4","92.7","92.9","92.16","92.21","92.25","95.3","98.0"],"的缩写":["23.1"],"content":["23.1","71.0"],"弹性元素会根据这个来决定":["23.2"],"项目的放大比例":["23.2"],"即使存在剩余空间":["23.2"],"rss":["24.0"],"rel":["24.0"],"连接属性等":["24.0"],"加载页面时":["24.0"],"标签引入的":["24.0"],"发生重叠":["25.0"],"它们发生重叠是因为它们是相邻的":["25.0"],"所以我们可以通过这":["25.0"],"一点来解决这个问题":["25.0"],"我们可以为父元素设置":["25.0"],"border":["25.0","41.1","42.0"],"padding":["25.0"],"static":["26.0"],"定位以外的第一个父元素进行定位":["26.0"],"的值":["26.4"],"em":["27.0"],"单位是根据自身元素的":["27.0"],"使用":["28.0","60.6","89.4"],"xml":["28.0"],"文档来描述图形":["28.0"],"可以通过":["28.0","88.4"],"javascript":["28.0","79.1","83.0","88.4","92.7"],"不能定义中间的状态":["29.0"],"不能重复执行动画":["29.0"],"overflow":["30.0"],"hidden":["30.0","32.0"],"右边触发了":["30.0"],"的区域不会和浮动元素发生重叠":["30.0"],"所以两侧不会发生重叠":["30.0"],"red":["30.0"],"300px":["30.0"],"比如说":["31.0"],"当用户悬停在指定的元素时":["31.0"],"visibility":["32.0"],"不会使元素从渲染树中消失":["32.0"],"不会改变页面布局":["32.0"],"不会触发该元素已经绑定的事件":["32.0"],"继承属性":["32.0"],"布局":["33.0"],"item":["33.0"],"预连接":["34.0"],"通过将样式表放在文档头部":["35.0"],"确保浏览器在渲染页面内容之前先加载和解析样式表":["35.0"],"从而避免了页面一开始的无样式状态":["35.0"],"使用内联样式":["35.0"],"所以理论上最小时间是":["36.0"],"7ms":["36.0"],"nowrap":["37.0"],"ellipsis":["37.0"],"translate":["38.0"],"子盒子必须定宽高":["38.0"],"father":["38.0"],"auto":["39.0"],"变成了浮动元素":["40.0"],"代码少":["40.1"],"浏览器兼容性好":["40.1"],"需要添加大量无语义的代码":["40.1"],"代码不够优雅":["40.1"],"50px":["41.1"],"solid":["41.1"],"边框区域":["42.0"],"外边距区域":["42.0"],"标准盒模型":["42.0"],"计算宽高时":["42.0"],"中的换行符和空格字符引起的":["43.0"],"ul":["43.1"],"设置为":["43.1"],"容器":["43.1"],"标签选择器":["44.0"],"属性选择器":["44.0"],"important":["44.1"],"内联样式":["44.1"],"attachevent":["45.0"],"只有冒泡":["45.0"],"没有捕获":["45.0"],"前者事件名不带":["45.0"],"读取到就会开始和执行":["46.0"],"会阻塞后续文档的加载":["46.0"],"都是去异步加载外部的":["46.0"],"在":["47.0","91.6"],"等语义化标签":["48.0"],"为了方便在客户端存储和获取数据":["48.0"],"提供了":["48.0"],"localstorage":["48.0"],"sessionstorage":["48.0"],"防止嵌套的内容对主页面的影响":["49.0"],"并行加载":["49.0"],"标签相关的表单控件上":["50.0"],"prefetch":["51.0"],"预取":["51.0"],"是一个资源提示属性":["51.0"],"用于告诉浏览器在页面加载完成后":["51.0"],"等标签":["52.0"],"用于加载外部资源":["52.0"],"当浏览器解析到带有":["52.0"],"属性的标签时":["52.0"],"会立即请求指定地址的资源":["52.0"],"暂停其它资源的下载和处理":["52.0"],"直到将该资源加载":["52.0"],"server":["53.1"],"url":["53.1","68.0","95.3"],"监听消息事件":["53.1"],"addeventlistener":["53.1","59.1"],"btn":["53.2"],"提交":["53.2"],"gt":["53.2"],"script":["53.2","57.0"],"信息":["53.3"],"b":["54.1"],"strong":["54.1"],"标签":["54.1","88.4","88.5"],"它们在样式上都是文字的加粗":["54.1"],"但是":["54.1","80.4"],"main":["54.2"],"主要内容区域":["54.2"],"article":["54.2"],"实现更灵活的字符串拼接和格式化":["56.0"],"解构赋值":["56.0"],"通过解构赋值语法":["56.0"],"可以从数组或对象中提取值":["56.0"],"并赋给对应的变量":["56.0"],"简化了变量赋值的操作":["56.0"],"默认参数":["56.0"],"函数可以定义默认参数值":["56.0"],"宏任务":["57.0"],"微任务":["57.0"],"全部代码":["57.0"],"同步代码也属于宏任务":["57.0"],"settimeout":["57.0","107.0"],"setinterval":["57.0"],"setimmediate":["57.0"],"等":["57.0","70.6","80.7","92.17"],"promsie":["57.0"],"mutationobserver":["57.0"],"执行过程":["57.0"],"代码执行过程中":["57.0"],"宏任务和微任务放在不同的任务队列中":["57.0"],"var定义的a变量挂载到window对象上":["58.0"],"function":["58.0","64.8","106.0","111.0","121.1"],"console":["58.0"],"log":["58.0"],"this1":["58.0"],"window":["58.0"],"报错":["58.0"],"uncaught":["58.0"],"typeerror":["58.0"],"cannot":["58.0"],"read":["58.0"],"properties":["58.0"],"of":["58.0"],"reading":["58.0"],"ie8":["59.0"],"以下中":["59.0"],"ie":["59.0"],"和事件捕获相反":["59.1"],"顺序是由内到外传播":["59.1"],"直到根节点":["59.1"],"在支持":["59.1"],"的浏览器中":["59.1"],"可以调用事件对象的":["59.1"],"stoppropagation":["59.1"],"方法以阻止事件的继续传播":["59.1"],"不同作用域下同名变量不会冲突":["60.0"],"定义":["60.2"],"for":["60.3","116.1"],"可以跨块访问":["60.4"],"会变量提升":["60.4"],"如果没有找到":["60.5"],"输出是什么":["60.6"],"为什么":["60.6"],"输出是":["60.6"],"在循环中":["60.6"],"声明了一个全局变量":["60.6"],"创建了":["60.6"],"个定时器任务":["60.6"],"每个任务都在":["60.6"],"那么就会去它的proto属性所指向的原型对象上查找":["61.1"],"是对象独有的":["61.3"],"是函数对象独有的":["61.3"],"作用是给特定类型的所有实例提供共享的属性和方法":["61.3"],"但是在":["61.3"],"会导致应用程序速度变慢":["62.0"],"脱离":["62.1"],"dom":["62.1","80.3"],"这个对象被标记为可到达对象":["62.2"],"清除阶段":["62.2"],"局限性是当出现循环引用时":["62.3"],"weakmap":["62.4"],"代码被解析和执行所在环境的抽象概念":["63.0"],"函数执行上下文":["63.1"],"存在无数个":["63.1"],"每当一个函数":["63.1"],"同步执行":["63.2"],"js":["63.3","64.2","64.15","88.2","95.0","106.0","121.0","121.1"],"引擎第一次遇到":["63.3"],"在这个阶段生成变量对象":["63.4"],"建立作用域链":["63.4"],"在全局执行上下文中":["63.5"],"变量对象就是全局对象":["63.5"],"是一种弱类型":["64.0"],"可以发生隐式类型转换":["64.0"],"symbol":["64.1"],"es6":["64.1"],"新增":["64.1"],"现在有两个":["64.2"],"字符串":["64.3","79.0"],"传入相同的字符串":["64.3"],"一定会返回相同的":["64.3"],"number":["64.4"],"数据类型支持的范围更大的整数值":["64.4"],"明确定义的变量在将来是用于保存对象的":["64.5"],"就应该将这个变量初始化为":["64.5"],"有助于区分":["64.5"],"从逻辑上来看":["64.6"],"值表示一个空对象指针":["64.6"],"可以快速分配和释放":["64.7"],"而基本数据类型的值是不可变的":["64.7"],"两种类型":["64.8"],"直接在计算机底层基于数据类型的二进制值进行检测":["64.8"],"属性返回对象的构造函数":["64.9"],"并判断该构造函数是否为数组构造函数":["64.9"],"length":["64.10"],"的时候":["64.11","79.2"],"实际上计算的是这两个数字在计算机里所存储的二进制":["64.11"],"会尝试将这个参数转换成数值":["64.12"],"任何不能被转换成数值的值都会返回":["64.12"],"true":["64.12"],"如果两边的类型不一致":["64.13"],"不会做强制类型转换":["64.13"],"转换成数字":["64.14"],"成立":["64.15"],"即要解析的字符串":["64.16"],"第二个参数":["64.16"],"radix":["64.16"],"基数":["64.16"],"进制":["64.16"],"范围":["64.16"],"add":["64.17"],"delete":["64.17"],"has":["64.17","105.0","119.0"],"成员都是对象":["64.17"],"成员都是弱引用":["64.17"],"减少了大用户量下的服务器负载":["65.0"],"可以实现动态刷新":["65.0"],"局部刷新":["65.0"],"安全问题":["65.0"],"暴露了与服务器交互的细节":["65.0"],"对搜索引擎的支持比较弱":["65.0"],"seo":["65.0"],"的替代方案":["65.1"],"是一个原生的":["65.1"],"api":["65.1","89.5","89.10","91.3"],"技术智能自动选择":["66.0"],"cache服务器":["66.0"],"选择最快的":["66.0"],"服务器":["66.0"],"加快远程访问的速度":["66.0"],"带宽优化":["66.0"],"自动生成服务器":["66.0"],"向本地域名解析服务系统发起域名解析的请求":["67.0"],"一般是本地运营商的机房":["67.0"],"向根域名解析服务器发起域名解析服务请求":["67.0"],"根域名服务器返回":["67.0"],"中":["68.0","92.6"],"浏览器对":["68.0"],"的长度有限制":["68.0"],"网络层之间加入了":["69.0"],"ssl":["69.0"],"tsl":["69.0"],"安全协议":["69.0"],"篡改风险":["69.1"],"强制植入垃圾广告":["69.1"],"冒充风险":["69.1"],"在通信过程中使用对称加密的方式进行加密明文数据":["69.2"],"服务端确认双方使用的加密方法":["69.3"],"并给出数字证书":["69.3"],"以及一个服务器生成的随机数":["69.3"],"第三步":["69.3"],"客户端确认数字证书有效":["69.3"],"场景中通常端与端之间的交互量很大":["69.4"],"对非对称加密的效率是无法忍受的":["69.4"],"另外":["69.4","89.7"],"场景中只有服务端保存了私钥":["69.4"],"一对公私钥只能实现单向加解密过程":["69.4"],"因此":["69.4"],"中的内容传输采用对称加密":["69.4"],"和加密算法":["69.5"],"如":["69.5","92.19"],"的基本报文格式就是":["70.1"],"header":["70.1"],"body":["70.1"],"浏览器不会记录":["70.2"],"http":["70.2","71.0","80.0"],"链接":["70.3"],"而且是串行请求":["70.3"],"的连接和断开":["70.3"],"增加了通信开销":["70.3"],"http1":["70.3"],"迁移至":["70.4"],"url2":["70.4"],"之后":["70.4"],"客户端不知道":["70.4"],"继续请求":["70.4"],"这个时候服务器就会提高":["70.4"],"状态码和":["70.4"],"location":["70.4"],"头部":["70.4"],"通知客户端这个资源已经迁移到":["70.4"],"所以客户端需要再发送":["70.4"],"请求获取资源":["70.4"],"如果重定向的请求多":["70.4"],"客户端每次都要发起":["70.4"],"就会降低网络的性能":["70.4"],"accept":["70.6"],"这些字段加起来高达几百甚至几千字节":["70.6"],"所以有必要进行压缩":["70.6"],"而且很大请求和响应的报文中有很多字段都是重复的":["70.6"],"所以有必要避免重复性":["70.6"],"而且字段是":["70.6"],"ascii":["70.6"],"编码":["70.6","80.11"],"可读性较好但是效率低":["70.6"],"所以有必要改成二进制编码":["70.6"],"所以":["70.6","92.21"],"开发了":["70.6"],"hpack":["70.6"],"算法来压缩头部":["70.6"],"主要由静态字典":["70.6"],"动态字典和":["70.6"],"huffman":["70.6"],"编码组成":["70.6"],"核心就是客户端和服务端都会建立和维护字典":["70.6"],"用长度较小的索引号来表示重复的字符串":["70.6"],"再用":["70.6"],"编码来压缩数据":["70.6"],"最高能达到":["70.6"],"的高压缩率":["70.6"],"二进制帧":["70.6"],"长连接机制":["71.0"],"作为自己认证的凭据":["72.0"],"应用系统接受到请求之后会把":["72.0"],"送到认证系统进行校验":["72.0"],"检查":["72.0"],"的合法性":["72.0"],"同一台设备进程之间进行通信":["73.0"],"可以通过管道":["73.0"],"可靠的":["73.1"],"基于字节流的传输层通信协议":["73.1"],"相比":["73.2"],"具备流量控制":["73.2"],"控制发送方向接收方发送数据的速率":["73.2"],"防止接收方接收不了":["73.2"],"导致数据丢失或网络拥塞":["73.2"],"核心思想是发送方和接收方一起维护一个滑动窗口":["73.2"],"接收方通过":["73.2"],"报文中的窗口大小字段告诉发送方它的接收能力":["73.2"],"发送方根据接收方告知的窗口大小来确定可以发的数据量":["73.2"],"每发送一次数据":["73.3"],"就累加一次该数据字节数的大小":["73.3"],"用来解决网络包乱序的问题":["73.3"],"ip":["73.4"],"层是不可靠的":["73.4"],"报文发送给服务端":["73.5"],"向服务端发起连接":["73.5"],"客户端处于":["73.5"],"sent":["73.5"],"这个报文不包含应用层数据":["73.5"],"作为":["73.6"],"报文的序列号值":["73.6"],"表明已经收到客户端的报文了":["73.6"],"此时服务端处于":["73.6"],"close":["73.6"],"wait":["73.6","121.0","121.1"],"第三次挥手":["73.6"],"如果服务端也想断开连接了":["73.6"],"只要客户端给出这个编号":["73.7"],"服务器如果有这个编号的记录":["73.7"],"那么双方就可以继续使用以前的秘钥":["73.7"],"而不用重新生成一把":["73.7"],"目前所有的浏览器都支持这一种方法":["73.7"],"但是这种方法有一个缺点是":["73.7"],"不重复":["73.8"],"且按序到达":["73.8"],"尽最大努力交付":["73.8"],"即不保证可靠交付":["73.8"],"并且因为":["73.8"],"可靠":["73.8"],"表示目前是协议处理的中间状态":["74.0"],"ok":["74.1"],"最常见的成功状态码":["74.1"],"表示一切正常":["74.1"],"moved":["74.2"],"permanently":["74.2"],"表示客户端请求的报文有错误":["74.3"],"服务器发生错误":["74.4"],"multipart":["75.0"],"form":["75.0"],"data":["75.0"],"application":["75.0"],"严重浪费了服务器端和客户端的资源":["76.0"],"当用户增加时":["76.0"],"服务器端的压力就会变大":["76.0"],"这是很不合理的":["76.0"],"长轮询":["76.0"],"首先由客户端向服务器发起请求":["76.0"],"较大的响应需要在客户端和服务器之间进行多次往返通信":["77.0"],"这会延迟浏览器获得和处理内容的时间":["77.0"],"还会增加访问者的流量费用":["77.0"],"是一个时间戳":["77.1"],"接下来当再次向服务器请求这个资源的时候":["77.1"],"浏览器会先比对本地时间和":["77.1"],"的时间戳":["77.1"],"如果本地时间小于":["77.1"],"设定的过期时间":["77.1"],"那么直接去缓存中去取这个资源":["77.1"],"也正因为如此":["77.1"],"是有问题的":["77.1"],"因为":["77.1","89.3"],"会依赖本地时间":["77.1"],"如果服务端和客户端的时间设置不同":["77.1"],"或者直接去手动改客户端的时间":["77.1"],"值":["77.2"],"服务器接收到这个时间戳后":["77.2"],"会比对该时间戳和资源在服务器上的最后修改时间是否一致":["77.2"],"从而判断资源是否发生了改变":["77.2"],"如果发生了变化":["77.2"],"就会返回一个完整的响应内容":["77.2"],"并在":["77.2"],"response":["77.2"],"中添加新的":["77.2"],"否则":["77.2"],"maxage":["77.3"],"最后":["77.3"],"配置协商缓存需要用到的":["77.3"],"etag":["77.3"],"modified":["77.3"],"等参数":["77.3"],"memorycache":["77.3"],"是指存在内存中的缓存":["77.3"],"优先级最高":["77.3"],"浏览器会最先去命中的一种缓存":["77.3"],"也是响应速度最快的一种缓存":["77.3"],"就是一个存储在浏览器中的很小的一个文本文件":["77.5"],"附着在":["77.5"],"使其消失的唯一办法就是手动删除":["77.6"],"即便是相同域名下的两个窗口":["77.7"],"只要不在同一个浏览器窗口中打开":["77.7"],"那么它们的":["77.7"],"不仅可以存储字符串":["77.8"],"也可以存储二进制数据":["77.8"],"都是只能在拿到数据后存起来这件事情发生之后":["77.9"],"首次请求资源的时候":["77.9"],"想要提升响应能力":["77.9"],"就需要":["77.9"],"浏览器可能做不到一次性处理那么多的任务":["78.0"],"实际上":["78.0"],"用户点开页面的瞬间":["78.0"],"能看到的只有首屏的东西":["78.0"],"通过在一段时间内无视后来产生的回调请求来实现的":["78.1"],"然后返回给客户端":["79.0"],"客户端拿到的是可以直接渲染然后呈现给用户的":["79.0"],"内容":["79.0"],"文档":["79.1"],"生成样式规则":["79.1"],"图层布局计算模块":["79.1"],"布局计算每个对象的精确位置和大小":["79.1"],"视图绘制模块":["79.1"],"进行具体节点的图像绘制":["79.1"],"引擎":["79.1"],"遇到":["79.2"],"link":["79.2"],"style":["79.2","92.16","95.1"],"才开始构建":["79.2"],"所以需要将":["79.2"],"尽早":["79.2"],"尽快下载到客户端":["79.2"],"以便缩短首次渲染的时间":["79.2"],"修改元素的宽":["79.3"],"高或隐藏元素等":["79.3"],"时":["79.3","92.16"],"浏览器需要重新计算元素的几何属性":["79.3"],"然后再将计算的结果绘制出来":["79.3"],"这个过程就叫回流":["79.3"],"请求":["80.0"],"响应":["80.0"],"功能很强大":["80.2"],"但是也很慢":["80.2"],"可以使用":["80.2","87.1"],"include":["80.2","92.9"],"module":["80.3"],"exports":["80.3"],"entry":["80.3"],"依赖的库数组":["80.3"],"vendor":["80.3"],"prop":["80.3"],"types":["80.3"],"babel":["80.3"],"polyfill":["80.3"],"react":["80.3","92.13"],"router":["80.3","92.25"],"output":["80.3"],"如果同一时刻存在多个任务":["80.4"],"只能排队一个一个的等待处理":["80.4"],"new":["80.5","102.0"],"删除冗余代码":["80.5"],"tree":["80.5","91.1"],"shaking":["80.5"],"基于":["80.5"],"import":["80.5"],"export":["80.5"],"语法":["80.5"],"压缩后通常能减少响应":["80.6"],"左右的大小":["80.6"],"压缩的原理是在一个文本文件中找出一些重复的字符串":["80.6"],"临时替换它们":["80.6"],"从而使整个文件变小":["80.6"],"base64":["80.7"],"首先":["80.7"],"是一种非常轻巧的图片格式":["80.8"],"格式有":["80.8"],"位存储单个图":["80.8"],"种颜色":["80.9"],"对图像的处理不是基于像素点":["80.10"],"而是基于对图像的形状描述":["80.10"],"对比":["80.10"],"png":["80.10"],"位字节码的编码方式":["80.11"],"通过对图片进行":["80.11"],"我们可以直接将编码结果写入到":["80.11"],"chrome":["80.12"],"之外的浏览器兼容性较差":["80.12"],"会增加服务端的负担":["80.12"],"和编码":["80.12"],"文件相比":["80.12"],"csrf":["81.0"],"token":["81.0"],"总的来说有以下几点":["82.0"],"永远不要信任用户的输入":["82.0"],"要对用户的输入进行校验":["82.0"],"可以通过正则表达式":["82.0"],"标签或者":["83.0"],"代码":["83.0","94.0"],"比如":["83.0"],"是加密传输":["84.0"],"两边拥有相同的密钥":["84.1"],"两边都知道如何将密文加密解密":["84.1"],"非对称密钥会有两把密钥":["84.2"],"一把是私钥":["84.2"],"只有自己才有":["84.2"],"服务器把":["84.3"],"ca":["84.3"],"数字证书":["84.3"],"包含公钥":["84.3"],"响应给客户端":["84.3"],"对之后传输的内容进行加密传输":["84.4"],"中间人通过客户端的随机数对客户端的数据进行解密":["84.4"],"中间人与服务端建立合法的":["84.4"],"https":["84.4"],"web":["85.0"],"可以防止用户使用自动化程序对密码":["86.0"],"当用户知道了":["87.0"],"中的":["87.0","91.8"],"在模板中放入过多逻辑会让模板难以维护":["87.1"],"可以将复杂的逻辑放入计算属性中处理":["87.1"],"当页面中有某些数据依赖其他数据进行变动的时候":["87.1"],"遍历":["87.2"],"里的每个属性":["87.2"],"常见的配置选项有":["87.3"],"deep":["87.3"],"immediate":["87.3","121.1"],"this":["88.0","91.9","92.23"],"route":["88.0"],"跳转对象":["88.1"],"里面可以获取":["88.1"],"name":["88.1"],"index":["88.2"],"文件中":["88.2"],"在电脑上有用":["88.3"],"安卓上没反应怎么解决":["88.3"],"因此我们能通过浏览器的回退":["88.4"],"前进按钮控制":["88.4"],"的切换":["88.4"],"a":["88.4","88.5"],"并设置":["88.4"],"href":["88.4"],"属性":["88.4","89.9","92.9"],"当用户点击这个标签后":["88.4"],"的":["88.4","91.6","92.3","92.12"],"值会发生改变":["88.4"],"或者使用":["88.4"],"来对":["88.4"],"loaction":["88.4"],"进行赋值":["88.4"],"分别起到路由导航作用和组件内容渲染作用":["88.5"],"使用中":["88.5"],"默认生成一个":["88.5"],"repalcestate":["88.6"],"这两个":["88.6"],"可以在不进行刷新的情况下":["88.6"],"操作浏览器的历史纪录":["88.6"],"replacestate":["88.7"],"的变化":["88.7"],"组件级":["88.8"],"影响范围由大到小":["88.8"],"例如全局的":["88.8"],"一般来说":["88.9"],"对所有的":["88.9"],"路由都使用动态导入":["88.9"],"是个好主意":["88.9"],"函数":["88.10"],"返回路由器实例":["88.10"],"实例内部做几件事":["88.10"],"保存用户传入的配置项":["88.10"],"监听":["88.10"],"hash":["88.10"],"无法监控到数组下标的变化":["89.0"],"导致通过数组下标添加元素":["89.0"],"不能实时响应":["89.0"],"必须遍历对象的每个属性":["89.0"],"用于处理对象类型的数据响应式":["89.1"],"会自动追踪函数内部使用的响应式数据":["89.2"],"不需要显示指定":["89.2"],"可以监视多个数据":["89.2"],"编译优化":["89.4"],"生命周期":["89.5"],"只会调用一次":["89.6"],"而":["89.6"],"函数在渲染过程中会被多次调用":["89.6"],"选项":["89.7"],"自定义渲染器":["89.7"],"变量":["89.7"],"suspense":["89.7"],"获取到哪一层才触发响应式":["89.8"],"get":["89.8","100.0","119.0"],"不是像":["89.8"],"vue2":["89.8"],"一次性递归监听数据":["89.8"],"编译层面做了更多编译优化处理":["89.8"],"用户将制造":["89.9"],"反而更混乱":["89.9"],"为何":["89.9"],"需要":["89.9"],"value":["89.9","105.0"],"composition":["89.10"],"不能直接更改":["90.0"],"类似于":["90.1"],"不同在于":["90.1"],"可以包含任意异步操作":["90.1"],"但它不能修改状态":["90.1"],"需要提交":["90.1"],"才能变更状态":["90.1"],"开发时":["90.1"],"包含异步操作或者复杂业务组合时使用":["90.1"],"选项方式":["90.2"],"可以以字符串形式监听":["90.2"],"state":["90.2","90.3"],"xx":["90.2"],"mutation":["90.3"],"的时候同时存入":["90.3"],"store":["90.3"],"中把值取出作为":["90.3"],"的升级版":["90.4"],"官网也说过":["90.4"],"为了尊重原作者":["90.4"],"所以取名":["90.4"],"而没有取名":["90.4"],"所以大家可以直接将":["90.4"],"比作为":["90.4"],"type":["90.5"],"payload":["90.5"],"dispatch":["90.5"],"实现":["90.5"],"通过":["91.0","94.0"],"object":["91.0"],"语法树":["91.1"],"abstract":["91.1"],"syntax":["91.1"],"即":["91.1"],"源代码的抽象语法结构的树状表现形式":["91.1"],"的属性一一对应":["91.3"],"如果用原生":["91.3"],"去操作":["91.3"],"浏览器会从构建":["91.3"],"树开始从头到尾执行一遍流程":["91.3"],"来检测数组":["91.4"],"性能差":["91.4"],"存放所依赖的":["91.5"],"watcher":["91.5"],"当属性变化后会通知自己对应的":["91.5"],"都是采用":["91.6"],"diff":["91.6","92.11"],"算法来对比新旧虚拟节点":["91.6"],"来更新节点":["91.6"],"函数中":["91.6"],"在交叉对比中":["91.6"],"同时也初始化了":["91.7"],"provide":["91.7"],"inject":["91.7"],"方法":["91.7"],"内部会对数据进行劫持":["91.7"],"对象采用":["91.7"],"先判断一方有子节点和一方没有子节点的情况":["91.8"],"如果新的":["91.8"],"children":["91.8","111.0"],"没有子节点":["91.8"],"将旧的子节点移除":["91.8"],"比较都有子节点的情况":["91.8"],"核心":["91.8"],"递归比较子节点":["91.8"],"算法称为":["91.8"],"patching":["91.8"],"它由":["91.8"],"对数据进行观测":["91.9"],"如果数据是对象":["91.9"],"调用":["91.9"],"walk":["91.9"],"内部对":["91.9"],"进行遍历":["91.9"],"通过调用":["91.9"],"方法循环对象属性":["91.9"],"方法将其定义为响应式":["91.9"],"这个过程中整体上做了两件事":["91.10"],"初始化":["91.10"],"会在本轮数据更新后":["91.11"],"在异步更新视图":["91.11"],"核心思想":["91.11"],"nexttick":["91.11"],"而是开启一个队列":["91.12"],"把组件更新函数保存在队列中":["91.12"],"在同一事件循环中发生的所有数据变更会异步的批量更新":["91.12"],"这一策略导致我们对数据的修改不会立刻体现在":["91.12"],"上":["91.12"],"此时如果想要获取更新后的":["91.12"],"状态":["91.12"],"就需要使用":["91.12"],"指令在表单":["91.13"],"算法是一个时间复杂度为":["91.14"],"o":["91.14"],"核心库只关心视图层":["92.0"],"是一个声明式框架":["92.0"],"因为根实例是单例":["92.1"],"不会产生数据污染情况":["92.1"],"组件实例对象":["92.1"],"只是简单的基于":["92.2"],"切换":["92.2"],"编译条件":["92.2"],"是真正的条件渲染":["92.2"],"它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建":["92.2"],"只有渲染条件为假时":["92.2"],"并不做操作":["92.2"],"直到为真才渲染":["92.2"],"的优先级是高于":["92.3"],"把它们放在一起":["92.3"],"refs":["92.4","92.23"],"div":["92.5"],"是不归":["92.5"],"如果请求来的数据不是要被其它组件共用":["92.6"],"仅仅在请求的组件内使用":["92.6"],"一旦页面加载完成":["92.7"],"加载慢的原因":["92.8"],"网络延时问题":["92.8"],"资源文件体积过大":["92.8"],"用于缓存组件":["92.9"],"提供":["92.9"],"exclude":["92.9"],"让一个对象变成响应式数据":["92.10"],"检测差异":["92.11"],"功能抽离公共的业务逻辑":["92.12"],"ui":["92.13","92.25"],"组件":["92.13","92.24"],"能看到的前端页面":["92.13"],"其实就是":["92.13"],"vue":["92.13","97.1"],"等前端框架":["92.13"],"vdom":["92.14"],"是一颗单根树形结构":["92.14"],"patch":["92.14"],"方法在遍历的时候从根节点开始遍历":["92.14"],"它要求只有一个根节点":["92.14"],"watch":["92.15"],"不能通过":["92.15"],"emit":["92.15"],"对外暴露事件":["92.15"],"调用事件只能通过":["92.15"],"listeners":["92.15","92.16"],"click":["92.15"],"从而实现任何组件间的通信":["92.16"],"包括父子":["92.16"],"兄弟组件":["92.16"],"attrs":["92.16"],"隔代组件通信":["92.16"],"包含了父作用域中不被":["92.16"],"所识别":["92.16"],"且获取":["92.16"],"的特性绑定":["92.16"],"class":["92.16"],"除外":["92.16"],"当一个组件没有声明任何":["92.16"],"混入":["92.17"],"子组件中所有的":["92.18"],"都将会刷新为最新的值":["92.18"],"这意味着你不应该在一个子组件内部改变":["92.18"],"如果你这样做了":["92.18"],"并且组件在系统中是被复用的":["92.19"],"所以对代码进行优化可获得系统的整体升级":["92.19"],"插件是什么":["92.19"],"插件通常用来为":["92.19"],"添加全局功能":["92.19"],"插件的功能范围没有严格的限制":["92.19"],"一般有下面几种":["92.19"],"添加全局方法或者属性":["92.19"],"custom":["92.19"],"element":["92.19","92.25"],"添加全局资源":["92.19"],"指令":["92.19"],"来说":["92.20"],"修饰符就简单很多了":["92.20"],"一个组件上可以有多个":["92.20"],"更快的内容到达时间":["92.21"],"首屏加载更快":["92.21"],"会等待所有":["92.21"],"编译后的":["92.21"],"文件都下载完成后":["92.21"],"才开始进行页面的渲染":["92.21"],"文件下载等需要一定的时间等":["92.21"],"所以首屏渲染需要一定的时间":["92.21"],"直接由服务端渲染好页面直接返回显示":["92.21"],"无需等待下载":["92.21"],"文件及再去渲染等":["92.21"],"有更快的内容到达时间":["92.21"],"开发条件会受到限制":["92.21"],"服务器端渲染只支持":["92.21"],"beforecreate":["92.21"],"created":["92.21"],"两个钩子":["92.21"],"当我们需要一些外部扩展库时需要特殊处理":["92.21"],"删除数组的区别":["92.22"],"我们就可以在项目中编写":["92.24"],"格式的":["92.24"],"我们可以把代码分割为":["92.24"],"接下来引入必要插件":["92.25"],"路由插件":["92.25"],"状态管理":["92.25"],"vuex":["92.25"],"pinia":["92.25"],"库我比较喜欢":["92.25"],"plu":["92.25"],"s":["92.25"],"antd":["92.25"],"上的数据和方法都不能被访问":["93.0"],"钩子调用是在":["93.0"],"initstate":["93.0"],"之前的":["93.0"],"作用是对":["93.0"],"props":["93.0"],"等属性进行初始化处理":["93.0"],"实例被创建后发生":["93.0"],"当前阶段已经完成了数据观测":["93.0"],"可以使用数据":["93.0"],"清理定时器":["93.1"],"避免内存泄露和不必要的开销":["93.1"],"取消异步操作":["93.1"],"mounted":["93.2","93.3"],"生命周期中调用异步请求":["93.3"],"babylon":["94.0"],"格式的资源":["95.0"],"source":["95.1"],"let":["95.1","108.0","116.1"],"scss":["95.3"],"代码转换成":["95.3"],"file":["95.3"],"底层是利用发布订阅模式":["96.1"],"原型上需要定义apply":["96.2"],"的方法":["96.2"],"apply":["96.2"],"compiler":["96.2"],"查找入口文件引入了哪些js文件":["97.0"],"结尾的文件":["97.1"],"必须要通过对应的":["97.1"],"解析成":["97.1"],"代码后":["97.1"],"才能识别":["97.1"],"值就会更改":["98.0"],"chunkhash":["98.0"],"webpack":["99.0"],"会重新编译":["99.0"],"开启":["99.1"],"服务":["99.1"],"本地":["99.1"],"启动后":["99.1"],"xmlhttprequest":["100.0"],"open":["100.0"],"false":["100.0","103.0"],"throw":["102.0"],"error":["102.0"],"必须传入至少一个参数":["102.0"],"判断参数是否都为函数":["102.0"],"null":["103.0"],"return":["103.0","109.0","116.0","120.0"],"shift":["104.0"],"取第一个任务执行":["104.0"],"sleep":["104.0"],"time":["104.0"],"const":["105.0","121.0"],"否则返回新生成的对象":["106.0"],"mynew":["106.0"],"constructor":["106.0"],"args":["106.0","110.0"],"模拟异步":["107.0"],"保证resolvetask事件先注册成功":["107.0"],"要考虑在promise里面写同步代码的情况":["107.0"],"foreach":["107.0"],"cb":["107.0"],"reject":["107.0"],"err":["107.0"],"resolve包一下":["107.1"],"防止promises":["107.1"],"不是promise类型":["107.1"],"重发的次数":["107.2"],"设置下一次执行interval函数":["108.0"],"达到模拟循环":["108.0"],"第一次interval函数":["108.0"],"在delay后执行interval":["108.0"],"ms":["109.0"],"curried":["110.0"],"if":["110.0","117.0"],"实现代码":["111.0"],"listtotree":["111.0"],"将回调函数添加到事件订阅列表中":["112.0"],"push":["112.0","117.0"],"删除订阅":["112.0"],"off":["112.0"],"检查是否存在该类型的事件订阅":["112.0"],"isarray":["114.0","115.0"],"concat":["114.0","115.0"],"返回数组":["116.0"],"改进":["116.0"],"betterbubblesort":["116.0"],"i":["116.1","116.2"],"是当前排序区间的起点":["116.1"],"j用于帮助":["116.2"],"寻找自己应该有的定位":["116.2"],"它接受一个数组nums以及左右边界left和right作为参数":["116.3"],"如果左边界大于等于右边界":["116.3"],"表示排序完成":["116.3"],"直接返回":["116.3"],"retur":["116.3"],"调用partition函数获取枢轴元素的索引":["116.3"],"leftarr":["116.4"],"slice":["116.4"],"递归分割右子数组":["116.4"],"rightarr":["116.4"],"includes":["117.0"],"转成":["118.0"],"这里用0表示为顶级节点":["118.0"],"fn":["121.0","121.1"],"是需要执行的函数":["121.0"],"是时间间隔":["121.0"],"throttle":["121.0"],"debounce":["121.1"],"已经解决方案":["123.0"]},{"0":["33.0","38.0","64.14","64.16","89.7"],"1":["9.0","36.0","65.0","77.1","116.1"],"2":["17.2","63.3","72.0","90.4","91.8","91.10","92.18","97.1","99.1"],"3":["19.0","24.0","30.0","57.0","63.2","72.0","90.3","91.12","92.14","97.0"],"4":["13.0","57.0","80.11","84.3","92.25"],"5":["92.15","92.25"],"6":["56.0"],"7":["56.0"],"10":["91.3"],"13":["91.9"],"20":["58.0"],"50":["6.15","121.0"],"100":["6.22"],"200":["13.0"],"204":["74.1"],"302":["13.0"],"403":["74.3"],"501":["74.4"],"1000":["36.0"],"1600":["80.8"],"其次":["5.0"],"就算是都使用的":["5.0"],"pc":["5.0"],"适用于未知字数中文对齐":["5.1"],"not":["5.1"],"去除无用属性":["5.1"],"排除指定元素不使用样式":["5.1"],"适用于符号分割文字":["5.1"],"object":["5.1","64.9","106.0"],"fit":["5.1"],"规定图像尺寸":["5.1"],"使图像脱离":["5.1"],"background":["5.1","6.19","6.20"],"缺点":["6.2","6.10"],"只对行内元素有效":["6.2"],"必须顶宽":["6.3"],"值不能为":["6.3"],"block":["6.4"],"改为行内或者行内块级形式":["6.4"],"以达到text":["6.4"],"transform":["6.5"],"translatex":["6.5"],"自身宽度一半":["6.5"],"等同于margin":["6.5"],"50px":["6.5","6.10"],"content":["6.6","6.17","100.0"],"center":["6.6","6.13","6.17","23.1"],"line":["6.8","6.9"],"30px":["6.9"],"25px":["6.10"],"优缺点":["6.10"],"优点":["6.10"],"兼容性好":["6.10"],"不管是块级还是行内元素都可以实现":["6.10"],"代码较多":["6.10"],"脱离文档流":["6.10"],"需要知道高度值":["6.10"],"son":["6.11"],"text":["6.13","53.2"],"align":["6.13","6.14"],"vertical":["6.14"],"middle":["6.14"],"left":["6.15","39.0"],"auto":["6.16","25.0"],"width":["6.16","6.22"],"100px":["6.16"],"justify":["6.17"],"color":["6.19"],"f00":["6.19"],"css":["6.20","6.22","6.23","6.24","6.27","14.2","28.0","77.3"],"relative":["6.21"],"子绝父相":["6.21"],"absolute":["6.21","16.1"],"top":["6.21","33.0"],"margin":["6.23"],"display":["6.24","6.27","30.0","37.0"],"eeff2b":["6.26"],"320px":["6.26"],"等于":["6.26"],"center的宽度之和加上间隔":["6.26"],"多出来的就是":["6.26"],"right和":["6.26"],"center的间隔":["6.26"],"0f0":["6.26"],"height":["6.27","21.0"],"500px":["6.27"],"禁止缩放":["9.0"],"设置":["9.0","88.5"],"meta":["9.0"],"标签":["9.0"],"的":["10.0","22.0","77.3"],"所以他必须等待到":["10.0"],"构建完成":["10.0"],"也就是":["10.0"],"资源加载完成":["10.0"],"或者":["10.0","88.10"],"资源加载失败":["10.0"],"后":["10.0"],"cookie":["11.0","83.0"],"绘制等任务":["12.0"],"将其转化成可视化的网页形式":["12.0"],"常见的有":["12.0"],"则需要重定向":["13.0"],"从":["13.0"],"location":["13.0"],"自动中读取地址":["13.0"],"重新进行第":["13.0"],"步":["13.0"],"跳转也会读取本地缓存吗":["13.0"],"则继续处理请求":["13.0"],"这样一个运行环境叫做进程":["14.1"],"管理任务和资源分配的基本单位":["14.1"],"html":["14.2","35.0"],"js":["14.2","52.0","63.5","64.6","77.3","79.2","88.4"],"其中的元素按照特定规则进行排布":["16.0"],"属性为":["16.1","59.0","87.0"],"或":["16.1","80.2"],"fixed":["16.1"],"因为":["16.2","89.6","91.9"],"表单加上":["17.1"],"off":["17.2"],"属性被设置成":["18.0"],"值后":["18.0"],"对于一般的元素":["18.0"],"它的表现跟":["18.0"],"图标":["20.0"],"能够改变元素的":["21.1"],"weight":["21.2"],"倍":["22.0"],"定义项目的缩小比例":["22.0"],"即":["22.0"],"如果空间不足":["22.0"],"该元素将缩小":["22.0"],"所有项目的":["22.0"],"容器":["23.0"],"定义在主轴上的对齐方式":["23.1"],"start":["23.1"],"默认":["23.1"],"左对齐":["23.1"],"end":["23.1"],"右对齐":["23.1"],"居中":["23.1"],"space":["23.1"],"between":["23.1"],"也不放大":["23.2"],"如果所有项目的":["23.2"],"被同时加载":["24.0"],"引入的":["24.0"],"将在页面加载完毕后被加载":["24.0"],"值来分隔它们":["25.0"],"当然我们也可以将父元素设置为":["25.0"],"第三种是高度为":["25.0"],"的父元素的":["25.0"],"如果不存在逐级向上查找":["26.0"],"和":["28.0","48.0","62.4","64.11","80.0","90.4","92.13","92.24"],"来修改和操作":["28.0"],"而":["28.0"],"除非一再触发动画":["29.0"],"blue":["30.0"],"flex":["30.0"],"布局":["30.0"],"左边定宽":["30.0"],"右侧":["30.0"],"outer":["30.0"],"我们可以通过":["31.0"],"hover":["31.0"],"子孙节点消失是继承了":["32.0"],"属性":["32.0"],"可以通过设置":["32.0"],"visibile":["32.0"],"使子孙节点显示":["32.0"],"只会导致重绘":["32.0"],"绝对定位中":["33.0"],"bottom":["33.0","38.0"],"骨架屏":["34.0"],"关键样式直接写在":["35.0"],"标签的":["35.0"],"style":["35.0","92.24"],"属性中":["35.0"],"多行":["37.0"],"right":["38.0","41.1"],"通过使用绝对定位":["39.0"],"以及设置元素":["39.0"],"为其宽度的一半":["39.0"],"不再向父元素汇报高度":["40.0"],"后期不容易维护":["40.1"],"原理":["40.1"],"元素的左右两侧都不允许浮动元素存在":["40.1"],"只设置":["41.0"],"transparent":["41.1"],"只包括内容区域":["42.0"],"ie":["42.0"],"盒模型":["42.0"],"包含内容区域":["42.0"],"这些空白字符会被解析为文本节点":["43.0"],"使":["43.1"],"li":["43.1"],"自动排列在一行内":["43.1"],"间隔消失":["43.1"],"伪类选择器":["44.0"],"id选择器":["44.1"],"类选择器":["44.1"],"on":["45.0"],"后者带":["45.0"],"脚本文件":["46.0"],"他们都不会阻塞页面的解析":["46.0"],"区别":["46.0"],"脚本的执行时机是在下载完成后立即执行":["46.0"],"href":["47.0"],"中指定锚点的":["47.0"],"和离线存储":["48.0"],"多媒体方面规定了":["48.0"],"audio":["48.0"],"允许在主页面加载的时候并行加载嵌套页面":["49.0"],"提高页面并发性能":["49.0"],"for":["50.0","64.10","102.0","111.0","119.0"],"异步地预取指定资源":["51.0"],"这意味着浏览器会在":["51.0"],"空闲":["51.0"],"时加载这些资源":["51.0"],"编译":["52.0"],"执行完毕":["52.0"],"因此":["52.0"],"属性会影响页面的加载和渲染速度":["52.0"],"这也是为什么将":["52.0"],"放在底部而不是头部":["52.0"],"message":["53.1"],"event":["53.1"],"javascript":["53.2","62.1"],"function":["53.2","113.0"],"click":["53.2"],"页面1":["53.3"],"input":["53.3","120.0"],"id":["53.3"],"标签具有强调的语义":["54.1"],"对于一般显示":["54.1"],"可能看上去没有什么差异":["54.1"],"但是对于机器来说":["54.1"],"会有很大的不同":["54.1"],"如果用户使用的是屏幕阅读器来访问网页":["54.1"],"内容块":["54.2"],"比如新闻文章":["54.2"],"博客帖子等":["54.2"],"aside":["54.2"],"简化了函数调用时传参的操作":["56.0"],"扩展运算符":["56.0"],"使用三个点":["56.0"],"进行数组和对象的展开操作":["56.0"],"可以将一个数组或对象拆分为独立的元素":["56.0"],"或者将多个数组或对象合并为一个":["56.0"],"promise":["56.0","65.1","88.9","107.2"],"引入了":["56.0"],"当某个宏任务执行完后":["57.0"],"会查看微任务队列是否有任务":["57.0"],"执行微任务队列中的所有微任务":["57.0"],"注意这里是执行所有的微任务":["57.0"],"微任务执行完成后":["57.0"],"会读取宏任务队列中排在最前的第一个宏任务":["57.0"],"注意宏任务是一个个取":["57.0"],"执行该宏任务":["57.0"],"如果执行过程中":["57.0"],"遇到微任务":["57.0"],"依次加入微任务队列":["57.0"],"宏任务执行完成后":["57.0"],"再次读取微任务队列里的任务":["57.0"],"依次类推":["57.0"],"async":["57.0"],"this2":["58.0"],"note":["58.0"],"开启了严格模式之和":["58.0"],"只是使函数内的this指向undefined":["58.0"],"不影响全局下的this的指向":["58.0"],"let":["58.0","103.0","111.0","116.3","119.0","121.0","121.1"],"const":["58.0","102.0","106.0"],"b":["58.0"],"的事件对象通过设置事件对象的":["59.0"],"canclebubble":["59.0"],"如果在同一对象上定义了其他处理程序":["59.1"],"剩下的处理程序将依旧被调用":["59.1"],"但调用":["59.1"],"之后任何其他对象上的事件处理程序将不会被调用":["59.1"],"不仅可以阻止事件在冒泡阶段的传播":["59.1"],"还能阻止事件在捕获阶段的传播":["59.1"],"ie9":["59.1"],"的时候决定的":["60.2"],"语句中的":["60.3"],"也属于块作用域":["60.3"],"只能在块作用域中访问":["60.4"],"不能跨块访问":["60.4"],"就会从父级的执行上下文的变量对象中查找":["60.5"],"后执行":["60.6"],"在每个":["60.6"],"的回调函数中":["60.6"],"尝试访问":["60.6"],"的值":["60.6"],"这个回调函数是在循环结束之后才会执行":["60.6"],"在循环结束的时候":["60.6"],"全局变量":["60.6"],"为":["60.6"],"所以输出是":["60.6"],"怎么改成":["60.6"],"如果依旧不存在":["61.1"],"中":["61.3","77.1"],"函数也是对象":["61.3"],"所以函数也有":["61.3"],"高延时":["62.0"],"的引用":["62.1"],"垃圾回收器对堆内存从头到尾进行线性遍历":["62.2"],"互相引用的对象不会被回收":["62.3"],"代码都是在执行上下文中运行的":["63.0"],"被调用":["63.1"],"时":["63.1","90.5","91.12"],"都会为该函数创建一个新的上下文":["63.1"],"从上向下按顺序执行":["63.2"],"脚本时":["63.3"],"会创建一个全局的执行上下文并压入当前执行栈":["63.3"],"确定":["63.4"],"this":["63.4","89.10"],"在顶层":["63.5"],"动态的语言":["64.0"],"bigint":["64.1"],"es10":["64.1"],"引用数据类型":["64.1"],"文件需要往这个对象中添加键名":["64.2"],"由于":["64.2"],"类型的值":["64.3"],"创建":["64.4"],"当一个数据不再需要使用时":["64.5"],"通过将其设置为":["64.5"],"代表的其实就是一个空对象":["64.6"],"在":["64.6","69.1","80.5","92.21"],"所以可以存储在栈中":["64.7"],"可以直接访问和复制":["64.7"],"普通对象":["64.8"],"数组对象":["64.8"],"正则对象":["64.8"],"日期对象":["64.8"],"prototype":["64.9","92.19"],"tostring":["64.9"],"call":["64.9"],"利用":["64.9","97.1"],"in":["64.10"],"循环":["64.10"],"因此非数字值传入也会返回":["64.12"],"会影响":["64.12"],"直接返回":["64.13","112.0"],"false":["64.13","88.4","92.2","104.0"],"var":["64.15","65.0"],"以":["64.16"],"进制的规则去解析":["64.16"],"字符串":["64.16"],"不合法导致解析失败":["64.16"],"随时可以消失":["64.17"],"可以用来保存":["64.17"],"dom":["64.17","89.7","92.13","93.0","93.3"],"节点":["64.17","91.3"],"不容易造成内存泄漏":["64.17"],"不能遍历":["64.17"],"不容易调试":["65.0"],"创建ajax对象":["65.0"],"xhr":["65.0"],"window":["65.0","88.4","88.6"],"xmlhttprequest":["65.0"],"new":["65.0","80.3","89.1","107.2","109.0"],"用于进行网络请求":["65.1"],"支持":["65.1"],"的远程":["66.0"],"mirror":["66.0"],"镜像":["66.0"],"远程用户":["66.0"],"访问时从":["66.0"],"gtld":["67.0"],"域名解析服务器地址":["67.0"],"向":["67.0"],"请求携带的参数一般是写在":["68.0"],"body":["68.0"],"报文中":["68.0"],"使得报文能够密文传输":["69.0"],"连接建立相对简单":["69.0"],"三次握手之后就可以进行":["69.0"],"然后生成一个新的随机数":["69.3"],"premaster":["69.3"],"secret":["69.3"],"并使用数字证书中的公钥":["69.3"],"对称密钥加密和非对称密钥加密它们有什么区别":["69.4"],"对称密钥加密是最简单的一种加密方式":["69.4"],"它的加解密用的都是相同的密钥":["69.4"],"这样带来的好处就是加解密效率很快":["69.4"],"但是并不安全":["69.4"],"如果有人拿到了这把密钥那谁都可以进行解密了":["69.4"],"而非对称密钥会有两把密钥":["69.4"],"一把是私钥":["69.4"],"只有自己才有":["69.4"],"一把是公钥":["69.4","84.2"],"hmac":["69.5"],"sha256":["69.5"],"对":["69.5","88.2"],"头部信息也是":["70.1"],"key":["70.1","84.3"],"value":["70.1"],"的状态":["70.2","73.6"],"为了解决这个问题":["70.3"],"提出了长连接的方式":["70.3"],"减少了":["70.3"],"连接的重复建立和断开所造成的额外开销":["70.3"],"可以将重定向的工作交给代理服务器":["70.4"],"就能减少":["70.4"],"合并请求":["70.4"],"就是把多个访问小文件的请求合并成一个大的请求":["70.4"],"虽然传输的总资源是一样的":["70.4"],"但是减少请求":["70.4"],"就意味着减少了重复发送的":["70.4"],"http1":["70.4","77.1"],"中是请求响应模型":["70.4"],"默认不开启管道模式":["70.4"],"所以也存在队头阻塞问题":["70.4"],"如果合并了请求":["70.4"],"就会减少":["70.4"],"tcp":["70.4","73.5"],"连接的数量":["70.4"],"节省":["70.4"],"将":["70.6","94.0","97.1"],"的文本格式改成二进制帧格式传输数据":["70.6"],"极大的提高了":["70.6"],"传输的效率":["70.6"],"h2":["70.6"],"将响应报文划分成了两类帧":["70.6"],"headers":["70.6"],"首部和":["70.6"],"data":["70.6","92.23","111.0"],"消息负载":["70.6"],"就是说一条":["70.6"],"响应":["70.6"],"划分成了两类帧来传输":["70.6"],"采用二进制编码":["70.6"],"并发传输":["70.6"],"是基于请求":["70.6"],"响应模型实现的":["70.6"],"在同一个连接中":["70.6"],"完成一个请求":["70.6"],"才能处理下一个":["70.6"],"也就是说在发出请求等待响应的过程中":["70.6"],"length":["71.0","110.0"],"服务器在返回数据的时候":["71.0"],"用户就可以在不用再次登录的情况下访问应用系统":["72.0"],"和应用系统":["72.0"],"了":["72.0"],"需要注意两点":["72.0"],"系统共享":["72.0"],"统一的认证系统":["72.0"],"共享内存":["73.0"],"信号":["73.0"],"面向连接":["73.1","73.8"],"发送方不会超过接收方指定的窗口大小发送数据":["73.2"],"超时重传":["73.2"],"在发送某一个数据之后就开启一个定时器":["73.2"],"在一定的时间内如果没有收到发送的数据包的":["73.2"],"ack":["73.2"],"报文":["73.2"],"就会重新发送":["73.2"],"直到发送成功为止":["73.2"],"拥塞控制":["73.2"],"通过观察感知网络的拥塞状态":["73.2"],"确认应答号":["73.3"],"指下一次期望收到的数据的序列号":["73.3"],"发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收":["73.3"],"不能保证网络包的交付":["73.4"],"不保证网络包的按序交付":["73.4"],"服务端收到客户端的":["73.5"],"服务端随机初始化自己的序列号":["73.5"],"将这个序列号填入":["73.5"],"首部的序号字段":["73.5"],"和客户端的第一次挥手一样":["73.6"],"发给":["73.6"],"且指定一个序列号":["73.6"],"last":["73.6"],"第四次挥手":["73.6"],"只能够存在一台服务器上":["73.7"],"如果我们的请求通过负载平衡被转移到了其他的服务器上":["73.7"],"那么就无法恢复对话":["73.7"],"不会丢失数据因此适合大数据量的交换":["73.8"],"是面向字节流":["73.8"],"面向报文":["73.8"],"并且网络出现拥塞不会使得发送速率降低":["73.8"],"因":["73.8"],"还需要后续的操作":["74.0"],"no":["74.1"],"永久重定向":["74.2"],"说明请求的资源已经不存在了":["74.2"],"需要用新的url再次访问":["74.2"],"forbidden":["74.3"],"表示客户端请求的功能还不支持":["74.4"],"x":["75.0","91.8","91.9"],"www":["75.0"],"urlencoded":["75.0"],"当服务器收到客户端发来的请求后":["76.0"],"服务器端不会直接进行响应":["76.0"],"而是先将":["76.0"],"这个请求挂起":["76.0"],"然后判断服务器端数据是否有更新":["76.0"],"如果有更新":["76.0"],"则进行响应":["76.0"],"如果一直没有数据":["76.0"],"所以缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面":["77.0"],"浏览器缓存机制有四个方面":["77.0"],"按照获取资源时请求的优先级排序":["77.0"],"memory":["77.0"],"就会无法达到预期":["77.1"],"所以在":["77.1"],"增加了":["77.1"],"这个字段来代替":["77.1"],"使用":["77.1","77.2","80.6"],"max":["77.1"],"age":["77.1"],"来控制资源的有效期":["77.1"],"不会再添加":["77.2"],"字段":["77.2"],"会有两个弊端":["77.2"],"比如我们编辑了文件":["77.2"],"但是文件的内容没有改变":["77.2"],"但是当":["77.3"],"tab":["77.3"],"关闭的时候":["77.3"],"内存中的数据也会消失":["77.3"],"base64":["77.3","95.3"],"格式的图片":["77.3"],"几乎都是放进":["77.3"],"体积不大的":["77.3"],"请求上":["77.5"],"在浏览器和服务器之间进行传递":["77.5"],"可以携带用户信息":["77.5"],"当服务器检查":["77.5"],"常用于存储一些内容稳定的资源":["77.6"],"无法共享":["77.7"],"当数据的复杂度和规模上升到了":["77.8"],"把资源":["77.9"],"copy":["77.9"],"只要我们在页面打开的时候把首屏的资源加载出来":["78.0"],"用户就会认为页面是没问题的":["78.0"],"下面的图片":["78.0"],"可以等到用户下拉的瞬间再去请求":["78.0"],"防抖":["78.1"],"不需要为了生成":["79.0"],"内容自己再去跑一遍":["79.0"],"代码":["79.0","79.1"],"使用服务端渲染很多是因为网站的":["79.0"],"编译执行":["79.1"],"以创建的是":["79.1"],"所以将":["79.2"],"放在":["79.2"],"head":["79.2"],"标签中":["79.2"],"会阻塞":["79.2"],"引擎是独立于渲染引擎的":["79.2"],"当":["79.2"],"解析器遇到应该":["79.2"],"script":["79.2","92.24"],"重绘":["79.3"],"的修改导致了样式的变化":["79.3"],"却并未影响其几何属性时":["79.3"],"对于":["80.0"],"exclude":["80.2"],"帮我们避免不必要的转译":["80.2"],"或者通过开启缓存将转译结果缓存至文件系统":["80.2"],"join":["80.3"],"dirname":["80.3"],"dist":["80.3"],"filename":["80.3"],"name":["80.3"],"library":["80.3"],"hash":["80.3"],"plugins":["80.3"],"dllplugin的name属性需要和libary保持一致":["80.3"],"cpu":["80.4","92.21"],"是多核的":["80.4"],"可以在编译的过程中知道哪些模块并没有被真正的使用":["80.5"],"这些没用的代码":["80.5"],"在最后打包的时候会被去除":["80.5"],"按需加载":["80.5"],"一次不加载完所有的文件内容":["80.5"],"只加载此刻需要用到的那部分":["80.5"],"当需要更多内容时":["80.5"],"再对用到的内容进行即时加载":["80.5"],"的配置文件中":["80.5"],"所以说文件中代码的重复率越高":["80.6"],"压缩的效率就越高":["80.6"],"的收益也就越大":["80.6"],"一般来说":["80.6"],"在计算机中":["80.7"],"像素是用二进制表示的":["80.7"],"不同的图片格式中像素与二进制位数之间的对应关系是不同的":["80.7"],"一个像素对应的二进制位数越多":["80.7"],"可以呈现多达":["80.8"],"万中颜色":["80.8"],"一般场景下足以应对":["80.8"],"适用于呈现色彩丰富的图片":["80.8"],"万种颜色":["80.9"],"图片具有比":["80.9"],"jpg":["80.9","80.10"],"更强的色彩表现力":["80.9"],"文件体积更小":["80.10"],"可压缩性更强":["80.10"],"最显著的优势是可以无限放大不失真":["80.10"],"而且因为":["80.10"],"从而减少":["80.11"],"http":["80.11","92.25"],"请求的次数":["80.11"],"编码之后":["80.11"],"图片的大小会膨胀为原文件的":["80.11"],"编码同样质量的":["80.12"],"文件会占用更多的计算资源":["80.12"],"应用场景":["80.12"],"在站点先进行兼容性的预判":["80.12"],"进行验证":["81.0"],"或限制长度":["82.0"],"对单引号和双":["82.0"],"进行转换等":["82.0"],"永远不要使用动态拼装":["82.0"],"攻击者在论坛中放一个看似安全的链接":["83.0"],"骗取用户点击后":["83.0"],"窃取":["83.0"],"非对称解密":["84.1"],"可以发布给任何人":["84.2"],"客户端解析证书拿到公钥":["84.3"],"生成随机的":["84.3"],"连接":["84.4"],"和服务端之之间使用对称加密进行数据传输":["84.4"],"拿到服务端的响应数据":["84.4"],"可访问目录下":["85.0"],"账号不断尝试":["86.0"],"depp":["87.0"],"没有缓存性":["87.1"],"更多的是观察的作用":["87.1"],"可以监听某些数据执行回调":["87.1"],"当我们需要深度监听对象中的属性时":["87.1"],"每个":["87.2"],"属性都是一个":["87.2"],"watch":["87.2"],"实例":["87.2"],"对应原理如下":["87.3"],"深度监听对象":["87.3"],"为对象的每一个属性创建一个":["87.3"],"接收":["88.0"],"path":["88.1","88.2","88.5","88.10"],"query":["88.1"],"params":["88.1"],"在安卓上有问题是":["88.3"],"改变":["88.4"],"值":["88.4"],"我们可以使用":["88.4"],"hashchange":["88.4"],"事件来监听":["88.4"],"值的变化":["88.4"],"从而对页面进行跳转":["88.4"],"渲染":["88.4"],"addeventlistener":["88.4"],"funcref":["88.4"],"每一次改变":["88.4"],"to":["88.5"],"属性定义跳转":["88.5"],"实际上也可以通过":["88.5"],"custom":["88.5"],"和插槽自定义最终的展现形式":["88.5"],"唯一不同的是":["88.6"],"前者是新增一个历史记录":["88.6"],"后者是直接替换当前的历史记录":["88.6"],"利用自定义事件":["88.7"],"beforeeach":["88.8"],"可以注册一个全局前置守卫":["88.8"],"每次路由导航都会经过这个守卫":["88.8"],"因此在其内部可以加入控制逻辑决定用户是否可以导航到目标路由":["88.8"],"在路由注册的时候可以加入单路由独享的守卫":["88.8"],"给":["88.9"],"component":["88.9"],"选项配置一个返回":["88.9"],"组件的函数就可以定义懒加载路由":["88.9"],"popstate":["88.10"],"事件":["88.10"],"回调里根据":["88.10"],"只能劫持对象的属性":["89.0"],"从而需要对每个对象":["89.0"],"每个属性进行遍历":["89.0"],"如果属性值是对象":["89.0"],"底层采用":["89.1"],"可以在回调函数中处理多个函数的变化情况":["89.2"],"只处理函数内部使用的响应式数据":["89.2"],"几乎是函数":["89.3"],"会有更好的类型推断":["89.3"],"proxy":["89.4","91.9"],"等":["89.4"],"beforedestroy":["89.5"],"改为":["89.5"],"无需使用":["89.6"],"usememo":["89.6"],"usecallback":["89.6"],"避免子组件重复渲染":["89.6"],"在框架层面也有很多亮眼的改进":["89.7"],"更快":["89.7"],"虚拟":["89.7","91.8"],"重写":["89.7"],"diff":["89.7","89.8"],"算法优化":["89.7"],"比如":["89.8"],"静态标记":["89.8"],"pachflag":["89.8"],"算法增加了一个静态标记":["89.8"],"是一个对象":["89.9"],"不丢失响应式":["89.9"],"存储值":["89.9"],"通过":["89.9"],"属性的":["89.9"],"中没有":["89.10"],"需要浅拷贝对象之后更改":["90.0"],"需要直接修改状态则提交":["90.1"],"但由于":["90.1"],"dispatch":["90.1"],"commit":["90.1"],"是两个":["90.1"],"api":["90.1"],"容易引起混淆":["90.1"],"实践中也会采用统一使用":["90.1"],"方式":["90.2"],"可以调用":["90.2"],"cb":["90.2"],"的初始值即可":["90.3"],"这里有两个问题":["90.3"],"不是所有状态都需要持久化":["90.3"],"如果需要保存的状态很多":["90.3"],"为什么要使用":["90.4"],"vue2":["90.4"],"都支持":["90.4"],"这让我们同时使用":["90.4"],"的小伙伴都能很快上手":["90.4"],"可以定义":["90.5"],"类":["90.5"],"构造函数接收选项":["90.5"],"options":["90.5"],"设置属性":["90.5"],"state":["90.5"],"defineproperty":["91.0","91.7"],"是":["91.1"],"createcompiler":["91.1"],"的返回值":["91.1"],"是用以创建编译器的":["91.1"],"另外":["91.1"],"比如有一次操作":["91.3"],"需要更新":["91.3"],"个":["91.3"],"浏览器收到第一个更新":["91.3"],"请求后":["91.3"],"采用重写数组的方法来实现":["91.4"],"去更新":["91.5"],"默认在初始化的时候会调用":["91.5"],"当前节点和旧节点头尾交叉对比没有结果时":["91.6"],"会根据新节点的":["91.6"],"去对比旧节点数组中的":["91.6"],"从而找到相应的旧节点":["91.6"],"如果没有找到就认为是一个新增节点":["91.6"],"如果没有":["91.6"],"就会采用遍历查找的方式去找到对应的旧节点":["91.6"],"数组采用方法重写":["91.7"],"再看一下用户是否传入了":["91.7"],"el":["91.7"],"属性和":["91.7"],"template":["91.7","92.24"],"snabbdom":["91.8"],"修改而来":["91.8"],"要想转化为真实":["91.8"],"就需要通过":["91.8"],"patch":["91.8"],"方法转换":["91.8"],"最初":["91.8"],"vue1":["91.8"],"视图中每个依赖均有更新函数对应":["91.8"],"可以做到精准更新":["91.8"],"因此并不需要虚拟":["91.8"],"vue3":["91.9"],"改用":["91.9"],"替代":["91.9"],"可以直接监听对象和数组的变化":["91.9"],"并且有多达":["91.9"],"种拦截方法":["91.9"],"并且作为新标准将受到浏览器厂商重点持续的性能优化":["91.9"],"回答范例":["91.9"],"所谓数据响应式就是":["91.9"],"能够使数据变化可以被检测并对这种变化做出响应的机制":["91.9"],"建立更新机制":["91.10"],"初始化会创建组件实例":["91.10"],"当数据发生了变化时":["91.11"],"首先调用":["91.11"],"deo":["91.11"],"notify":["91.11"],"开发时":["91.12"],"有两个场景我们会用到":["91.12"],"created":["91.12"],"中想要获取":["91.12"],"响应式数据变化后获取":["91.12"],"textarea":["91.13"],"select":["91.13"],"等元素上创建双向数据绑定":["91.13"],"n3":["91.14"],"vue":["91.14","92.18"],"更关注结果":["92.0"],"收到":["92.0"],"文件在使用的时候实际上会转换成一个":["92.1"],"class":["92.1"],"由":["92.2"],"变为":["92.2"],"true":["92.2","104.0"],"的时候不会触发组件的生命周期":["92.2"],"的时候":["92.2"],"输出的渲染函数中可以看出会先执行循环再判断条件":["92.3"],"哪怕只渲染列表中一小部分元素":["92.3"],"也得在每次重新渲染的时候遍历整个列表":["92.3"],"这会比较浪费":["92.3"],"先给标签设置一个":["92.4"],"管的":["92.5"],"所以写的代码在还没有解析的情况下会容易出现花屏现象":["92.5"],"看到类似":["92.5"],"就不需要放入":["92.6"],"不会因为用户的操作进行页面的重新加载或跳转":["92.7"],"而是利用路由机制实现":["92.7"],"内容的变换":["92.7"],"ui":["92.7"],"是否发生重复请求":["92.8"],"加载脚本的时候":["92.8"],"渲染内容堵塞":["92.8"],"允许组件有条件的进行缓存":["92.9"],"两者都支持字符串或正则表达式":["92.9"],"表示只有名称匹配的组件会被缓存":["92.9"],"表示任何名称匹配的组件都不会被缓存":["92.9"],"内部会用它来处理":["92.10"],"设计的每一个组件一个":["92.11"],"watcher":["92.11"],"没有采用一个属性对应一个":["92.11"],"原理类似":["92.12"],"对象的继承":["92.12"],"当组件初始化时会调用":["92.12"],"层的桥梁":["92.13"],"模式不需要用户手动的去操作":["92.13"],"元素":["92.13"],"将数据绑定到":["92.13"],"组件也会转换为一个":["92.14"],"中之所以可以写多个根节点":["92.14"],"的方式调用外部传入的事件":["92.15"],"因为函数式组件是没有实例化的":["92.15"],"所以在外部通过":["92.15"],"ref":["92.15"],"去引用组件时":["92.15"],"实际引用的是":["92.15"],"htmlelement":["92.15"],"这里会包含所有父作用域的绑定":["92.16"],"并且可以通过":["92.16"],"v":["92.16"],"bind":["92.16","101.0"],"传入内部组件":["92.16"],"通常配合":["92.16"],"inheritattrs":["92.16"],"选项一起使用":["92.16"],"多余的属性不会被解析到标签上":["92.16"],"包含了父作用域中的":["92.16"],"不含":["92.16"],"native":["92.16"],"修饰器的":["92.16"],"是分发":["92.17"],"组件中可复用功能的非常灵活的方式":["92.17"],"会在浏览器控制台中发出警告":["92.18"],"实际开发过程中有两个场景会想要修改一个属性":["92.18"],"这个":["92.18"],"过滤器":["92.19"],"过渡等":["92.19"],"touch":["92.19"],"通过全局混入来添加一些组件选项":["92.19"],"router":["92.19"],"添加":["92.19"],"实例方法":["92.19"],"通过把它们添加到":["92.19"],"修饰符":["92.20"],"相同点":["92.20"],"都是语法糖":["92.20"],"都可以实现父子组件中的数据的双向通信":["92.20"],"区别点":["92.20"],"服务端渲染应用程序也需要处于":["92.21"],"node":["92.21"],"的运行环境":["92.21"],"服务器会有更大的负载需求":["92.21"],"中渲染完整的应用程序":["92.21"],"显然会比仅仅提供静态文件的":["92.21"],"server":["92.21"],"更加大量占用":["92.21"],"资源":["92.21"],"intensive":["92.21"],"密集":["92.21"],"因此如果你预料在高流量环境":["92.21"],"high":["92.21"],"traffic":["92.21"],"下使用":["92.21"],"请准备相应的服务器负载":["92.21"],"并明智地采用缓存策略":["92.21"],"其基本实现原理":["92.21"],"app":["92.21"],"只是被删除的元素变成了":["92.22"],"empty":["92.22"],"box":["92.23"],"获取子组件中的":["92.23"],"代码会异常清晰":["92.24"],"结合其他":["92.24"],"我们还可以用":["92.24"],"工具我会选":["92.25"],"axios":["92.25"],"其他比较常用的库有":["92.25"],"vueuse":["92.25"],"nprogress":["92.25"],"图标可以使用":["92.25"],"svg":["92.25"],"loader":["92.25"],"下面是代码规范":["92.25"],"更改数据":["93.0"],"在这里更改数据不会触发":["93.0"],"函数":["93.0"],"可以做一些初始化数据的获取":["93.0"],"当前阶段不能和":["93.0"],"进行交互":["93.0"],"但是可以通过":["93.0"],"vm":["93.0"],"nexttick":["93.0"],"来访问":["93.0"],"之后触发钩子函数":["93.0"],"所以可以访问到":["93.0"],"确保在销毁实例时不会触发不必要的回调或产生不稳定的行为":["93.1"],"清理订阅":["93.1"],"如果使用了观察者模式或者订阅发布模式":["93.1"],"子组件更新过程":["93.2"],"beforeupdate":["93.2"],"如果需要在组件实例被创建时立即获取数据并且不依赖于":["93.3"],"转化成":["94.0"],"ast":["94.0"],"抽象语法树":["94.0"],"任何非":["95.0"],"document":["95.1"],"createelement":["95.1"],"链":["95.2"],"类似":["95.3"],"区别是用户可以设置一个阈值":["95.3"],"大于阈值交给":["95.3"],"处理":["95.3"],"小于阈值返回文件的":["95.3"],"编码":["95.3"],"通过compiler获取webpack内部的钩子":["96.2"],"hooks":["96.2"],"done":["96.2"],"找到依赖关系":["97.0"],"babel":["97.1"],"babylon":["97.1"],"代码转化为":["97.1"],"ast抽象语法树":["97.1"],"webpack":["98.0"],"打包的":["98.0"],"chunk":["98.0"],"编译后浏览器替换修改的模块":["99.0"],"再去启动":["99.1"],"建立本地服务和浏览器的双向通信":["99.1"],"每次编译后":["99.1"],"setrequestheader":["100.0"],"type":["100.0"],"application":["100.0"],"json":["100.0"],"mybind":["101.0"],"args1":["101.0"],"首先需要进行判断":["101.0"],"如果调用者不是函数":["101.0"],"直接抛出异常":["101.0"],"fn":["102.0"],"of":["102.0"],"proto":["103.0"],"getprototypeof":["103.0"],"sleepwrapper":["104.0"],"return":["104.0","105.0","107.2","108.0","112.0","114.0","115.0","121.1"],"链式调用":["104.0"],"sleepfirst":["104.0"],"delete":["105.0"],"set":["105.0"],"创建一个新对象":["106.0"],"关联到构造函数的原型":["106.0"],"obj":["106.0","117.0"],"create":["106.0"],"error":["107.0"],"保证rejecttask事件注册成功":["107.0"],"关键代码":["107.0"],"执行fn函数":["107.0"],"then":["107.1"],"res":["107.1"],"catch":["107.1"],"err":["107.1"],"all静态方法":["107.1"],"返回promises列表中全部执行完的结果":["107.1"],"resolve":["107.2"],"reject":["107.2"],"clear":["108.0"],"返回清除定时器的方法":["108.0"],"cleartimeout":["108.0"],"temp":["111.0"],"treedata":["111.0"],"i":["111.0"],"使用数组的filter方法":["112.0"],"过滤掉要取消订阅的回调函数":["112.0"],"实现代码":["113.0"],"真正的渲染函数":["113.0"],"render":["113.0"],"vnode":["113.0"],"如果是数字类型转化为字符串":["113.0"],"if":["113.0","121.1"],"typeof":["113.0"],"number":["113.0"],"string":["113.0"],"else":["114.0","115.0"],"push":["114.0","115.0"],"注意差别在这行":["116.0"],"我们对内层循环的范围作了限制":["116.0"],"初始化":["116.1"],"为当前区间第一个元素":["116.1"],"j分别定义当前区间的上下界":["116.1"],"j":["116.2"],"判断":["116.2"],"前面一个元素是否比":["116.2"],"pivotindex":["116.3"],"partition":["116.3"],"对枢轴左侧和右侧的子数组分别进行快速排序":["116.3"],"合并左右两个有序数组":["116.4"],"mergearr":["116.4"],"返回合并后的结果":["116.4"],"arr1":["116.4"],"arr2":["116.4"],"初始化两个指针":["116.4"],"分别指向":["116.4"],"方法3":["117.0"],"使用对象":["117.0"],"newobj":["119.0"],"array":["119.0"],"isarray":["119.0"],"上一次执行":["121.0"],"的时间":["121.0"],"previous":["121.0"],"timer":["121.1"],"null":["121.1"],"args":["121.1"],"以便以后回顾或找到更优解":["123.0"]},{"0":["6.10","6.13","6.21","32.0","43.1","64.15","116.2","121.0"],"1":["18.0","23.2","60.6","73.8","105.0"],"2":["9.0","60.6","63.4","65.0","70.6","88.4","88.10","94.0"],"3":["32.0","35.0","38.0","60.6","61.3","63.1","68.0","80.11","91.10","92.19","97.1"],"4":["30.0","33.0","39.0","60.6","91.12","100.0"],"5":["66.0","80.5","84.3"],"6":["92.15","92.25"],"7":["91.4","92.25"],"8":["56.0"],"9":["91.3"],"10":["64.16"],"32":["64.6"],"64":["64.11"],"302":["74.2"],"502":["74.4"],"端":["5.0"],"用户是否将浏览器全屏也是个问题":["5.0"],"不同屏幕分辨率也不同":["5.0"],"的约束":["5.1"],"img":["5.1"],"来标记图像背景尺寸":["5.1"],"适用于图片尺寸自适应":["5.1"],"overflow":["5.1","6.26"],"x":["5.1"],"排版横向列表":["5.1"],"flexbox":["5.1"],"或":["5.1","6.10"],"inline":["5.1","16.1"],"block":["5.1","16.1"],"的形式横行排列元素":["5.1"],"且属性会继承":["6.2"],"会影响后代行内内容":["6.2"],"如果子元素宽度大于父元素宽度就会失效":["6.2"],"宽度要小于父元素":["6.3"],"否则无效":["6.3"],"css":["6.3","40.1","95.1"],"align对其生效":["6.4"],"优点":["6.4","6.6","72.0","92.7"],"兼容性好":["6.4"],"00ff00":["6.5"],"简单":["6.6"],"与height等值":["6.8"],"元素在页面呈现为5行":["6.9"],"则line":["6.9"],"height的值为height":["6.9"],"兼容性不好":["6.10"],"ie9":["6.10"],"当":["6.10"],"为":["6.10","64.16","73.3","121.1"],"时":["6.10","87.0","89.9"],"会无限延伸占满空间并且平分":["6.10"],"self":["6.11"],"font":["6.13","43.1"],"size":["6.13","43.1"],"text":["6.14","95.1"],"center":["6.14"],"如果是行内元素就添加这个":["6.14"],"定宽高时等同于margin":["6.15"],"负自身宽度一半":["6.15"],"height":["6.16","6.19","6.22","21.1","21.2"],"50px":["6.16"],"top":["6.16"],"align":["6.17","23.1"],"items":["6.17","23.1"],"width":["6.19","6.20","6.21","6.27"],"100px":["6.19","6.27","38.0"],"color":["6.20","6.21"],"f00":["6.20","6.21"],"background":["6.21","6.27"],"500px":["6.22"],"display":["6.22","16.1","40.1"],"10px":["6.23","6.24","6.27"],"只设置浮动":["6.23"],"不设宽度":["6.24"],"margin":["6.24","6.27","33.0"],"间距":["6.27"],"user":["9.0"],"scalable":["9.0"],"no":["9.0"],"fastclick":["9.0"],"js":["9.0","64.11","95.3"],"才能开始渲染":["10.0"],"因此":["10.0"],"加载是会阻塞":["10.0"],"的渲染的":["10.0"],"可能会操作之前的":["10.0"],"节点和":["10.0"],"样式":["10.0"],"因此浏览器会维持":["10.0"],"中":["10.0","18.0"],"带宽":["11.0"],"webkit":["12.0","17.2","37.0"],"blink":["12.0"],"响应处理":["13.0"],"检查响应类型":["13.0"],"content":["13.0","40.1","74.1"],"type":["13.0","53.3","71.0","95.1"],"如果是字节流类型":["13.0"],"则将该请求提交给下载管理器":["13.0"],"该导航流程结束":["13.0"],"不再进行后续的渲染":["13.0"],"html":["13.0","70.4"],"则通知浏览器进程准备渲染进程准备进行渲染":["13.0"],"准备渲染进程":["13.0"],"浏览器进程检查当前":["13.0"],"是否和之前打开的渲染进程根域名是否相同":["13.0"],"如果相同":["13.0"],"则复用原来的进程":["13.0"],"是进程内的最小执行单位":["14.1"],"是进程的一部分":["14.1"],"一个进程可以包含多个线程":["14.1"],"转换为用户可以与之交互的网页":["14.2"],"gpu":["14.2"],"进程":["14.2"],"与其他区域相互隔离":["16.0"],"的边界会包裹浮动元素":["16.2"],"垂直外边距重叠":["16.2"],"在同一个":["16.2","70.3"],"input":["17.2"],"hidden":["18.0"],"是一样的":["18.0"],"chrome":["18.0"],"使用":["18.0","54.1","92.21"],"圆角边框":["19.0"],"边框图像":["19.0"],"减少选择器的复杂性":["20.0"],"避免使用":["20.0"],"weight":["21.0","21.1"],"大小由内容撑开":["21.0"],"当空间不足时":["22.0"],"缩小的比例相同":["22.0"],"空间不足时":["22.0"],"该项目不会缩小":["22.0"],"它的所有子元素自动成为容器成员":["23.0"],"两端对齐":["23.1"],"项目之间的间隔相等":["23.1"],"around":["23.1"],"两个项目两侧间隔相等":["23.1"],"定义在交叉轴上的对齐方式":["23.1"],"交叉轴起点对齐":["23.1"],"都为":["23.2"],"等分剩余空间":["23.2"],"shrink":["23.2"],"css2":["24.0"],"才有的语法":["24.0"],"故只可在":["24.0"],"ie5":["24.0"],"它们发生重叠一个是因为它们相":["25.0"],"邻":["25.0"],"一个是因为父元素的高度不固定":["25.0"],"因此我们可以为父元素设置":["25.0"],"直到相对于":["26.0"],"大小来计算":["27.0"],"vh":["27.0"],"viewport":["27.0"],"来绘制图形":["28.0"],"需要重新绘制才能进行修改":["28.0"],"需要在特定状态触发后才能执行":["29.0"],"animation":["29.0"],"绝对定位":["30.0"],"父元素设置为相对定位":["30.0"],"左边元素设置为绝对定位":["30.0"],"右边元素的":["30.0"],"设置为":["30.0"],"来描述这个元素的状态":["31.0"],"双冒号":["31.0"],"读屏器会读取":["32.0"],"opacity":["32.0"],"auto":["33.0","38.0"],"资源预加载":["34.0"],"这样即使外部样式表加载延迟":["35.0"],"页面仍然可以有基本的样式展示":["35.0"],"避免出现完全无样式的情况":["35.0"],"使用样式预加载":["35.0"],"如果需要手写编写动画":["36.0"],"可以将最小时间间隔设置为":["36.0"],"box":["37.0","42.0"],"line":["37.0"],"clamp":["37.0"],"负值":["38.0"],"必须定宽高":["38.0"],"如果元素为绝对定位":["39.0"],"position":["39.0"],"所以父元素在计算高度的时候并没有将浮动元素的高度计算出来":["40.0"],"伪元素":["40.1"],"outer":["40.1"],"after":["40.1","104.0"],"border":["41.0"],"可以通过":["42.0","60.3"],"sizing":["42.0"],"属性来改变元素的盒模型":["42.0"],"而文本节点默认会应用一定的样式":["43.0"],"导致":["43.0"],"父元素设置":["43.1"],"伪元素选择器":["44.0"],"后代选择器":["44.0"],"属性选择器":["44.1"],"伪类选择器":["44.1"],"标签选择器":["44.1"],"前者回调函数中的":["45.0"],"this":["45.0","63.5"],"指向当前元素":["45.0"],"这意味着如果脚本的加载速度很快":["46.0"],"可能会在页面的其他资源加载之前执行":["46.0"],"导致可能的依赖问题":["46.0"],"脚本的执行时机是在文档解析完毕后":["46.0"],"domcontentloaded":["46.0"],"id":["47.0","88.2","88.9"],"来实现":["47.0"],"video":["48.0"],"canvas":["48.0"],"画布":["48.0"],"拖拽元素":["48.0"],"代码复用":["49.0"],"可以将共享的内容嵌套在多个页面中":["49.0"],"mobile":["50.0"],"number":["50.0","64.8"],"以备将来可能需要用到":["51.0"],"适用于当前页面未使用但可能在后续页面或用户操作中可能会用到的资源":["51.0"],"preload":["51.0"],"预加载":["51.0"],"href":["52.0"],"指向网络资源所在位置":["52.0"],"建立和当前元素或当前文档之间的链接":["52.0"],"a":["52.0"],"link":["52.0"],"area":["52.0"],"data":["53.1","92.10","92.18","118.0"],"处理接收到的消息":["53.1"],"发送消息":["53.1"],"send":["53.1"],"var":["53.2"],"val":["53.2"],"name":["53.3","80.5","88.5"],"就会有明显的语调上的变化":["54.1"],"标签则没有":["54.1"],"如果是搜索引擎的爬虫对我们的网页进行分析的话":["54.1"],"它会依赖":["54.1"],"侧边栏":["54.2"],"footer":["54.2"],"页脚":["54.2"],"figure":["54.2"],"对象":["56.0","80.5","90.2"],"用于更好地处理异步操作":["56.0"],"解决了回调地狱的问题":["56.0"],"并提供了更清晰的异步编程模式":["56.0"],"类和模块化":["56.0"],"es6":["56.0"],"引入了类的概念":["56.0"],"可以使用":["56.0","70.2","92.25","93.3"],"class":["56.0"],"关键字定义类":["56.0"],"await":["57.0"],"事件轮询执行时机":["57.0"],"隐式返回":["57.0"],"promise":["57.0","91.12","109.0"],"会产生一个微任务":["57.0"],"后面的代码是在微任务时执行":["57.0"],"event":["57.0"],"loop":["57.0"],"和浏览器更新渲染时机1":["57.0"],"浏览器更新渲染会在":["57.0"],"中的":["57.0","90.4"],"和":["57.0","58.0","69.1","73.5","89.9","90.5","91.9","116.4"],"使用let":["58.0"],"声明的变量不会被绑定到window上":["58.0"],"这里需要注意的时候":["58.0"],"true":["59.0","80.2","87.1"],"来阻止冒泡":["59.0"],"默认事件的话通过事件对象的":["59.0"],"之前的":["59.1"],"ie":["59.1"],"不支持":["59.1"],"方法":["59.1","60.6"],"而是设置事件对象":["59.1"],"cancelbubble":["59.1"],"属性为":["59.1"],"在块级作用域中":["60.3"],"也不能跨函数访问":["60.4"],"没有变量提升":["60.4"],"不能重复声明":["60.4"],"如果还没有找到":["60.5"],"一直找到全局上下文的变量对象":["60.5"],"后":["60.6"],"打印":["60.6"],"使用立即执行函数创建了闭包":["60.6"],"将当前的":["60.6"],"值传递给回调函数":["60.6"],"就会去原型的proto属性所指向的原型对象上去查找":["61.1"],"直到找到":["61.1"],"属性":["61.3"],"奔溃等问题":["62.0"],"有自动的垃圾回收机制":["62.1"],"当一个值":["62.1"],"如果发现有对象没有被标识为可到达对象":["62.2"],"那么就将此对象占用的内存回收":["62.2"],"weakset":["62.4"],"执行上下文就是指当前环境中的变量":["63.0"],"函数声明":["63.0"],"eval":["63.1"],"执行上下文":["63.1"],"全局上下文只有一个":["63.2"],"也就是":["63.2"],"每当":["63.3"],"引擎调用一个函数的时候":["63.3"],"会为该函数创建一个新的执行上下文并压入栈的顶部":["63.3"],"指向":["63.4"],"代码中":["63.5"],"动态语言":["64.0"],"object":["64.1"],"普通对象":["64.1"],"函数":["64.1","91.5"],"文件在不同模块":["64.2"],"值作为对象的属性名":["64.3"],"通过":["64.3","89.10","91.9"],"只需要在数字末尾追加":["64.4"],"来解除引用":["64.5"],"字面意思就是":["64.5"],"的最初版本中使用的是":["64.6"],"位系统":["64.6"],"引用数据类型用堆存储":["64.7"],"堆内存是动态分配":["64.7"],"都是":["64.8"],"nan":["64.8","64.12"],"instanceof":["64.8","101.0"],"value":["64.9","64.15"],"将要判断的变量作为参数传入":["64.9"],"并判断返回的字符串是否为":["64.9"],"if":["64.10","100.0","101.0"],"hasownproperty":["64.10","117.0","119.0"],"在转换为二进制表示的时候会出现位数无限循环的情况":["64.11"],"中是以":["64.11"],"位双精度格式来存储数字的":["64.11"],"只有":["64.11"],"的判断":["64.12"],"一般情况下和":["64.13"],"相同":["64.13"],"首先转换成布尔值":["64.14"],"false":["64.14"],"valueof":["64.15"],"且第一个参数不以":["64.16"],"0x":["64.16"],"开头时":["64.16"],"按照":["64.16"],"为基数返回":["64.16"],"本质上是健值对的集合":["64.17"],"activexobject":["65.0"],"microsoft":["65.0"],"xmlhttp":["65.0"],"兼容ie6及以下版本":["65.0"],"配置":["65.0"],"ajax请求地址":["65.0"],"open":["65.0"],"get":["65.0","89.9"],"但在某些方面功能较为简单":["65.1"],"需要进行封装来处理错误":["65.1"],"超时等情况":["65.1"],"是一个第三方库":["65.1"],"服务器上读取数据":["66.0"],"减少远程访问":["66.0"],"的带宽":["66.0"],"分担网络流量":["66.0"],"减轻原站点web":["66.0"],"负载等功能":["66.0"],"集群抗攻击":["66.0"],"广泛分布的":["66.0"],"服务器发起解析请求":["67.0"],"服务器接收请求并返回":["67.0"],"没有限制":["68.0"],"请求是安全且幂等的":["68.0"],"无论操作多少次":["68.0"],"的报文传输":["69.0"],"三次握手之后还需要进行":["69.0"],"tcp":["69.1"],"之间加入了":["69.1"],"加密这个随机数":["69.3"],"发给服务端":["69.3"],"第四步":["69.3"],"服务端使用自己的私钥":["69.3"],"可以发布给任何人":["69.4"],"并且加密的内容只有相匹配的密钥才能解":["69.4","84.2"],"这样带来的一个好处就是能保证传输的内容是安全的":["69.4","84.2"],"因为例如如果是公钥加密的数据":["69.4","84.2"],"就算是第三方截取了这个数据但是没有对应的私钥也破解不了":["69.4"],"不过它也有缺点":["69.4"],"一是公钥因为是公开的":["69.4"],"谁都可以过去":["69.4"],"如果内容是通过私钥加密的话":["69.4"],"那拥有对应公钥的黑客就可以用这个公钥来进行解密得到里面的信息":["69.4"],"payload":["69.5"],"如账号密码":["69.5"],"生成一个字符串":["69.5"],"简单文本的形式":["70.1"],"易于理解":["70.1"],"学习和使用的门槛低":["70.1"],"当要完成有关联性的操作时会麻烦":["70.2"],"减轻了服务器端的负载":["70.3"],"持久连接就是只要任意一端没有明确提出断开连接":["70.3"],"就会报错":["70.3"],"连接状态":["70.3"],"管道":["70.3"],"握手和慢启动过程耗费的时间":["70.4"],"常见的合并请求比如精灵图就是将请求多个小图片合并成请求成一张大的图片":["70.4"],"请求的次数":["70.4"],"减少网络开销":["70.4"],"延迟发送请求":["70.4"],"一个":["70.4"],"文件中会包含很多的":["70.4"],"如果是当前页面不需要的资源":["70.4"],"没必要一次性全部获取":["70.4"],"可以通过按需获取的方式":["70.4"],"减少第一时间的":["70.4"],"比如请求网页的时候":["70.4"],"就没有必要把全部的资源获取到":["70.4"],"是没办法做其它事情的":["70.6"],"如果响应迟迟不来":["70.6"],"后续的请求是无法发送的":["70.6"],"这就造成了队头阻塞的问题":["70.6"],"通过使用多个":["70.6"],"stream":["70.6"],"复用一条":["70.6"],"连接":["70.6"],"达到并发的效果":["70.6"],"连接包含一个或者多个":["70.6"],"是":["70.6","88.1"],"并发的关键技术":["70.6"],"里可以包含":["70.6"],"个或多个":["70.6"],"message":["70.6","92.5"],"对应":["70.6"],"表示本次回应的数据长度":["71.0"],"信息识别":["72.0"],"让应用系统能够识别已经登录过的用户":["72.0"],"其实要把":["72.0"],"发送到认证系统进行校验":["72.0"],"单点登录":["72.0"],"用户只需登录一次":["72.0"],"消息队列等方式":["73.0"],"而不同的设备之间想要进行通信":["73.0"],"一对一":["73.1"],"调整发送速度":["73.2"],"等特点":["73.2"],"基于这些特点能够保证数据包能够可靠的传输给对方":["73.2"],"所有是安全的":["73.2"],"可靠的":["73.2"],"只负责传输数据":["73.2"],"不保证数据能否抵达":["73.2"],"传输效率比较高":["73.2"],"实时性也比较好":["73.2"],"当应用传输的数据非常大的时候":["73.2"],"用来解决丢包问题":["73.3"],"控制位":["73.3"],"ack":["73.3","73.5"],"不保证网络包中数据的完整性":["73.4"],"如果需要保证网络数据包的可靠性":["73.4"],"置为":["73.5"],"最后把这个报文发给客户端":["73.5"],"服务端处于":["73.5"],"rcvd":["73.5"],"客户端收到":["73.6"],"一样发送一个":["73.6"],"报文作为应答":["73.6"],"且把服务端的序列号值":["73.6"],"作为自己":["73.6"],"ticket":["73.7"],"另一种方式是":["73.7"],"此会出现丢包":["73.8"],"对实时的应用比如":["73.8"],"ip":["73.8"],"电话和视频会议等":["73.8"],"只能是":["73.8"],"对":["73.8","89.3","97.1"],"但是响应头没有body数据":["74.1"],"found":["74.2"],"表示临时重定向":["74.2"],"表示服务器禁止访问资源":["74.3"],"不是客户端的请求出错":["74.3"],"通常是服务器作为网关或代理时返回的错误码":["74.4"],"复杂请求":["75.0"],"不符合以上条件的就是复杂请求":["75.0"],"复杂请求的":["75.0"],"cors":["75.0"],"则到达一定的时间限制才返回":["76.0"],"客户端":["76.0","92.21"],"javascript":["76.0","77.3"],"响应处理函数会在处理完服务器返回的信息后":["76.0"],"再次发出请求":["76.0"],"重新建立连接":["76.0"],"长轮询和短轮询比起来":["76.0"],"cache":["77.0"],"service":["77.0","77.3"],"worker":["77.0","77.3"],"不再是一个时间戳":["77.1"],"而是一个时间长度":["77.1"],"意味着该资源在当前时间长度内都是有效的":["77.1"],"这就完美规避了时间戳带来的潜在问题":["77.1"],"相对于":["77.1"],"更加准确":["77.1"],"优先级也更高":["77.1"],"两者同时出现":["77.1"],"以":["77.1","91.9"],"为准":["77.1"],"s":["77.1"],"服务端并不知道我们是否真正改变了文件":["77.2"],"它仍然通过最后编辑时间进行判断":["77.2"],"因此这个资源在再次被请求时":["77.2"],"会被当作新资源":["77.2"],"进而引发一次完整的响应":["77.2"],"不该重新请求的时候":["77.2"],"也会重新请求":["77.2"],"当我们修改文件的速度过快时":["77.2"],"由于":["77.2"],"只能检查到以秒为最小计量单位的时间差":["77.2"],"所以是感知不到这个改动的":["77.2"],"该请求的时候没有请求":["77.2"],"也可以放进去":["77.3"],"但是较大的":["77.3"],"就不可以了":["77.3"],"因为内存资源是有限的":["77.3"],"独立于主线程之外的":["77.3"],"线程":["77.3"],"脱离于浏览器窗体":["77.3"],"的时候":["77.5"],"就可以获取到客户端的状态":["77.5"],"有体积上限":["77.5"],"存储只适用于当前会话的信息":["77.7"],"相同点":["77.7"],"localstorage":["77.8"],"一份到":["77.9"],"服务器上的过程":["77.9"],"回源":["77.9"],"这个就是懒加载":["78.0"],"懒加载的实现有两个关键的数值":["78.0"],"一个是当前可视区域的高度":["78.0"],"const":["78.0","113.0","114.0","115.0","118.0"],"在一段时间内":["78.1"],"seo":["79.0"],"客户端渲染":["79.0"],"在搜索引擎搜索某个关键字":["79.0"],"是找不到的":["79.0"],"因为搜索引擎只会搜现成的内容":["79.0"],"所以这种情况下":["79.0"],"会使用服务端渲染":["79.0"],"渲染引擎开始解析":["79.1"],"转换树中的标签到":["79.1"],"节点":["79.1"],"被称为内容树":["79.1"],"cssom":["79.1"],"标签":["79.2"],"会暂停渲染过程":["79.2"],"将控制器交给":["79.2"],"引擎":["79.2"],"引擎对内联的":["79.2"],"代码会直接执行":["79.2"],"对外部":["79.2"],"文件要先获取到脚本":["79.2"],"再进行执行":["79.2"],"浏览器不需要重新计算元素的几何属性":["79.3"],"直接为该元素绘制新的样式":["79.3"],"这个过程叫重绘":["79.3"],"所以":["79.3"],"重绘不一定导致回流":["79.3"],"连接这两个步骤":["80.0"],"前端可以做的非常有限":["80.0"],"核心是在":["80.0"],"只需要为":["80.2"],"添加":["80.2"],"cachedirectory":["80.2"],"manifest":["80.3"],"json":["80.3"],"context需要和webpack":["80.3"],"js保持一致":["80.3"],"context":["80.3"],"编译完成之后":["80.3"],"运行这个文件":["80.3"],"dist文件夹多出两个文件":["80.3"],"会充分释放":["80.4"],"在多核并发方面的优势":["80.4"],"output":["80.5"],"chunkfilename":["80.5"],"chunkhash":["80.5"],"chunk":["80.5"],"写路由的时候":["80.5"],"压缩是服务器的工作":["80.6"],"服务器接收到需要压缩的文件":["80.6"],"会启动自己的":["80.6"],"cpu":["80.6"],"去完成这个任务":["80.6"],"压缩本身也是需要耗费时间的":["80.6"],"它可以表示的颜色种类就越多":["80.7"],"成像效果就越细腻":["80.7"],"文件体积相应就越大":["80.7"],"一个二进制位表示两种颜色":["80.7"],"在我们日常的开发中":["80.8"],"图片经常作为大的背景图":["80.8"],"轮播图或":["80.8"],"banner":["80.8"],"对线条的处理更加细腻":["80.9"],"对透明度有良好的支持":["80.9"],"当追求最佳的显示效果":["80.9"],"不在意文件体积大小的时候":["80.9"],"推荐使用":["80.9"],"是文本文件":["80.10"],"我们既可以像写代码一样定义":["80.10"],"也可以把他写在":["80.10"],"如果把大图也编码到":["80.11"],"文件中":["80.11"],"后者的体积会明显增加":["80.11"],"即便减少了":["80.11"],"如果浏览器环境支持":["80.12"],"优先使用":["80.12"],"格式":["80.12"],"否则把图片降级为":["80.12"],"验证请求来源":["81.0"],"可以使用参数化的":["82.0"],"或者直接使用存储过程进行数据查询存取":["82.0"],"中的用户私密信息":["83.0"],"或者攻击者在论坛中加一个恶意表单":["83.0"],"当用户提交表单的时候":["83.0"],"却把信息传送到攻击者的服务器中":["83.0"],"有公钥和私钥之分":["84.1"],"公钥所有人都知道":["84.1"],"客户端把解密后的":["84.3"],"传递给服务端":["84.3"],"使用随机码":["84.3"],"并通过和服务器建立的对称加密的密钥进行解密":["84.4"],"中间人再通过和客户端建立的对称加密对响应数据进行加密后传输给客户端":["84.4"],"客户端通过与中间人建立的对称加密的密钥对数据进行解密":["84.4"],"简单来说":["84.4"],"生成唯一且安全的文件名":["85.0"],"防止刷票和灌水":["86.0"],"可以打开":["87.1"],"deep":["87.1","89.2"],"选项":["87.1"],"这样便会对对象中的每一项进行监听":["87.1"],"每个属性提供的函数作为属性的":["87.2"],"从而确保对象的每一个属性更新时都会触发传入的回调函数":["87.3"],"主要原因在于对象属于引用类型":["87.3"],"单个属性的更新并不会触发对象":["87.3"],"params":["88.0"],"等":["88.1"],"vue":["88.1","95.3"],"属性加上":["88.2"],"babel":["88.3"],"的问题":["88.3"],"都会在浏览器的访问历史中增加一个记录利用":["88.4"],"的以上特点":["88.4"],"就可以来实现前端路由":["88.4"],"更新视图但不重新请求页面":["88.4"],"的功能了":["88.4"],"特点":["88.4"],"兼容性好但是不美观":["88.4"],"采用":["88.4"],"html5":["88.4"],"的新特性":["88.4"],"且提供了两个新方法":["88.4"],"pushstate":["88.4"],"replacestate":["88.4"],"是要显示组件的占位组件":["88.5"],"可以嵌套":["88.5"],"对应路由配置的嵌套关系":["88.5"],"配合":["88.5"],"back":["88.6"],"后退":["88.6"],"forward":["88.6"],"new":["88.7","107.0"],"例如":["88.8","88.9"],"beforeenter":["88.8"],"守卫只在进入路由时触发":["88.8"],"因此只会影响这个路由":["88.8"],"控制更精确":["88.8"],"path":["88.9"],"users":["88.9"],"匹配对应路由":["88.10"],"将":["88.10","91.1","121.0"],"router":["88.10"],"定义成一个":["88.10"],"还需要深度遍历":["89.0"],"优势":["89.0"],"针对对象":["89.0"],"proxy":["89.1","89.7"],"可以通过配置选项来控制监听行为":["89.2"],"比如":["89.2"],"immediate":["89.2"],"tree":["89.3"],"shaking":["89.3"],"友好":["89.3"],"代码也更容易压缩":["89.3"],"体积更小":["89.4"],"更好的":["89.4"],"beforeunmount":["89.5"],"destroyed":["89.5"],"在":["89.6"],"闭包中缓存了变量":["89.6"],"无需顾虑调用顺序":["89.6"],"编译器优化":["89.7"],"静态提升":["89.7","89.8"],"patchflags":["89.7"],"静态标记":["89.7"],"事件监听缓存":["89.7"],"基于":["89.7"],"的响应式系统":["89.7"],"ssr":["89.7"],"只对比有标记的":["89.8"],"dom":["89.8","91.9"],"元素":["89.8","93.3"],"事件增加缓存":["89.8"],"set":["89.9"],"实现响应式":["89.9"],"用于模板":["89.9"],"reactive":["89.9"],"不需要":["89.9"],"getcurrentinstance":["89.10"],"获取当前实例":["89.10"],"否则会报错":["90.0"],"的方式":["90.1"],"调用":["90.1"],"两个":["90.1"],"时几乎完全一样":["90.1"],"但是定义两者时却不甚相同":["90.1"],"回调函数接收":["90.2"],"mutation":["90.2","90.4"],"对象和":["90.2"],"这样可以进一步判断":["90.2"],"编写的代码就不够优雅":["90.3"],"每个提交的地方都要单独做保存处理":["90.3"],"这里就可以利用":["90.3"],"提供的":["90.3"],"中只有":["90.4"],"state":["90.4","92.6"],"getter":["90.4"],"action":["90.4"],"抛弃了":["90.4"],"一直都不太受小伙伴们的待见":["90.4"],"对外暴露状态":["90.5"],"提供":["90.5"],"修改属性":["90.5"],"这里需要设置":["90.5"],"来劫持各个属性的":["91.0"],"setter":["91.0"],"还负责合并":["91.1"],"option":["91.1"],"然后":["91.1"],"会经过":["91.1"],"generate":["91.1"],"并不知道后续还有":["91.3"],"次更新操作":["91.3"],"所以会马上执行流程":["91.3"],"最终执行":["91.3"],"次流程":["91.3"],"而通过":["91.3"],"vnode":["91.3"],"个变异的方法":["91.4"],"能改变原数组的方法":["91.4"],"render":["91.5","91.7"],"此时会触发属性依赖收集":["91.5"],"为什么不推荐使用":["91.6"],"index":["91.6","107.1"],"作为":["91.6"],"因为使用":["91.6"],"和不带":["91.6"],"的效果是一样的":["91.6"],"或者":["91.7"],"的优先级更高":["91.7"],"如果用户写的是":["91.7"],"会做模板编译":["91.7"],"算法支持":["91.8"],"但是这样粒度过细导致":["91.8"],"无法承载较大应用":["91.8"],"中为了降低":["91.8"],"watcher":["91.8","91.11"],"粒度":["91.8"],"每个组件只有一个":["91.8"],"与之对应":["91.8"],"此时就需要引入":["91.8"],"mvvm":["91.9","92.0"],"框架中要解决的一个核心问题是连接数据层和视图层":["91.9"],"数据驱动":["91.9"],"应用":["91.9"],"数据变化":["91.9"],"视图更新":["91.9"],"要做到这点的就需要对数据做响应式处理":["91.9"],"这样一旦数据发生变化就可以立即做出更新处理":["91.9"],"为例说明":["91.9"],"通过数据响应式加上虚拟":["91.9"],"patch":["91.9"],"算法":["91.9"],"开发人员只需要操作数据":["91.9"],"关心业务":["91.9"],"初始化组件状态":["91.10"],"创建各种响应式数据":["91.10"],"建立更新机制这一步会立即执行一次组件更新函数":["91.10"],"去通知":["91.11"],"进行更新操作":["91.11"],"依次调用":["91.11"],"更新后的状态":["91.12"],"比如希望获取列表更新后的高度":["91.12"],"签名如下":["91.12"],"function":["91.12","118.0","121.0"],"callback":["91.12"],"void":["91.12"],"我们知道":["91.13"],"进行了优化":["91.14"],"转换成了":["91.14"],"模式启发":["92.0"],"简化了映射关系":["92.0"],"一个组件被复用多次的话":["92.1"],"也会创建多个实例":["92.1"],"本质上":["92.1"],"这些实例用的都是同一个构造函数":["92.1"],"触发组件的":["92.2"],"beforecreate":["92.2"],"create":["92.2"],"beforemount":["92.2"],"mounted":["92.2"],"钩子":["92.2"],"的时候触发组件的":["92.2"],"beforedestory":["92.2"],"destory":["92.2"],"vue3":["92.3"],"中完全相反":["92.3"],"值":["92.4","99.1"],"再通过":["92.4"],"的字样":["92.5"],"可以在":["92.5"],"的":["92.6"],"和用户的交互":["92.7"],"用户体验好":["92.7"],"内容的改变不需要重新加载整个页面":["92.7"],"避免了不必要的跳转和重复渲染":["92.7"],"解决办法":["92.8"],"减小入口文件体积":["92.8"],"静态资源本地缓存":["92.8"],"其中":["92.9"],"的优先级比":["92.9"],"高":["92.9"],"对应两个钩子函数":["92.9"],"这样会导致大量的":["92.11"],"mergeoptions":["92.12"],"方法进行合并":["92.12"],"采用策略模式针对不同的属性进行合并":["92.12"],"当组件和混入对象含有同名选项时":["92.12"],"层上":["92.13"],"会自动将数据渲染到页面中":["92.13"],"视图变化会通知":["92.13"],"层更新数据":["92.13"],"代表数据模型":["92.13"],"也可以在":["92.13"],"中定义数据修改和操作的业务逻辑":["92.13"],"是因为引入了":["92.14"],"fragment":["92.14"],"的概念":["92.14"],"这是一个抽象的节点":["92.14"],"如果发现组件是多根的":["92.14"],"函数式组件的":["92.15"],"props":["92.15"],"可以不用显示声明":["92.15"],"所以没有在":["92.15"],"里面声明的属性都会被自动隐式解析为":["92.15"],"prop":["92.15"],"而普通组件所有未声明的属性都解析到":["92.15"],"事件监听器":["92.16"],"它可以通过":["92.16"],"provide":["92.16"],"inject":["92.16"],"祖先组件中通过":["92.16"],"provider":["92.16"],"来提供变量":["92.16"],"然后在子孙组件中通过":["92.16"],"来注入变量":["92.16"],"api":["92.16","92.19"],"主要解决了跨级组件间的通信问题":["92.16"],"不过它的使用场景":["92.16"],"主要是子组件获取上级组件的状态":["92.16"],"混入对象可以包含任意组件选项":["92.17"],"当组件使用混入对象时":["92.17"],"所有混入对象的选项将被混入该组件本身的选项":["92.17"],"用来传递一个初始值":["92.18"],"这个子组件接下来希望将其作为一个本地的":["92.18"],"数据来使用":["92.18"],"在这种情况下":["92.18"],"最好定义一个本地的":["92.18"],"上实现":["92.19"],"一个库":["92.19"],"提供自己的":["92.19"],"同时提供上面提到的一个或多个功能":["92.19"],"两者的区别":["92.19"],"两者的区别主要表现在以下几个方面":["92.19"],"编写形式":["92.19"],"编写一个组件":["92.19"],"可以有很多方式":["92.19"],"我们最常见的就是":["92.19"],"格式不同":["92.20"],"num":["92.20"],"作为客户端与服务端的公用入口":["92.21"],"导出":["92.21"],"根实例":["92.21"],"供客户端":["92.21"],"entry":["92.21","98.0"],"与服务端":["92.21"],"主要作用挂载到":["92.21"],"上":["92.21"],"服务端":["92.21"],"除了创建和返回实例":["92.21"],"还进行路由匹配与数据预获取":["92.21"],"webpack":["92.21"],"为客服端打包一个":["92.21"],"client":["92.21"],"bundle":["92.21"],"为服务端打包一个":["92.21"],"服务器接收请求时":["92.21"],"会根据":["92.21"],"undefined":["92.22"],"其他的元素的键值还是不变":["92.22"],"pug":["92.24"],"编写":["92.24"],"用":["92.24"],"sass":["92.24"],"ts":["92.24"],"结合":["92.25"],"prettier":["92.25"],"eslint":["92.25"],"即可":["92.25"],"最后是提交规范":["92.25"],"husky":["92.25"],"lint":["92.25"],"staged":["92.25"],"commitlint":["92.25"],"目录结构我有如下习惯":["92.25"],"等属性":["93.0"],"实例挂载之前发生":["93.0"],"在这之前":["93.0"],"template":["93.0"],"模板已经导入渲染函数编译":["93.0"],"当前阶段虚拟":["93.0"],"已经创建完成":["93.0"],"即将开始渲染":["93.0"],"在此时也可以对数据进行更改":["93.0"],"不会触发":["93.0"],"挂载完成之后发生":["93.0"],"可以在这里取消订阅":["93.1"],"确保不再接收到不需要的事件获取数据更新":["93.1"],"销毁第三方库实例":["93.1"],"updated":["93.2"],"traverse":["94.0","97.1"],"是一个对":["94.0"],"文件都必须被对应的":["95.0"],"setattribute":["95.1"],"执行顺序为从右到左":["95.2"],"单文件组件":["95.3"],"raw":["95.3"],"加载文件原始内容":["95.3"],"在运行过程中会广播事件":["96.1"],"tap":["96.2"],"my":["96.2"],"plugin":["96.2"],"compilation":["96.2"],"递归遍历引入的其它js":["97.0"],"生成最终的依赖关系图":["97.0"],"然后通过":["97.1"],"ast":["97.1"],"进行遍历":["97.1"],"遍历的目的找到文件的":["97.1"],"import引用节点":["97.1"],"有关":["98.0"],"不同的":["98.0"],"局部刷新":["99.0"],"无需刷新整个页面":["99.0"],"会生成一个":["99.1"],"hash":["99.1"],"代表每一次编译的标识":["99.1"],"本次输出的":["99.1"],"onreadystatechange":["100.0"],"readystate":["100.0"],"let":["101.0","116.4","118.0"],"f":["101.0"],"symbol":["101.0"],"result":["101.0","106.0","107.1"],"result如果作为构造函数被调用":["101.0"],"typeof":["102.0"],"while":["103.0","116.2"],"first":["104.0"],"wake":["104.0"],"up":["104.0"],"如果缓存中不存在该键":["105.0"],"返回":["105.0"],"put":["105.0"],"prototype":["106.0","119.0"],"调用构造函数":["106.0"],"将新对象作为上下文":["106.0"],"try":["107.0"],"catch":["107.0"],"then":["107.0","107.2"],"resolvecallback":["107.0"],"rejectcallback":["107.0"],"解决链式调用的情况":["107.0"],"继续返回promise":["107.0"],"func":["107.2"],"res":["107.2","116.4","118.0"],"mysettimeout":["108.0"],"resolve":["109.0"],"length":["111.0"],"in":["111.0","119.0"],"filter":["112.0"],"item":["112.0"],"只保留不需要取消的回调函数的项":["112.0"],"只执行一次订阅事件":["112.0"],"once":["112.0"],"字符串类型直接就是文本节点":["113.0"],"return":["113.0","121.0"],"document":["113.0"],"createtextnode":["113.0"],"普通dom":["113.0"],"迭代":["114.0","115.0"],"使用栈":["114.0","115.0"],"stack":["114.0","115.0"],"时间复杂度为n的情况":["116.0"],"i是左边界":["116.1"],"j是右边界":["116.1"],"j":["116.1","116.4"],"若":["116.1"],"大":["116.2"],"返回排序后的数组":["116.3"],"定义名为partition的分区函数":["116.3"],"将最右边的元素作为枢轴元素":["116.3"],"pivot":["116.3"],"i":["116.4"],"初始化结果数组":["116.4"],"缓存arr1的长度":["116.4"],"len1":["116.4"],"通过这个字段来确定子父级":["118.0"],"实现代码如下":["118.0"],"treetolist":["118.0"],"key":["119.0"],"reduce":["120.0"],"处理结果当作函数返回":["121.0"],"args":["121.0"],"获取当前时间":["121.0"],"cleartimeout":["121.1"],"time":["121.1"],"新增部分":["121.1"],"start":["121.1"]},{"0":["6.14","6.16","39.0","58.0","80.7"],"1":["53.1","73.3","80.7","88.6"],"2":["18.0","37.0"],"3":["63.3","65.0","88.5","90.2","90.5","91.8","92.17","92.24","99.1"],"4":["19.0","24.0","32.0","65.0","88.9","90.3","97.0","97.1"],"5":["6.9","77.7","91.12"],"6":["84.3"],"7":["91.9"],"8":["95.3"],"9":["56.0"],"20":["6.26"],"50":["33.0"],"53":["64.11"],"200":["100.0"],"206":["74.1"],"304":["74.2"],"404":["74.3"],"1000":["104.0"],"同一张图片在不同的设备上":["5.0"],"大小可能天差地别":["5.0"],"响应式界面的标准是什么":["5.0"],"同一页面在不同大小和比例上看起来都应该是舒适的":["5.0"],"对父元素设置":["5.1"],"auto":["5.1","6.10","23.1"],"横行滚动查看":["5.1"],"适用于横行滚动列表":["5.1"],"元素过多但位置有限的导航栏":["5.1"],"控制文本溢出":["5.1"],"适用于单行文字":["5.1"],"多行文字溢出":["5.1"],"transform":["5.1"],"描绘":["5.1"],"1px":["5.1"],"注意":["6.2"],"只控制行内内容如何相对父元素对齐":["6.2"],"css":["6.2","43.1","92.5"],"son":["6.3","6.13","6.14"],"width":["6.3","27.0"],"缺点":["6.4","6.6","6.9","49.0","92.7"],"只对行内元素有效":["6.4"],"属性会继承影响到后代行内内容":["6.4"],"子绝父相":["6.5"],"top":["6.5"],"bottom":["6.5","6.16","41.1"],"right":["6.5","39.0"],"是相对于父元素尺寸的":["6.5"],"margin":["6.5","6.14","6.15"],"容易理解":["6.6"],"优点":["6.8","6.9","92.15"],"兼容性好":["6.8","6.9"],"简单":["6.10"],"消除幽灵空白节点的bug":["6.13"],"display":["6.13"],"inline":["6.13"],"负自身高度一半":["6.15"],"500px":["6.19","6.20","6.21","6.23","6.24"],"100px":["6.20","6.21","6.22"],"height":["6.20","6.21","6.23","6.24","25.0","40.1"],"background":["6.22","6.23","6.24","17.2"],"color":["6.22","6.23","6.24","6.27"],"f00":["6.22","6.23","6.24","6.27"],"不设宽度":["6.23"],"原理是检查到":["9.0"],"touched":["9.0"],"事件的时候":["9.0"],"会通过":["9.0"],"dom":["9.0","77.3","80.10","92.0","113.0"],"的顺序":["10.0"],"样式表会在后面的":["10.0"],"执行前先加载执行完毕":["10.0"],"所以":["10.0","92.3"],"会阻塞后面":["10.0"],"的执行":["10.0"],"怎么解决":["10.0"],"使用":["10.0","80.8","88.2","93.0","94.0"],"cdn":["10.0"],"因为":["10.0"],"会根据你的网络状况":["10.0"],"解析执行":["12.0"],"代码":["12.0"],"如果不同":["13.0"],"则开启新的渲染进程":["13.0"],"传输数据":["13.0"],"更新状态":["13.0"],"渲染进程准备好后":["13.0"],"浏览器向渲染进程发起":["13.0"],"提交文档":["13.0"],"的消息":["13.0"],"渲染进程接收到消息和网络进程建立传输数据的":["13.0"],"管道":["13.0"],"渲染进程接收完数据后":["13.0"],"向浏览器发送":["13.0"],"确认提交":["13.0"],"浏览器进程接收到确认消息后更新浏览器界面状态":["13.0"],"安全":["13.0"],"地址栏":["13.0"],"每个线程都有自己的独立执行路径和栈空间":["14.1"],"进程和线程的特点":["14.1"],"进程中的任一线程执行出错":["14.1"],"绘制":["14.2"],"网络进程":["14.2"],"不会影响到外部布局":["16.0"],"table":["16.1"],"cell":["16.1"],"caption":["16.1"],"中的元素":["16.2"],"webkit":["17.1"],"autofill":["17.1","17.2"],"值和使用":["18.0"],"没有区别":["18.0"],"flex":["19.0"],"important":["20.0"],"可以使用":["21.0","21.1","77.8"],"padding":["21.0","21.2"],"空间不足时缩小的比例是":["22.0"],"容器中默认存在两条轴":["23.0"],"主轴和交叉轴":["23.0"],"交叉轴终点对齐":["23.1"],"居中对齐":["23.1"],"baseline":["23.1"],"项目的第一行文字的基线对齐":["23.1"],"stretch":["23.1"],"默认值":["23.1"],"如果项目未设置高度或者设置为":["23.1"],"占满整个容器的高度":["23.1"],"定义项目缩小比例":["23.2"],"如果空间不足":["23.2"],"项目缩小":["23.2"],"才能识别":["24.0"],"标签作为":["24.0"],"元素":["24.0","26.0"],"不存在兼容性问题":["24.0"],"来分隔它们":["25.0"],"也可以为":["25.0"],"父元素设置一个高度":["25.0"],"max":["25.0"],"min":["25.0"],"body":["26.0"],"视口的宽":["27.0"],"适用场景":["28.0"],"通常用于创建图像和图表":["28.0"],"可以用":["29.0"],"position":["30.0"],"relative":["30.0","39.0"],"absolute":["30.0"],"不会生成新的元素":["31.0"],"伪元素":["31.0"],"如果该元素绑定了事件会触发":["32.0"],"重绘":["32.0"],"content":["32.0"],"移出文档流":["32.0"],"但是再次显示时消耗性能低":["32.0"],"固定宽高时设置":["33.0"],"接口预加载":["34.0"],"在":["35.0"],"的":["35.0","73.8","91.11","92.21"],"中使用":["35.0"],"这样可以确保每帧动画能够在显示器刷新之前完成":["36.0"],"如果时间间隔小于":["36.0"],"指定要显示的行数":["37.0"],"元素设为":["39.0"],"因此就造就了高度塌陷的问题":["40.0"],"block":["40.1"],"visibility":["40.1"],"hidden":["40.1"],"把任意三边隐藏掉":["41.0"],"默认为":["42.0"],"标准盒子模型":["42.0"],"li":["43.0"],"子元素重新设置字体大小和行高":["43.1"],"原理是":["43.1"],"中字体继承的特性和文字基线对齐":["43.1"],"相邻后代选择器":["44.0"],"伪元素选择器":["44.1"],"后者指向":["45.0"],"window":["45.0","63.2","78.0"],"第三个参数涉及到冒泡和捕获":["45.0"],"是":["45.0"],"事件触发之前执行":["46.0"],"这确保了脚本的执行在整个文档结构构建完成之后":["46.0"],"使用场景":["46.0","92.2","92.10"],"如果页面中有多个带有":["46.0"],"添加":["47.0"],"webworker":["48.0"],"webscoket":["48.0"],"协议":["48.0","69.1"],"新增":["48.0"],"实现代码复用":["49.0"],"input":["50.0","92.20"],"type":["50.0","90.2"],"用于告诉浏览器在页面加载时立即开始加载指定的资源":["51.0"],"与":["51.0"],"用于定义超链接和外部样式表":["52.0"],"不会立即请求资源":["52.0"],"而是将链接添加到文档的超链接列表中":["52.0"],"当用户点击链接时":["52.0"],"才会根据":["52.0"],"hello":["53.1"],"from":["53.1"],"tab":["53.1"],"处理连接关闭":["53.1"],"标签页2":["53.2"],"button":["53.3"],"标签来确定上下文和各个关键字的权重":["54.1"],"一个语义化的文档对爬虫来说是友好的":["54.1"],"是有利于爬虫对文档内容解读的":["54.1"],"从而有利于网站的":["54.1"],"seo":["54.1"],"表示一组媒体内容":["54.2"],"一般包括图像":["54.2"],"图表":["54.2"],"实现了更接近传统面向对象编程的方式":["56.0"],"同时":["56.0"],"还提供了模块化的支持":["56.0"],"import":["56.0","88.9","97.1"],"export":["56.0"],"语法导入和导出模块":["56.0"],"完成后进行":["57.0"],"即":["57.0","69.3"],"渲染更新":["57.0"],"先宏任务":["57.0"],"再微任务":["57.0"],"然后再渲染更新":["57.0"],"宏任务队列中":["57.0"],"如果有大量任务等待执行时":["57.0"],"将":["57.0","91.11"],"dom的变动作为微任务":["57.0"],"能更快的将变化呈现给用户":["57.0"],"这样就可以在这一次的事件轮询中更新":["57.0"],"domevent":["57.0"],"是window调用的foo函数":["58.0"],"所以foo中的this指向window":["58.0"],"obj2":["58.0"],"foo1":["58.0"],"foo2":["58.0"],"settimeout":["58.0","109.0"],"preventdefault":["59.0","59.1"],"方法来阻止":["59.0"],"true":["59.1","65.0","117.0","121.1"],"来实现阻止事件进一步传播":["59.1"],"e":["59.1"],"可以阻止事件的默认行为发生":["59.1"],"默认行为是指":["59.1"],"点击":["59.1"],"a":["59.1"],"标签就转跳到其他页面":["59.1"],"let":["60.3"],"用来定义常量":["60.4"],"声明时必须赋值":["60.4"],"也就是全局对象":["60.5"],"j":["60.6"],"timer":["60.6"],"fn":["60.6","112.0"],"null":["61.1","65.0","80.5","88.4","108.0"],"是一个对象指向一个函数":["61.3"],"这个函数就是这个对象的构造函数":["61.3"],"构造函数":["61.3"],"构造函数本身":["61.3"],"在内存中失去引用时":["62.1"],"垃圾回收机制会根据特殊的算法找到它":["62.1"],"并将原来标记为可到达对象的标识清除":["62.2"],"以便进行下一次垃圾回收操作":["62.2"],"因为它们对于值的引用不计入垃圾回收机制":["62.4"],"作用域链":["63.0"],"运行在":["63.1"],"函数中的代码":["63.1"],"对象":["63.2","90.1"],"当该函数执行结束":["63.3"],"执行上下文从栈中弹出":["63.3"],"执行阶段":["63.4"],"对变量进行赋值":["63.4"],"指向全局对象":["63.5"],"全局变量会作为该对象的属性来被查询":["63.5"],"在运行过程中需要检查数据类型的语言":["64.0"],"静态语言":["64.0"],"function":["64.1","64.15","112.0"],"数组":["64.1"],"array":["64.1"],"所以可能添加相同的键名":["64.2"],"就会出现冲突的问题":["64.2"],"in":["64.3"],"object":["64.3","113.0"],"n":["64.4","91.14"],"或者使用":["64.4"],"未定义的值":["64.5"],"语义是表示一个变量最原始的状态":["64.5"],"而不是人为操作的结果":["64.5"],"声明一个变量":["64.5"],"但是没有赋值":["64.5"],"为了性能考虑使用低位存储变量的类型信息":["64.6"],"000":["64.6"],"开头代表对象":["64.6"],"可以容纳各种大小的数据":["64.7"],"对于复制操作":["64.7"],"可以判断引用类型":["64.8"],"检测当前实例是否是属于这个类的":["64.8"],"底层机制":["64.8"],"只要当前类出现在实例的原型上":["64.8"],"结果都是":["64.8"],"key":["64.10"],"return":["64.10","102.0"],"位的有效数字":["64.11"],"超过这个长度的位数会被截取掉这样就造成了精度丢失的问题":["64.11"],"解决":["64.11","70.2"],"将其转换为整数之后再进行运算":["64.11"],"会首先判断传入参数是否为数字":["64.12"],"如果是数字再继续判断是否为":["64.12"],"处理了一些特殊的情况":["64.13"],"比如":["64.13"],"再转换成数字为":["64.14"],"this":["64.15","89.3","92.4"],"基数为":["64.16"],"表示的数中":["64.16"],"最大值小于":["64.16"],"类似集合":["64.17"],"方法很多":["64.17"],"可以跟各种数据格式转换":["64.17"],"接受对象作为健名":["64.17"],"index":["65.0"],"xml":["65.0"],"发送请求":["65.0"],"send":["65.0"],"严谨写法":["65.0"],"可以用于浏览器和":["65.1"],"node":["65.1"],"js":["65.1","79.3","92.5","92.16"],"环境中发出":["65.1"],"http":["65.1","75.0","77.0","80.12","81.0"],"节点加上节点之间的智能冗余":["66.0"],"机制":["66.0"],"可以有效地预防黑客":["66.0"],"入侵以及降低各种":["66.0"],"d":["66.0"],"o":["66.0"],"s":["66.0"],"攻击对网站的影响":["66.0"],"name":["67.0"],"server":["67.0"],"服务器":["67.0"],"通常情况下就是你注册的域名服务器":["67.0"],"服务器上的数据都是安全的":["68.0"],"每次的结果都是相同的":["68.0"],"浏览器会对":["68.0"],"的握手过程":["69.0"],"才可以进行密文传输":["69.0"],"ssl":["69.1"],"tsl":["69.1"],"获取客户端发来的随机数":["69.3"],"第五步":["69.3"],"二来公钥里并没有包含服务器的信息":["69.4"],"也就是并不能确保服务器身份的合法性":["69.4"],"并且非对称加密的时候要消耗一定的时间":["69.4"],"减低了数据的传输效率":["69.4","84.2"],"混合加密机制的好处是什么":["69.4"],"对称密钥加密和非对称密钥加密都有它们各种的优缺点":["69.4"],"而混合加密机制就是将两者结合利用它们各自的优点来进行加密传输":["69.4"],"比如既然对称密钥的优点是加解密效率快":["69.4"],"那么在客户端与服务端确定了连接之后就可以用它来进行加密传输":["69.4"],"返回前端":["69.5"],"前端每次":["69.5"],"灵活和易于扩展":["70.1"],"协议中的各类请求方法":["70.1"],"cookie":["70.2"],"连接中":["70.3"],"客户端发起多个请求":["70.3"],"发出了第一个请求之后":["70.3"],"不用等待返回结果":["70.3"],"可以发第二个请求":["70.3"],"只获取当前用户能看到的页面资源":["70.4"],"当用户向下滑动页面的时候":["70.4"],"再去请求服务器获取相应的资源":["70.4"],"达到延迟发送请求的效果":["70.4"],"一般来说":["70.4"],"的响应数据要比请求大":["70.4"],"所以可以考虑对响应的资源进行压缩":["70.4"],"减少响应的数据大小":["70.4"],"提高网络传输的效率":["70.4"],"无损压缩":["70.4"],"无损压缩是指源码经过压缩后":["70.4"],"信息不被破坏":["70.4"],"还能恢复到压缩前的模样":["70.4"],"适合用在文本文件":["70.4"],"程序可执行文件":["70.4"],"程序源代码":["70.4"],"一般情况下":["70.4"],"中的请求或响应":["70.6"],"由":["70.6"],"头部和包体构成":["70.6"],"里包含一条或者多个":["70.6"],"frame":["70.6"],"最小单位":["70.6"],"以二进制压缩格式存放":["70.6"],"中的内容":["70.6"],"头部和包体":["70.6"],"多个":["70.6"],"跑在一条":["70.6"],"同一个":["70.6"],"请求与响应是跑在同一个":["70.6"],"消息可以由多个":["70.6"],"用于服务器回应时":["71.0"],"告诉客户端":["71.0"],"即可通过单点登录系统":["72.0"],"etruesso":["72.0"],"访问后台的多个":["72.0"],"应用系统":["72.0"],"二次登陆时无需重新输入用户名和密码":["72.0"],"基于角色访问控制":["72.0"],"根据用户的角色和":["72.0"],"url":["72.0","92.21"],"就需要网络进行通信":["73.0"],"但是设备是多样性的":["73.0"],"保证一个报文一定能到达接收端":["73.1"],"如果直接传输就很不好控制":["73.2"],"所有当传输的数据包大于":["73.2"],"最大报文长度的时候":["73.2"],"就要将数据包分块":["73.2"],"这样的好处就是如果传输过程中有一个丢失或者损坏":["73.2"],"只需要重新发送丢失的分块即可":["73.2"],"不需要重新发送整个数据包":["73.2"],"传输层的报文中会携带端口号":["73.2"],"接收方根据这个端口号来判断这个报文要传输给那个应用":["73.2"],"时":["73.3","91.6"],"确认应答的字段变为有效":["73.3"],"需要":["73.4"],"这个报文也不包含应用层数据":["73.5"],"客户端收到服务端的报文后":["73.5"],"向服务端回应最后一个应答报文":["73.5"],"首先将应答报文":["73.5"],"首部":["73.5"],"标志位置为":["73.5"],"time":["73.6"],"需要过一阵子以确保服务端收到自己的":["73.6"],"报文之后才会进入":["73.6"],"closed":["73.6"],"是服务器在上一次对话中发送给客户的":["73.7"],"这个":["73.7"],"支持":["73.8","89.4","90.4"],"partial":["74.1"],"说明请求的资源还在":["74.2"],"但是暂时需要用另一个url来访问":["74.2"],"not":["74.3"],"表示服务器自身工作正常":["74.4"],"访问后端服务器发生了错误":["74.4"],"请求":["75.0","80.11"],"会在正式通信之前":["75.0"],"增加一次":["75.0"],"它的优点是":["76.0"],"明显减少了很多不必要的":["76.0"],"请求次数":["76.0"],"相比之下节约了资源":["76.0"],"长轮询的缺点在于":["76.0"],"连接挂起也会导致资源的浪费":["76.0"],"websocket":["76.0"],"push":["77.0","107.0"],"maxgae":["77.1"],"优先级高于":["77.1"],"如果":["77.1","92.1"],"maxage":["77.1"],"未过期":["77.1"],"向代理服务器请求缓存内容":["77.1"],"只在代理服务器中生效":["77.1"],"客户端只考虑":["77.1"],"public":["77.1","92.25"],"private":["77.1"],"如果为资源设置了":["77.1"],"那么它既可以被浏览器缓存":["77.1"],"所以使用":["77.2"],"可能会有一个":["77.2"],"bug":["77.2"],"那就是服务器并没有正确感知文件的变化":["77.2"],"为了解决这个问题":["77.2"],"etag":["77.2"],"出现了":["77.2"],"是由服务器为每个资源生成的唯一的标识字符串":["77.2"],"这个标识字符串是基于文件内容编码的":["77.2"],"只要文件内容不同":["77.2"],"对应的":["77.2"],"所以无法直接访问":["77.3"],"可以帮我们实现离线缓存":["77.3"],"消息推送和网络代理等功能":["77.3"],"借助":["77.3"],"实现的离线缓存就是":["77.3"],"生命周期包括":["77.3"],"最大只能有":["77.5"],"4kb":["77.5"],"所以只能存少量的信息":["77.5"],"过量的":["77.5"],"存储容量大":["77.7"],"可以达到":["77.7"],"无法解决的程度":["77.8"],"发现自己没有这个资源":["77.9"],"一般是缓存的数据过期了":["77.9"],"转头向根服务器去要这个资源":["77.9"],"viewheight":["78.0"],"innerheight":["78.0"],"document":["78.0"],"无论调用多少次":["78.1"],"服务端渲染也可以解决首屏加载速度过慢":["79.0"],"除了加载":["79.0"],"还要等渲染所需的这部分":["79.0"],"创建的是":["79.1"],"的解析过程是并行的":["79.1"],"渲染树":["79.1"],"等":["79.2","89.2","89.8"],"引擎运行完毕":["79.2"],"浏览器会把控制器交还给渲染引擎":["79.2"],"继续":["79.2"],"和":["79.2"],"的构建":["79.2"],"通过":["79.2"],"有人":["79.2"],"回流一定会导致重绘":["79.3"],"如何避免":["79.3"],"将一些属性使用":["79.3"],"变量缓存起来":["79.3"],"计算完毕再提交给浏览器发出重计算请求":["79.3"],"连接上进行优化":["80.0"],"在webpack":["80.3"],"js中对dll做配置":["80.3"],"帮我们把任务分解给多个子进程去并发执行":["80.4"],"大大提升打包效率":["80.4"],"使用方法":["80.4"],"getcomponent":["80.5"],"location":["80.5"],"cb":["80.5","96.2"],"ensure":["80.5"],"pages":["80.5"],"所以可以理解为以服务器压缩的时间开销和":["80.6"],"开销为代价":["80.6"],"省下了一些传输过程中的时间开销":["80.6"],"但是我们都知道服务器的":["80.6"],"黑":["80.7"],"白":["80.7"],"图":["80.8"],"呈现大图":["80.8"],"既可以保证图片的质量":["80.8"],"但是在日常开发中":["80.9"],"我们为了避免文件体积过大":["80.9"],"一般不使用":["80.9"],"html":["80.10"],"里成为":["80.10"],"的一部分":["80.10"],"也可以把对图形的描述写入以":["80.10"],"无法弥补这庞大的体积带来的性能开销":["80.11"],"只有在传输非常小的图片的时候":["80.11"],"带来的文件体积膨胀":["80.11"],"以及浏览器解析":["80.11"],"jgp":["80.12"],"还有就是让后端去根据":["80.12"],"头部的":["80.12"],"accept":["80.12"],"字段来决定返回什么格式的图片":["80.12"],"验证":["81.0"],"永远不要使用管理员权限的数据库连接":["82.0"],"为每个应用使用单独的权限有限的数据库连接":["82.0"],"不要把机密信息明文存放":["82.0"],"请加密或者":["82.0"],"而不是用户原本以为的信任站点":["83.0"],"防护原理":["83.0"],"对用户输入进行合适的转义和过滤":["83.0"],"使用安全的模板引擎或自动转义函数":["83.0"],"tls":["84.0"],"可以将数据用公钥加密":["84.1"],"就算是第三方截取了这个数据但是没有对应的私钥也解密不了":["84.2"],"缺点是非对称加密的时候要消耗一定的时间":["84.2"],"对传输数据进行对称加密":["84.3"],"服务端拿私钥解密随机码":["84.3"],"中间人攻击中":["84.4"],"中间人首先伪装成服务端和客户端进行通信":["84.4"],"然后又伪装成客户端和服务端进行通信":["84.4"],"可以阻止自动化程序大规模注册账号":["86.0"],"如果当前监控的值是数组类型":["87.0"],"会对对象中的每一项进行求值":["87.0"],"此时会将当前":["87.0"],"这样会带来性能问题":["87.1"],"优化的话可以使用字符串形式监听":["87.1"],"如果没有写到组件中":["87.1"],"不要忘记使用":["87.1"],"unwatch":["87.1"],"转化":["87.2"],"依赖收集":["87.2"],"因此引入":["87.3"],"能够很好地解决监听对象的问题":["87.3"],"的实例":["88.1"],"想要导航到不同":["88.1"],"对象的":["88.2"],"安装":["88.3"],"可以对浏览器历史记录栈进行修改":["88.4"],"以及":["88.4"],"popstate":["88.4"],"事件的监听到状态变更":["88.4"],"path":["88.4"],"程序员poetry":["88.4"],"代码已经复制到剪贴板":["88.4"],"这两个方法有个共同的特点":["88.4"],"可以显示具名组件":["88.5"],"起到更强的布局作用":["88.5"],"组件内部根据":["88.5"],"属性判断如何渲染最终生成节点":["88.5"],"前进":["88.6"],"go":["88.6"],"前进或者后退几步":["88.6"],"event":["88.7"],"创建这两个事件":["88.7"],"我们还可以为路由组件添加守卫配置":["88.8"],"beforerouteenter":["88.8"],"会在渲染该组件的对应路由被验证前调用":["88.8"],"views":["88.9"],"userdetails":["88.9"],"结合注释":["88.9"],"插件":["88.10","90.5"],"即实现":["88.10"],"install":["88.10","92.19"],"方法":["88.10","92.2","92.19"],"内部做两件事":["88.10"],"实现两个全局组件":["88.10"],"针对整个对象":["89.0"],"而不是对象的某个属性":["89.0"],"所以也就不需要对":["89.0"],"keys":["89.0","113.0"],"通常用于处理单值的响应式问题":["89.1"],"底层采用的是":["89.1"],"相对更简单":["89.2"],"没有额外的选项":["89.2"],"中见不到":["89.3"],"的使用":["89.3"],"ts":["89.4"],"umounted":["89.5"],"需要保证":["89.6"],"的顺序一致":["89.6"],"优化":["89.7"],"更小":["89.7"],"更好的摇树优化":["89.7"],"tree":["89.7","118.0"],"shaking":["89.7"],"移除一些不常用的":["89.7"],"更友好":["89.7"],"对不参与更新的元素":["89.8"],"会做静态提升":["89.8"],"只会被创建一次":["89.8"],"之后会在每次渲染时候被不停的复用":["89.8"],"可以有效跳过大量":["89.8"],"其他情况都要":["89.9"],"初衷":["89.9"],"不丢失响应式的情况下":["89.9"],"若使用":["89.10"],"options":["89.10"],"的回调函数接收参数是":["90.1"],"state":["90.1"],"则是与":["90.1"],"实例具有相同方法和属性的上下文":["90.1"],"context":["90.1"],"因此一般会解构它为":["90.1"],"是否是期待的那个":["90.2"],"从而进一步做后续处理":["90.2"],"方式简单好用":["90.2"],"且能获取变化前后值":["90.2"],"subscribe":["90.3"],"方法做一个统一的处理":["90.3"],"甚至可以封装一个":["90.3"],"插件以便复用":["90.3"],"直接抛弃它了":["90.4"],"这无疑减少了我们工作量":["90.4"],"支持同步和异步":["90.4"],"不支持":["90.4"],"良好的":["90.4"],"typescript":["90.4"],"毕竟我们":["90.4"],"为响应式对象":["90.5"],"同时将":["90.5"],"定义为一个":["90.5"],"vue":["90.5"],"getter":["91.0"],"语法树转化成":["91.1"],"funtion":["91.1"],"字符串的过程":["91.1"],"函数":["91.1","91.7","91.8"],"同样更新":["91.3"],"虚拟":["91.3"],"不会立即操作":["91.3"],"通过原型链":["91.4"],"函数劫持的方式实现的":["91.4"],"depend":["91.5"],"当属性发生修改时会触发":["91.5"],"每个列表项的":["91.6"],"在变更前后是一样的":["91.6"],"都是直接判断为":["91.6"],"samenode":["91.6"],"然后复用":["91.6"],"最终拿到":["91.7"],"内部挂载的时候会产生一个":["91.7"],"watcher":["91.7"],"会调用":["91.7"],"算法才能精确找到发生变化的地方并高效更新":["91.8"],"中":["91.8"],"执行的时刻是组件内响应式数据变更触发实例执行其更新函数时":["91.8"],"更新函数会再次执行":["91.8"],"render":["91.8"],"函数获得最新的虚拟":["91.8"],"然后执行":["91.8"],"并传入新旧两次虚拟":["91.8"],"通过比对两者找到变化的地方":["91.8"],"最后将其转化为对应的":["91.8"],"完全不用接触繁琐的":["91.9"],"操作":["91.9"],"从而大大提升开发效率":["91.9"],"降低开发难度":["91.9"],"中的数据响应式会根据数据类型来做不同处理":["91.9"],"如果是":["91.9","116.2"],"对象则采用":["91.9"],"的方式定义数据拦截":["91.9"],"当数据被访问或发生变化时":["91.9"],"我们感知并作出响应":["91.9"],"如果是数组则通过覆盖数组对象原型的":["91.9"],"个变更方法":["91.9"],"使这些方法可以额外的做更新通知":["91.9"],"这会首次执行组件渲染函数并执行":["91.10"],"patch":["91.10"],"将前面获得":["91.10"],"update":["91.11"],"所以我们只需要在传入的回调函数中访问最新":["91.12"],"状态即可":["91.12"],"或者我们可以":["91.12"],"await":["91.12"],"方法返回的":["91.12"],"之后做这件事":["91.12"],"本质上不过是语法糖":["91.13"],"可以看成是":["91.13"],"value":["91.13","92.20","120.0"],"采用虚拟":["92.0"],"是对象的话":["92.1"],"对象属于引用类型":["92.1"],"性能消耗":["92.2"],"有更高的切换消耗":["92.2"],"有更高的初始渲染消耗":["92.2"],"里加":["92.5"],"如果被其它地方复用":["92.6"],"就放在":["92.6"],"前后端职责分离":["92.7"],"架构清晰":["92.7"],"服务器压力小":["92.7"],"初次加载耗时多":["92.7"],"ui":["92.8"],"框架按需加载":["92.8"],"图片资源压缩":["92.8"],"activated":["92.9"],"deactivated":["92.9"],"当组件被激活时":["92.9"],"触发钩子函数":["92.9"],"函数返回的对象":["92.10"],"的产生而浪费内存":["92.11"],"如果粒度过低也无法精准检测变化":["92.11"],"所以采用":["92.11"],"这些选项将以恰当的方式进行":["92.12"],"合并":["92.12"],"如果混入的数据和本身组件的数据冲突":["92.12"],"我们可以把":["92.13"],"称为数据层":["92.13"],"因为它仅仅关注数据本身":["92.13"],"不关心任何行为":["92.13"],"用户操作界面":["92.13"],"当":["92.13"],"就创建一个":["92.14"],"节点":["92.14","93.0","97.1"],"把多个根节点作为它的":["92.14"],"children":["92.14"],"attrs":["92.15"],"里面":["92.15"],"并自动挂载到组件根元素上面":["92.15"],"可以通过":["92.15"],"inheritattrs":["92.15"],"属性禁止":["92.15"],"由于函数式组件不需要实例化":["92.15"],"跨级组件间建立了一种主动提供与依赖注入的关系":["92.16"],"root":["92.16"],"访问根组件中的属性或方法":["92.16"],"是根组件":["92.16"],"不是父组件":["92.16"],"只对根组件有用":["92.16"],"vuex":["92.16"],"是一个专为":["92.16"],"应用程序开发的状态管理模式":["92.16"],"每一个":["92.16","92.19"],"插槽主要用于":["92.17"],"组件中的内容分发":["92.17"],"并将这个":["92.18"],"用作其初始值":["92.18"],"以一种原始的值传入且需要进行转换":["92.18"],"单文件的这种格式":["92.19"],"文件我们都可以看成是一个组件":["92.19"],"use":["92.19"],"插件的实现应该暴露一个":["92.19"],"这个方法的第一个参数是":["92.19"],"构造器":["92.19"],"第二个参数是一个可选的选项对象":["92.19"],"注册形式":["92.19"],"组件注册主要分为":["92.19"],"加载相应组件":["92.21"],"获取和解析异步数据":["92.21"],"创建一个读取":["92.21"],"bundlerenderer":["92.21"],"然后生成":["92.21"],"发送给客户端":["92.21"],"客户端混合":["92.21"],"客户端收到从服务端传来的":["92.21"],"与自己的生成的":["92.21"],"进行对比":["92.21"],"把不相同的":["92.21"],"使其可以能够响应后续变化":["92.21"],"这个过程称为客户端激活":["92.21"],"为确保混合成功":["92.21"],"客户端与服务器端需要共享同一套数据":["92.21"],"在服务端":["92.21"],"可以在渲染之前获取数据":["92.21"],"填充到":["92.21"],"msg":["92.23"],"调用子组件中的方法":["92.23"],"我们的":["92.24"],"还可以单独作用当前组件":["92.24"],"打包时":["92.24"],"vscode":["92.25"],"用来放项目中的":["92.25"],"配置":["92.25"],"plugins":["92.25"],"用来放":["92.25"],"插件的":["92.25"],"plugin":["92.25"],"用来放一些诸如":["92.25"],"页头":["92.25"],"icon":["92.25"],"真实":["93.0"],"已经挂载完毕":["93.0"],"数据完成双向绑定":["93.0"],"可以访问到":["93.0"],"refs":["93.0"],"属性对":["93.0"],"进行操作":["93.0"],"也可以向后台发送请求":["93.0"],"拿到返回数据":["93.0"],"更新之前发生":["93.0"],"也就是响应式数据发生更新":["93.0"],"如果在":["93.1"],"中使用了第三方库":["93.1"],"父组件更新过程":["93.2"],"如果需要等待":["93.3"],"进行遍历":["94.0"],"插件转化成新的":["94.0"],"处理转换成":["95.0"],"innerhtml":["95.1"],"head":["95.1"],"从下到上":["95.2"],"utf":["95.3"],"把文件输出到一个文件夹中":["95.3"],"在代码中通过相对":["95.3"],"去引用输出的文件":["95.3"],"image":["95.3"],"插件只需要监听它所关系的事件":["96.1"],"console":["96.2"],"log":["96.2"],"将es6语法转化成es5":["97.0"],"因为现在我们引入文件都是通过":["97.1"],"的方式引入":["97.1"],"所以找到了":["97.1"],"就找到了文件的依赖关系":["97.1"],"会生出不同的":["98.0"],"contenthash":["98.0"],"好处":["99.0"],"值会编译新生成的文件标识":["99.1"],"被作为下次热更新的标识":["99.1"],"监听文件变化":["99.1"],"主要是通过文件的生成时间判断是否有变化":["99.1"],"status":["100.0"],"this指向的是new出来的对象":["101.0"],"判断new出来的对象是否为fn的实例":["101.0"],"thisf":["101.0"],"传入的所有参数都必须为函数":["102.0"],"prototype":["103.0"],"if":["104.0","111.0","116.1","118.0"],"unshift":["104.0"],"放到任务队列顶部":["104.0"],"else":["104.0"],"删除旧的数据":["105.0"],"apply":["106.0"],"如果构造函数显示返回了一个对象":["106.0"],"将then传入的回调函数":["107.0"],"注册到resolvetask中":["107.0"],"重点":["107.0"],"判断resolvecallback事件的返回值":["107.0"],"假如用户注册的resolvecallback事件又返回一个promise":["107.0"],"将resolve和reject传进去":["107.0"],"这样就实现控制了链式调用的顺序":["107.0"],"const":["107.0"],"res":["107.0"],"catch":["107.2"],"err":["107.2"],"接口失败后":["107.2"],"判断剩余次数不为0时":["107.2"],"继续重发":["107.2"],"timeout":["108.0"],"moreargs":["110.0"],"定义一个内部函数fn":["112.0"],"会在触发时执行回调函数并取消订阅":["112.0"],"执行回调函数":["112.0"],"createelement":["113.0"],"遍历属性":["113.0"],"while":["114.0","115.0","116.4"],"next":["114.0","115.0"],"区别在这里":["116.0"],"我们加了一个标志位":["116.0"],"flag":["116.0"],"false":["116.0"],"处的数据项比当前最小值还要小":["116.1"],"则更新最小值索引为":["116.1"],"则将":["116.2"],"前面的一个元素后移一位":["116.2"],"为":["116.2"],"让出位置":["116.2"],"初始化左边界的索引":["116.3"],"leftindex":["116.3"],"lef":["116.3"],"遍历从左边界到右边界之前的元素":["116.3"],"for":["116.3"],"i":["116.3"],"如果当前元素小于枢轴元素":["116.3"],"缓存arr2的长度":["116.4"],"len2":["116.4"],"合并两个子数组":["116.4"],"方法4":["117.0"],"dfs":["118.0"],"foreach":["118.0"],"item":["118.0"],"call":["119.0"],"func":["120.0"],"转换成时间戳":["121.0"],"单位毫秒":["121.0"],"now":["121.0"],"new":["121.0"],"date":["121.0"],"将当前时间和上一次执行函数的时间进行对比":["121.0"],"表示第一次触发后执行":["121.1"],"为空表示首次触发":["121.1"]},{"0":["30.0","40.1","64.13","107.2"],"1":["6.22"],"3":["90.1","92.18","94.0"],"4":["38.0","61.3","63.2","63.3","64.9","91.8","92.17","92.24","99.1"],"5":["19.0","30.0","32.0","33.0","39.0","97.0","97.1"],"6":["32.0"],"7":["84.3"],"10":["56.0"],"20":["73.8"],"80":["69.0"],"100":["70.6"],"304":["100.0"],"443":["69.0"],"503":["74.4"],"同一页面在不同分辨率上看起来应该合理":["5.0"],"同一页面在不同操作方式下":["5.0"],"体验应该是统一的":["5.0"],"边框":["5.1"],"适用于容器":["5.1"],"翻转内容":["5.1"],"scale3d":["5.1"],"对内容进行翻转":["5.1"],"适用于内容翻转":["5.1"],"letter":["5.1"],"spacing":["5.1"],"排版倒序文本":["5.1"],"parent":["6.2"],"100px":["6.3","6.14"],"块级元素改为":["6.4"],"或":["6.5"],"是相对于自身尺寸的":["6.5"],"组合使用达到水平居中的目的":["6.5"],"优点":["6.5"],"使用":["6.5","39.0","64.11","83.0","88.1","91.6"],"pc":["6.6"],"端兼容性不好":["6.6"],"缺点":["6.8","62.2","72.0"],"只能用于单行行内内容":["6.8"],"只能用于行内内容":["6.9"],"需要知道高度和最终呈现多少行来计算出":["6.9"],"兼容性较好":["6.10"],"ie8":["6.10"],"items":["6.10","38.0"],"center":["6.10","38.0"],"self":["6.10"],"direction":["6.11"],"column":["6.11"],"justify":["6.11","38.0"],"block":["6.13"],"如果是块级元素需改为行内或行内块级才生效":["6.13"],"vertical":["6.13","37.0"],"auto":["6.14","22.0"],"如果是块级元素就添加这个":["6.14"],"transform":["6.15"],"translate":["6.15"],"left":["6.16","41.1"],"right":["6.16"],"0f0":["6.19","6.20","6.22","6.24"],"值大于等于":["6.21"],"left的宽度":["6.21"],"均分了父元素剩余空间":["6.22"],"hidden":["6.23"],"触发bfc":["6.23"],"间隔":["6.26"],"在此定义和":["6.26"],"的间隔":["6.26"],"200px":["6.27"],"eeff2b":["6.27"],"自定义事件立即发出":["9.0"],"click":["9.0"],"事件":["9.0"],"并把浏览器在":["9.0"],"替你挑选最近的一个具有缓存内容的节点为你提供资源":["10.0"],"因此可以减少加载时间":["10.0"],"对":["10.0"],"进行压缩":["10.0"],"可以用很多打包工具":["10.0"],"比如":["10.0","89.6"],"webpack":["10.0","80.6"],"gulp":["10.0"],"等":["10.0"],"也可以通过开启":["10.0"],"gzip":["10.0","70.4","92.8"],"压缩":["10.0","92.8"],"合理的使用缓存":["10.0"],"设置":["10.0"],"cache":["10.0"],"control":["10.0"],"expires":["10.0"],"实现网页的动态交互":["12.0"],"v8":["12.0"],"前进后退的历史状态":["13.0"],"更新":["13.0","91.5"],"页面":["13.0"],"渲染流程":["13.0"],"渲染进程将":["13.0"],"内容转换为能够读懂的":["13.0"],"dom":["13.0","24.0","91.10"],"树结构":["13.0"],"渲染引擎将":["13.0"],"css":["13.0","52.0","92.25"],"样式表转化为浏览器可以理解的":["13.0"],"stylesheets":["13.0"],"计算出":["13.0"],"都会导致整个进程奔溃":["14.1"],"线程之间共享进程中的数据":["14.1"],"当一个进程关闭后":["14.1"],"负责页面的网络资源加载":["14.2"],"插件进程":["14.2"],"负责插件的运行":["14.2"],"flex":["16.1","38.0"],"grid":["16.1"],"中的元素":["16.1"],"overflow":["16.1","40.1"],"它们的边界会被限制在":["16.2"],"的内部":["16.2"],"私有属性造成的":["17.1"],"color":["17.2"],"transparent":["17.2"],"firefox":["18.0"],"opera":["18.0"],"和":["18.0","88.10"],"ie":["18.0"],"弹性盒子布局":["19.0"],"使用缓存":["20.0"],"使用精灵图":["20.0"],"margin":["21.0","21.1","21.2"],"上下不生效":["21.0"],"padding":["21.1"],"定义在分配多余空间之前":["22.0"],"项目占据的主轴空间":["22.0"],"main":["22.0","80.3"],"size":["22.0","105.0"],"浏览器根据此属性计算主轴是否有多余空间":["22.0"],"默认值为":["22.0"],"项目原本大小":["22.0"],"项目默认沿主轴排列":["23.0"],"多根轴线的对齐方式":["23.1"],"如果只有一根轴线":["23.1"],"不起作用":["23.1"],"和交叉轴的起点对齐":["23.1"],"和交叉轴终点对齐":["23.1"],"和交叉轴的中点对齐":["23.1"],"可以通过":["24.0"],"js":["24.0","59.1","77.9","91.3"],"操作":["24.0","59.1"],"插入":["24.0"],"标签来改变样式":["24.0"],"也能解决这个问题":["25.0"],"当然将父元素设置为":["25.0"],"是最简单的方法":["25.0"],"第四种情况":["25.0"],"是没有内容的元素":["25.0"],"自身的":["25.0"],"即相对于浏览器窗口":["26.0"],"vw":["27.0"],"通常用于创建动画":["28.0"],"游戏和交互式图形":["28.0"],"如果需要创建可伸缩的图形或需要处理文本或样式的图形":["28.0"],"应该适用":["28.0"],"keyframes定义动画序列":["29.0"],"可以设置动画执行的次数":["29.0"],"父元素设置为绝对定位":["30.0"],"左边元素设置为":["30.0"],"右边元素设置为绝对定位":["30.0"],"左边定位为":["30.0"],"其余方向为":["30.0"],"用于创建一些不在文档树中的元素":["31.0"],"并为其添加样式":["31.0"],"z":["32.0"],"index":["32.0","80.3","117.0"],"负值":["32.0"],"将层级放到底部":["32.0"],"被覆盖":["32.0"],"相当于隐藏了":["32.0"],"为":["33.0","42.0"],"2height":["33.0"],"文本垂直居中设置":["33.0"],"接口合并":["34.0"],"link":["35.0","88.10"],"ref":["35.0"],"preload":["35.0"],"将样式提前预加载":["35.0"],"确保在页面渲染之前样式表已经下载完毕":["35.0"],"则会导致某些帧在显示器刷新之后才能呈现":["36.0"],"orient":["37.0"],"display":["38.0"],"content":["38.0","70.4","83.0"],"align":["38.0"],"解决高度塌陷的问题就叫做清除浮动":["40.0"],"bfc":["40.1"],"布局规则":["40.1"],"给父元素添加":["40.1"],"剩下的就是一个三角形":["41.0"],"盒子模型":["42.0"],"指定":["42.0"],"之间产生间隔":["43.0"],"字体是继承属性":["43.1"],"所以在默认情况下":["43.1"],"子元素的文本内容会根据父元素的字体大小来渲染":["43.1"],"如果父元素的字体大小不设置为":["43.1"],"兄弟选择器":["44.0"],"通配符选择器":["44.0"],"继承":["44.1"],"true":["45.0","64.8","103.0"],"时为捕获":["45.0"],"属性的脚本":["46.0"],"它们的执行顺序是不确定的":["46.0"],"因为它们可能在下载完成后立即执行":["46.0"],"而下载速度快慢不一":["46.0"],"导致顺序混乱":["46.0"],"download":["47.0"],"属性":["47.0","91.7"],"email":["48.0"],"number":["48.0"],"url":["48.0","70.1","88.1"],"等表单类型":["48.0"],"浏览器兼容问题":["49.0"],"搜索引擎的检索程序无法解读这种页面":["49.0"],"text":["50.0"],"id":["50.0","97.1"],"不同":["51.0"],"会在页面加载时立即下载资源":["51.0"],"而不是在后台异步加载":["51.0"],"属性的值请求相应的资源":["52.0"],"如果使用":["52.0"],"来引入":["52.0"],"文件":["52.0","95.3"],"会并行下载资源而且不会停止对当前文档的处理":["52.0"],"close":["53.1"],"window":["53.2","63.5","92.21"],"addeventlistener":["53.2"],"event":["53.2"],"console":["53.2"],"btn":["53.3"],"value":["53.3","113.0","117.0"],"提交":["53.3"],"从":["54.1"],"html5":["54.1","76.0"],"可以看出":["54.1"],"标准是倾向于以语义化的方式构建网页的":["54.1"],"比如新增了":["54.1"],"header":["54.1","69.5"],"footer":["54.1"],"视频等":["54.2"],"abbr":["54.2"],"缩写词":["54.2"],"address":["54.2"],"模块化":["56.0"],"引入了模块化的概念":["56.0"],"提供了更好的代码组织和模块复用的方式":["56.0"],"迭代器和生":["56.0"],"成器":["56.0"],"vue":["57.0","87.1","91.1"],"nexttick1":["57.0"],"nexttick":["57.0"],"的源码实现":["57.0"],"优先级判断":["57.0"],"总结就是":["57.0"],"这里优先使用":["57.0"],"因为根据":["57.0"],"与浏览器更新渲染时机":["57.0"],"对于settimeout中的函数":["58.0"],"存在隐式绑定的丢失":["58.0"],"也就是当讲函数作为参数传递的时候":["58.0"],"会被隐式赋值":["58.0"],"回调函数丢失this绑定":["58.0"],"所以settimeout中函数内的this指向window":["58.0"],"name":["58.0"],"通过设置事件对象的":["59.0"],"returnvalue":["59.0"],"拖拽一个图片到浏览器会自动打开":["59.1"],"点击表单的提交按钮会提交表单":["59.1"],"事件委托":["59.1"],"在":["59.1","69.5","77.3","91.12"],"中性能优化的一个主要思想就是减少":["59.1"],"const":["60.3"],"声明变量":["60.3","60.6"],"只能在块级作用域中访问":["60.4"],"不能修改":["60.4"],"这种由多个执行上下文的变量对象构成的链表就叫作用域链":["60.5"],"第三个参数":["60.6"],"将作为":["60.6"],"的参数":["60.6"],"let":["60.6"],"具有块级作用域":["60.6"],"而不是函数作用域":["60.6"],"在每次迭代的时候都会创建一个新的变量":["60.6"],"而不是共享一个全局变量":["60.6"],"当循环执行的时候":["60.6"],"这个查找的路线就是原型链":["61.1"],"一个对象的":["61.3"],"指向其构造函数的":["61.3"],"并将其回收":["62.1"],"释放内存":["62.1"],"垃圾收集后可能会造成大量的内存碎片":["62.2"],"this":["63.0","121.1"],"等信息":["63.0"],"对于每个执行上下文":["63.1"],"都有变量对象":["63.1"],"作用域链":["63.1"],"函数每调用一次就会产生一个新的执行上下文环境":["63.2"],"控制流程到达当前栈中的下一个上下文中":["63.3"],"一旦所有代码都执行完毕":["63.3"],"函数引用":["63.4"],"执行其它代码":["63.4"],"在浏览器中":["63.5"],"在使用之前就需要确认其变量数据类型的语言":["64.0"],"数学函数":["64.1"],"math":["64.1"],"正则对象":["64.1"],"regexp":["64.1"],"所以":["64.2","64.3","77.2","80.6"],"keys":["64.3"],"都是获取不到的":["64.3"],"构造函数来创建":["64.4"],"访问对象上不存在的属性或者没有定义的变量":["64.5"],"函数定义了形参":["64.5"],"但是调用的时候":["64.5"],"没有传递实参":["64.5"],"但是":["64.6"],"表示为全零":["64.6"],"原始类型的数据直接完整地复制变量值":["64.7"],"对象数据类型的数据则是复制引用地址":["64.7"],"基于原型链和构造函数":["64.8"],"但是不能检测基本数据类型":["64.8"],"prototype":["64.8"],"es5":["64.9"],"新增的":["64.9"],"isarray":["64.9"],"false":["64.10"],"json":["64.10","95.3"],"stringfy":["64.10"],"运算之后再转换为小数":["64.11"],"tofixed":["64.11"],"控制小数点后的位数":["64.11"],"不会进行数据类型的转换":["64.12"],"这种方法对于判断":["64.12"],"nan":["64.13"],"return":["64.15","95.1"],"无法解析":["64.16"],"返回":["64.16"],"null":["64.17","106.0"],"除外":["64.17"],"不接受其他类型的值作为健名":["64.17"],"健名所指向的对象":["64.17"],"不计入垃圾回收机制":["64.17"],"监听请求":["65.0"],"接受响应":["65.0"],"onreadysatechange":["65.0"],"function":["65.0"],"if":["65.0","88.2","106.0","107.1","107.2","121.0"],"readysate":["65.0"],"请求":["65.1"],"提供了更多的功能和选项":["65.1"],"同时保证较好的服务质量":["66.0"],"作用":["66.0"],"使用户就近获取所需内容":["66.0"],"降低网络拥塞":["66.0"],"提高用户访问响应速度和命中率":["66.0"],"原理":["66.0"],"最简单的":["66.0"],"网络由一个":["66.0"],"dns":["66.0"],"服务器和几台缓存服务器组成":["66.0"],"而工作的核心就是缓存服务器":["66.0"],"它记录了用户所需内容":["66.0"],"而且离用户较近":["66.0"],"服务器返回":["67.0"],"请求进行缓存":["68.0"],"请求会修改服务器上的资源":["68.0"],"是不安全的":["68.0"],"多次提交会创建多个资源":["68.0"],"默认端口":["69.0"],"将信息加密":["69.1"],"使得交易信息不能被获取":["69.1"],"通过校验机制":["69.1"],"客户端和服务端根据约定的加密方法":["69.3"],"使用前面的三个随机数":["69.3"],"生成":["69.3"],"对话密钥":["69.3"],"不过前提是得解决双方都能安全的拿到这把对称密钥":["69.4"],"这时候就可以里用非对称密钥加密来传输这把对称密钥":["69.4"],"因为我们知道非对称密钥加密的优点就是能保证传输的内容是安全的":["69.4"],"所以它的好处是即保证了对称密钥能在双方之间安全的传输":["69.4"],"又能使用对称加密方式进行通信":["69.4"],"这比单纯的使用非对称加密通信快了很多":["69.4"],"以此来解决了":["69.4"],"中内容可能被窃听的问题":["69.4"],"混合加密的缺点":["69.4"],"request":["69.5"],"uri":["70.1"],"状态码":["70.1"],"内容很容易被窃取":["70.2"],"但是服务器必须按照接收请求的顺序发送对这个管道化请求的响应":["70.3"],"如果服务端在处理":["70.3"],"a":["70.3"],"请求耗时比较长":["70.3"],"就会导致后续的请求的处理都会被堵塞":["70.3"],"这就是":["70.3"],"队头堵塞":["70.3"],"代码文件中会有很多换行符或空格":["70.4"],"目的是为了更好的可读性":["70.4"],"但是机器执行的时候不需要这些符合":["70.4"],"所以可以把这些多余的字符去除":["70.4"],"就是常见的无损压缩":["70.4"],"客户端也支持":["70.4"],"客户端会在请求中提高头部":["70.4"],"accept":["70.4"],"encoding":["70.4","71.0"],"字段告知服务器支持的压缩算法":["70.4"],"服务器从中选择一个服务器支持的合适的压缩算法":["70.4"],"使用这个算法对代码进行压缩":["70.4"],"通过响应头中的":["70.4"],"字段告诉客户端当前资源使用的压缩算法":["70.4"],"服务器应该选择压缩效率更高的":["70.4"],"br":["70.4"],"压缩算法":["70.4"],"有损压缩":["70.4"],"构成":["70.6"],"一个":["70.6"],"可以由多个":["70.6"],"报文构成":["70.6"],"当":["70.6","80.12","92.16"],"实现":["70.6"],"个并发":["70.6"],"时":["70.6","80.12"],"只需要建立一次":["70.6"],"而":["70.6","73.8","90.4"],"需要建立":["70.6"],"每个":["70.6"],"连接都要经过":["70.6"],"本次数据是什么格式":["71.0"],"实现访问控制功能":["72.0"],"集群":["72.0"],"通过集群功能":["72.0"],"实现多台服务器之间的动态负载均衡":["72.0"],"传输加密":["72.0"],"支持多种对称和非对称加密算法":["72.0"],"保证用户信息在传输过程中不被窃取和篡改":["72.0"],"为了兼容多种设备":["73.0"],"就协商出了一套通用的网络协议":["73.0"],"字节流":["73.1"],"网络层":["73.2"],"完成实际的传输功能":["73.2"],"最常使用的是":["73.2"],"协议":["73.2"],"层将传输层的报文作为数据部分":["73.2"],"加上":["73.2"],"包头组成":["73.2"],"表示希望建立连接":["73.3"],"fin":["73.3"],"来负责":["73.4"],"工作在传输层":["73.4"],"将服务端的":["73.5"],"作为确认应答号":["73.5"],"最后把报文发给服务端":["73.5"],"这次报文可以携带客户到服务端的数据":["73.5"],"之后客户端处于":["73.5"],"established":["73.5"],"报文之后":["73.6"],"就处于关闭连接了":["73.6"],"处于":["73.6"],"服务端在收到客户端断开连接":["73.6"],"报文后":["73.6"],"是加密的":["73.7"],"只有服务器能够解密":["73.7"],"里面包含了本次会话的信息":["73.7"],"比如对话秘钥和加密方法等":["73.7"],"这样不管我们的请求是否转移到其他的服务器上":["73.7"],"当服务器将":["73.7"],"对多":["73.8"],"的首部较大为":["73.8"],"字节":["73.8"],"只有":["73.8"],"用于http分块下载或断点续传":["74.1"],"表示响应返回的body数据不是资源的全部":["74.1"],"not":["74.2"],"modified":["74.2"],"表示资源未修改":["74.2"],"found":["74.3"],"请求的资源在服务器上找不到或不存在":["74.3"],"表示服务器当前很忙":["74.4"],"查询请求":["75.0"],"称为":["75.0"],"预检请求":["75.0"],"该请求的方法是":["75.0"],"是":["76.0"],"定义的一个新协议":["76.0"],"与传统的":["76.0"],"协议不同":["76.0"],"该协议允许由服务器主动的向客户端推送信息":["76.0"],"缓存分为强缓存和协商缓存":["77.0"],"强缓存的优先级高于协商缓存":["77.0"],"也可以被代理服务器缓存":["77.1"],"如果设置了":["77.1"],"则只能被浏览器缓存":["77.1"],"为默认值":["77.1"],"一般情况下":["77.1"],"不需要单独设置":["77.1"],"因为一般情况下会同时写":["77.1"],"这就表明是可以被浏览器和代理服务器缓存的":["77.1"],"no":["77.1"],"store":["77.1","92.16","92.21"],"就是不同的":["77.2"],"能精准的感知文件的变化":["77.2"],"当首次请求的时候":["77.2"],"会在响应头里获取到一个最初的标识字符串":["77.2"],"那么在下一次请求的时候":["77.2"],"请求头中就会带有一个值相同的":["77.2"],"名为":["77.2"],"none":["77.2"],"match":["77.2"],"的字符串供服务端比对了":["77.2"],"install":["77.3"],"active":["77.3"],"working":["77.3"],"一旦被":["77.3"],"将始终存在":["77.3"],"之间切换":["77.3"],"server":["77.3"],"会带来巨大的性能浪费":["77.5"],"同一个域名下的所有请求":["77.5"],"都会携带":["77.5"],"10m":["77.7"],"只位于浏览器端":["77.7"],"往往被用来存储静态资源":["77.9"],"就是":["77.9","116.2"],"documentelement":["78.0"],"clientheight":["78.0"],"另一个是元素距离可视区域顶部的高度":["78.0"],"getclientrects":["78.0"],"只执行最后一次":["78.1"],"加载完":["79.0"],"之后还需要把这部分":["79.0"],"代码在浏览器上跑一遍":["79.0"],"这一切发生在用户点击了链接之后发生的事":["79.0"],"在这个过程结束之前":["79.0"],"树和":["79.1"],"结合":["79.1"],"得到渲染树":["79.1"],"布局渲染树":["79.1"],"从根节点递归调用":["79.1"],"计算每一个元素的大小":["79.1"],"位置等":["79.1"],"默认会阻塞浏览器":["79.2"],"浏览器必须等待当前":["79.2"],"脚本执行完毕才会去继续做其它的事情":["79.2"],"async":["79.2"],"模式下":["79.2"],"不会阻塞浏览器做任何其它的事情":["79.2"],"加载是异步的":["79.2"],"当它加载结束":["79.2"],"脚本会立即执行":["79.2"],"不能保证脚本的执行顺序":["79.2"],"避免逐条改变样式":["79.3"],"使用类名去合并样式":["79.3"],"离线化":["79.3"],"先把元素":["79.3"],"优化有两个大方向":["80.0"],"减少请求次数和减少单次请求所花费的时间":["80.0"],"主要通过":["80.0"],"这样至少可以将":["80.2"],"的工作效率提升两倍":["80.2"],"当然":["80.2"],"mode":["80.3"],"production":["80.3"],"编译入口":["80.3"],"src":["80.3","92.25"],"目标文件":["80.3"],"只需要把":["80.4"],"laoder":["80.4"],"的配置转移到":["80.4"],"bugcomponent":["80.5"],"default":["80.5"],"bug":["80.5"],"route":["80.5"],"path":["80.5"],"核心就是":["80.5"],"的性能不是无限的":["80.6"],"如果存在大量的压缩需求":["80.6"],"服务器也是扛不住的":["80.6"],"如果服务器慢下来了":["80.6"],"用户还是要等":["80.6"],"如果一个图片格式对应的二进制位数有":["80.7"],"n":["80.7"],"个":["80.7"],"那么它就可以呈现":["80.7"],"文件体积也不会太大":["80.8"],"但是也存在一定的缺陷":["80.8"],"当处理矢量图形和":["80.8"],"logo":["80.8"],"等线条感较强":["80.8"],"去处理较复杂的图片":["80.9"],"所有会优先选择":["80.9"],"为后缀的独立文件":["80.10"],"使得":["80.10"],"文件可以被非常多的工具读取和修改":["80.10"],"的时间开销":["80.11"],"和节省掉的":["80.11"],"请求开销相比":["80.11"],"可以忽略不计":["80.11"],"此时才能体现出优势":["80.11"],"什么时候才会用":["80.11"],"满足以下条件":["80.11"],"字段包含":["80.12"],"image":["80.12"],"referer":["81.0"],"hash":["82.0"],"掉密码和敏感的信息":["82.0"],"防护原理":["82.0"],"使用参数化查询或预编译语句":["82.0"],"http":["83.0"],"头部中的":["83.0"],"ssl":["84.0"],"但是将数据解密必须使用私钥解密":["84.1"],"私有只有分发公钥的一方才知道":["84.1"],"因为公钥是公开的":["84.2"],"拥有对应公钥的黑客可以用这个公钥进行解密得到里面的信息":["84.2"],"公钥中没有包含服务器的信息":["84.2"],"对传输的数据进行对称加密":["84.3"],"把对称加密后的内容传递给客户端":["84.3"],"整个过程中":["84.4"],"由于缺少了证书的验证过程":["84.4"],"虽然使用了":["84.4"],"刷屏或在论坛上发布大量无意义的帖子":["86.0"],"watcher":["87.0"],"存入到对应属性的依赖中":["87.0"],"手动注销":["87.1"],"用于观察和监听页面上的":["87.1"],"实例":["87.1"],"用于依赖发生变化时":["87.2"],"触发属性重新计算":["87.2"],"若出现当前":["87.2"],"计算属性嵌套其他":["87.2"],"同时也会引入判断机制":["87.3"],"确保在多个属性更新时回调函数仅触发一次":["87.3"],"避免性能浪费":["87.3"],"params":["88.2"],"polypill":["88.3"],"插件解决":["88.3"],"当调用他们修改浏览器历史记录栈后":["88.4"],"虽然当前":["88.4"],"改变了":["88.4"],"但浏览器不会刷新页面":["88.4"],"这就为单页应用前端路由":["88.4"],"提供了基础":["88.4"],"路由模式的实现主要基于存在下面几个特性":["88.4"],"repalcestate":["88.4"],"两个":["88.4"],"api":["88.4","91.9","92.25"],"来操作实现":["88.4"],"的变化":["88.4"],"内部提供导航方法":["88.5"],"navigate":["88.5","88.8"],"用户点击之后实际调用的是该方法":["88.5"],"此方法最终会修改响应式的路由变量":["88.5"],"然后重新去":["88.5"],"routes":["88.5"],"匹配出数组结果":["88.5"],"从触发事件的监听上来说":["88.6"],"replacestate":["88.6"],"不能被":["88.6"],"并全局监听":["88.7"],"控制的范围更精确了":["88.8"],"用户的任何导航行为都会走":["88.8"],"方法":["88.8"],"内部有个":["88.8"],"webpackchunkname":["88.9"],"group":["88.9"],"user":["88.9"],"view":["88.10"],"分别实现页面跳转和内容显示":["88.10"],"进行遍历":["89.0"],"支持数组":["89.0"],"不需要对数组的方法进行重载":["89.0"],"object":["89.1"],"defineproperty":["89.1"],"的回调函数会接收新值和旧值作为参数":["89.2"],"可以根据需要进行比较和处理":["89.2"],"减少了":["89.3"],"指向不明的情况":["89.3"],"如果是小型组件":["89.3"],"可以继续使用":["89.3"],"更好的代码组织":["89.4"],"更好的逻辑抽离":["89.4"],"其他沿用":["89.5"],"不能放在循环":["89.6"],"判断":["89.6"],"里面":["89.6"],"在兼顾":["89.7"],"vue2":["89.7"],"的":["89.7"],"options":["89.7"],"的同时还推出了":["89.7"],"过程":["89.8"],"打包时更好的支持":["89.8"],"tree":["89.8"],"shaking":["89.8"],"把对象数据":["89.9"],"分解":["89.9"],"扩散":["89.9"],"前端":["89.9"],"针对的是响应式对象":["89.9"],"封装的":["89.9"],"非普通对象":["89.9"],"可以照常使用":["89.10"],"从而方便编码":["90.1"],"另外":["90.1"],"会返回":["90.1"],"promise":["90.1"],"实例便于处理内部异步结果":["90.1"],"实现上":["90.1"],"首选":["90.2"],"方法会被所有":["90.2"],"commit":["90.2","92.16"],"行为触发":["90.2"],"因此还需要判断":["90.2"],"类似的插件有":["90.3"],"persist":["90.3"],"persistedstate":["90.3"],"都推荐使用":["90.4"],"ts":["90.4"],"来编写":["90.4"],"这个时候使用":["90.4"],"就非常合适了":["90.4"],"无需再创建各个模块嵌套了":["90.4"],"中如果数据过多":["90.4"],"我们通常分模块来进行管理":["90.4"],"稍显麻烦":["90.4"],"方法中可以获取用户传入":["90.5"],"mutations":["90.5"],"并执行它":["90.5"],"这样可以按用户提供的方法修改状态":["90.5"],"在数据变动时发布消息给订阅者":["91.0"],"触发相应的监听回调":["91.0"],"的返回值是":["91.1"],"的虚拟":["91.1"],"而是将这":["91.3"],"次更新的":["91.3"],"diff":["91.3"],"内容保存到本地的一个":["91.3"],"对象中":["91.3"],"最终将这个":["91.3"],"缺陷是不能检索索引更改和数组长度的更改":["91.4"],"数组中的元素也会被再次观测":["91.4"],"比如有一个":["91.6"],"ul":["91.6"],"其中有三个":["91.6"],"li":["91.6"],"checkbox":["91.6"],"包裹":["91.6"],"当选择一个复选框时":["91.6"],"可以点击删除按钮将其删除":["91.6"],"如果不设置":["91.6"],"函数触发依赖收集":["91.7"],"内部还会给所有的响应式数据增加":["91.7"],"dep":["91.7"],"让属性记录当前的":["91.7"],"过程是一个递归过程":["91.8"],"遵循深度优先":["91.8"],"同层比较的策略":["91.8"],"以":["91.8"],"vue3":["91.8"],"为例":["91.8"],"首先判断两个节点是否为相同同类节点":["91.8"],"不同则删除重新创建":["91.8"],"如果双方都是文本则更新文本内容":["91.8"],"如果双方都是元素节点则递归更新子元素":["91.8"],"同时更新元素属性":["91.8"],"从而作出响应":["91.9"],"这种机制很好的解决了数据响应化的问题":["91.9"],"但在实际使用中也存在一些缺点":["91.9"],"比如初始化时的递归遍历会造成性能损失":["91.9"],"新增或删除属性时需要用户使用":["91.9"],"set":["91.9"],"delete":["91.9","118.0"],"这样特殊的":["91.9"],"才能生效":["91.9"],"对于":["91.9"],"es6":["91.9"],"中新产生的":["91.9"],"map":["91.9"],"这些数据结构不支持等问题":["91.9"],"为了解决这些问题":["91.9"],"vnode":["91.10"],"转换为":["91.10"],"去重之后放到队列中":["91.11"],"然后通过":["91.11"],"内部":["91.12"],"之所以能够让我们看到":["91.12"],"更新后的结果":["91.12"],"是因为我们传入的":["91.12"],"会被添加到队列刷新函数":["91.12"],"flushschedulerqueue":["91.12"],"方法的语法糖":["91.13"],"复杂度的问题":["91.14"],"只比较同级不考虑跨级问题":["91.14"],"比较新旧虚拟节点":["92.0"],"找到变化再进行更新":["92.0"],"会影响到所有的实例":["92.1"],"所以为了保证组件在不同的实例之间":["92.1"],"不冲突":["92.1"],"都能控制":["92.2"],"元素在页面的显示":["92.2"],"开销更大的":["92.2"],"直接操作":["92.2"],"执行的时候":["92.3"],"调用的变量还不存在":["92.3"],"就会导致异常":["92.3"],"如果一定要一起使用":["92.3"],"可以把":["92.3"],"domname":["92.4"],"来获取":["92.4"],"v":["92.5"],"cloak":["92.5"],"disply":["92.5"],"action":["92.6"],"前进后退路由难管理":["92.7"],"seo":["92.7"],"难度大":["92.7"],"怎么解决":["92.7"],"ssr":["92.7"],"开启":["92.8"],"当组件被移除时":["92.9"],"的中还运用了":["92.9"],"实现非父子组件通信":["92.10"],"算法":["92.11"],"组件级":["92.11"],"会以组件的数据为准":["92.12"],"有很多缺陷如":["92.12"],"命名冲突":["92.12"],"进行更新的时候":["92.13"],"会通过数据绑定更新到":["92.13"],"业务逻辑层":["92.13"],"需要什么数据":["92.13"],"要提供这个数据":["92.13"],"将来":["92.14"],"的时候":["92.14"],"如果发现是一个":["92.14"],"无状态":["92.15"],"没有生命周期":["92.15"],"所以渲染性能要好于普通组件":["92.15"],"函数式组件结构比较简单":["92.15"],"代码结构更清晰":["92.15"],"使用场景":["92.15","92.19"],"一个简单的展示组件":["92.15"],"作为容器组件使用":["92.15"],"应用的核心就是":["92.16"],"仓库":["92.16"],"基本上就是一个容器":["92.16"],"它包含着你的应用中大部分的状态":["92.16"],"state":["92.16","92.21"],"的状态存储是响应式的":["92.16"],"组件从":["92.16"],"中读取状态的时候":["92.16"],"若":["92.16"],"中的状态发生变化":["92.16"],"那么相应的组件也会相应地得到高效更新":["92.16"],"改变":["92.16"],"中的状态的唯一途径就是显式地提交":["92.16"],"也可以用于组件扩展":["92.17"],"组件选项中还有一个不太常用的选项":["92.17"],"最好使用这个":["92.18"],"的值来定义一个计算属性":["92.18"],"实践中如果确实想要改变父组件属性应该":["92.18"],"全局注册":["92.19"],"与":["92.19"],"局部注册":["92.19"],"插件的注册通过":["92.19"],"的方式进行注册":["92.19"],"安装":["92.19"],"第一个参数为插件的名字":["92.19"],"第二个参数是可选择的配置项":["92.19"],"component":["92.19"],"是用来构成你的":["92.19"],"app":["92.19"],"update":["92.20"],"stroe":["92.21"],"里":["92.21"],"这样":["92.21"],"在客户端挂载到":["92.21"],"之前":["92.21"],"可以直接从":["92.21"],"里取数据":["92.21"],"首屏的动态数据通过":["92.21"],"initial":["92.21"],"发送到客户端":["92.21"],"的实现":["92.21"],"主要就是把":["92.21"],"的组件输出成一个完整":["92.21"],"renderer":["92.21"],"就是干这事的":["92.21"],"直接删除了数组":["92.22"],"改变了数组的键值":["92.22"],"会以":["92.24"],"的方式调用":["92.24"],"之类的公共文件":["92.25"],"会被打包到":["92.25"],"dist":["92.25"],"根目录下":["92.25"],"用来放项目代码文件":["92.25"],"的一些接口配置":["92.25"],"assets":["92.25"],"用来放一些":["92.25"],"之类的静态资源":["92.25"],"虚拟":["93.0"],"重新渲染之前被触发":["93.0"],"可以在当前阶段进行数据更改":["93.0"],"不会造成重新渲染":["93.0"],"更新完成之后发生":["93.0"],"当前阶段":["93.0"],"已完成更新":["93.0"],"需要注意的是在此期间应该避免更改数据":["93.0"],"因为可能会导致无限循环的更新":["93.0"],"实例销毁之前发生":["93.0"],"在当前阶段实例完全可以被使用":["93.0"],"可以在这个阶段进行清除定时器等工作":["93.0"],"比如地图库":["93.1"],"图表库":["93.1"],"可以在这里销毁这些库的实例":["93.1"],"销毁过程":["93.2"],"beforedestroy":["93.2"],"准备好才执行一些操作":["93.3"],"generator":["94.0"],"代码":["95.0"],"appendchild":["95.1"],"加载并且压缩图片文件":["95.3"],"babel":["95.3"],"在特定的时间对资源做处理":["96.1"],"分为同步和异步的钩子":["96.2"],"异步钩子必须执行对应的回调":["96.2"],"module":["96.2"],"最终生成一个可以在浏览器加载执行的js文件":["97.0"],"同时每个模块生成一个唯一的":["97.1"],"并将解析过的":["97.1"],"模块缓存":["97.1"],"起来":["97.1"],"如果其他地方也引入该模块":["97.1"],"就无需重新解析":["97.1"],"最后根据依赖关系生成依赖图谱":["97.1"],"根据文件内容来定义":["98.0"],"文件内容不变":["98.0"],"节省开发时间":["99.0"],"提升开发体验":["99.0"],"当文件变化后":["99.1"],"重新编译":["99.1"],"编译结束后":["99.1"],"通知浏览器请求变化的资源":["99.1"],"同时将新生成的":["99.1"],"responsetext":["100.0"],"else":["100.0","101.0","107.0","116.4","119.0"],"bind返回的函数作为普通函数被调用时":["101.0"],"contextf":["101.0"],"input":["102.0"],"reduceright":["102.0"],"result":["102.0"],"放到任务队列尾部":["104.0"],"eat":["104.0"],"如果缓存已满":["105.0"],"返回该对象":["106.0"],"typeof":["106.0"],"instanceof":["107.0"],"假如返回值为普通值":["107.0"],"resolve传递出去":["107.0"],"同理":["107.0"],"判断rejectcallback事件的返回值":["107.0"],"reject传递出去":["107.0"],"输出结果的顺序和promises的顺序一致":["107.1"],"settimeout":["107.2"],"执行回调":["108.0"],"clearinterval":["108.0"],"清除定时器":["108.0"],"调用on方法":["112.0"],"将fn添加为回调函数":["112.0"],"触发事件":["112.0"],"emit":["112.0"],"rest":["112.0"],"如果存在":["112.0"],"依次调用所有回调函数":["112.0"],"foreach":["113.0"],"key":["113.0"],"setattribute":["113.0"],"pop":["114.0","115.0"],"如果":["116.1"],"对应元素不是目前的头部元素":["116.1"],"则交换两者":["116.1"],"循环让位":["116.2"],"最后得到的":["116.2"],"交换当前元素和左边界元素":["116.3"],"push":["116.4"],"若其中一个子数组首先被合并完全":["116.4"],"则直接拼接另一个子数组的剩余部分":["116.4"],"使用filter":["117.0"],"filter":["117.0"],"大于等待时间就把":["121.0"],"设置为当前时间并执行函数":["121.0"],"apply":["121.1"],"end":["121.1"]},{"1":["6.24","6.27"],"2":["80.7"],"4":["35.0"],"5":["99.1"],"6":["97.1"],"8":["73.8"],"11":["56.0"],"200":["65.0"],"304":["65.0"],"404":["88.4"],"同一页面在不同类型的设备上":["5.0"],"交互方式应该是符合习惯的":["5.0"],"设置负值字体间距将文本倒序":["5.1"],"适用于文言文":["5.1"],"margin":["5.1"],"left":["5.1"],"排版左重右轻列表":["5.1"],"横行布局时":["5.1"],"最后一个元素通过设置":["5.1"],"实现向右对齐":["5.1"],"适用于右侧带图标的导航栏":["5.1"],"换行":["6.4"],"空格会产生元素间隔":["6.4"],"兼容性好":["6.5"],"不管是块级还是行内都能实现":["6.5"],"缺点":["6.5"],"代码较多":["6.5"],"脱离文档流":["6.5"],"兼容性不好":["6.5"],"需要知道高度的值":["6.8"],"的值":["6.9"],"这个尚未搞清楚":["6.10"],"应该是":["6.10"],"使":["6.10"],"上下边界无限延伸至剩余空间并平分了":["6.10"],"content":["6.11","39.0"],"middle":["6.13"],"50px":["6.14"],"self":["6.17","117.0"],"大于等于":["6.19"],"left的宽度":["6.19"],"hidden":["6.20","6.26"],"触发bfc达到自适应":["6.20"],"0f0":["6.21","6.23","6.27"],"一列不定":["6.22"],"一列自适应":["6.22"],"盒子宽带随着内容增加或减少发生变化":["6.22"],"另一个盒子自适应":["6.22"],"均分":["6.24","6.27"],"parent剩余的部分":["6.24"],"触发":["6.26","40.1"],"bfc":["6.26"],"parent剩余的部分达到自适应":["6.27"],"之后真正的":["9.0"],"事件阻止掉":["9.0"],"还可以解决穿透问题":["9.0"],"以及":["10.0"],"e":["10.0"],"tag":["10.0"],"都是不错的":["10.0"],"不过要注意一个问题":["10.0"],"就是文件更新后":["10.0"],"你要避免缓存而带来的影响":["10.0"],"其中一个解决防范是在文件名字后面加一个版本号":["10.0"],"减少":["10.0"],"http":["10.0"],"请求数":["10.0"],"将多个":["10.0"],"文件合并":["10.0"],"或者是干脆直接写成内联样式":["10.0"],"内联样式的一个缺点就是不能缓存":["10.0"],"spidermonkey":["12.0"],"firefox":["12.0"],"节点的样式":["13.0"],"创建布局树":["13.0"],"并计算元素的布局信息":["13.0"],"对布局树进行分层":["13.0"],"并生成分层树":["13.0"],"为每个图层生成绘制列表":["13.0"],"并将其提交到合成线程":["13.0"],"合成线程将图层分成图块":["13.0"],"并在光栅化线程池中将图块转换成位图":["13.0"],"合成线程发送绘制图块命令":["13.0"],"drawquad":["13.0"],"给浏览器进程":["13.0"],"浏览器进程根据":["13.0"],"消息生成页面":["13.0"],"并显示到显示器上":["13.0"],"操作系统会回收进程所占用的内存":["14.1"],"进程之间的内容相互隔离":["14.1"],"通过插件进程进行隔离":["14.2"],"保证插件进行奔溃不会对浏览器和页面造成影响":["14.2"],"属性值不为":["16.1"],"visible":["16.1"],"的元素":["16.1"],"阻止它们的边界垂直交叠":["16.2"],"display":["18.0","79.3"],"none":["18.0","79.3","92.5"],"没有什么区别":["18.0"],"媒体查询":["19.0"],"使用硬件加速":["20.0"],"之后":["22.0"],"因为有":["22.0"],"的设置会自动放大或缩小":["22.0"],"和交叉轴两端对齐":["23.1"],"轴线之间的间隔平均分布":["23.1"],"每根轴线两侧的间隔都相等":["23.1"],"轴线占满整个交叉轴":["23.1"],"当空间不足时":["23.2"],"等比例缩小":["23.2"],"basis":["23.2"],"由于":["24.0"],"方法是基于文档的":["24.0"],"无法使用":["24.0"],"的方式插入样式":["24.0"],"发生的重叠":["25.0"],"我们可以通过为其设置":["25.0"],"pa":["25.0"],"dding":["25.0"],"或者高度来解决这个问题":["25.0"],"height":["27.0","33.0"],"视口的高":["27.0"],"如果需要创建动画":["28.0"],"游戏或交互式图形":["28.0"],"不需要触发特定状态即可执行":["29.0"],"top":["30.0"],"bottom":["30.0"],"单冒号":["31.0"],"会生成新的元素":["31.0"],"transform":["32.0"],"scale":["32.0"],"将元素缩放为":["32.0"],"依然占据空间":["32.0"],"不可交互":["32.0"],"line":["33.0"],"使用媒体查询避免不必要的样式加载":["35.0"],"通过媒体查询在适当的条件下加载特定的样式":["35.0"],"避免在不需要的情况下加载不必要的样式":["35.0"],"造成不连续的动画效果":["36.0"],"出现跳帧现象":["36.0"],"skyblue":["38.0"],"flex":["39.0"],"布局":["39.0"],"justify":["39.0"],"或":["40.1","88.4"],"auto":["40.1"],"yellow":["41.1"],"inherit":["42.0"],"时":["42.0"],"会从父元素继承":["42.0"],"由于字体的基线对齐":["43.1"],"子元素之间可能会存在一些额外的空白间隙":["43.1"],"浏览器默认":["44.1"],"false":["45.0","59.0"],"则为冒泡":["45.0"],"它们的执行顺序是按照它们在文档中出现的顺序执行的":["46.0"],"保证了它们之间的顺序性":["46.0"],"变为下载链接":["47.0"],"queryselector":["48.0"],"queryselectorall":["48.0"],"不利于":["49.0"],"seo":["49.0"],"适用于当前页面需要用到的重要资源":["51.0"],"以优化关键资源的加载时间":["51.0"],"这也是为什么建议使用":["52.0"],"方式来加载":["52.0"],"而不是":["52.0"],"import":["52.0"],"的方式":["52.0"],"关闭连接":["53.1"],"log":["53.2","65.0"],"newvalue":["53.2"],"页面2":["53.3"],"这些语义标签":["54.1"],"删除了":["54.1"],"big":["54.1"],"font":["54.1"],"这些没有语义的标签":["54.1"],"联系信息":["54.2"],"cite":["54.2"],"标记引用的作者或来源":["54.2"],"引入了迭代器和生成器的概念":["56.0"],"可以通过自定义迭代器来遍历数据集合":["56.0"],"并使用生成器函数来生成迭代器":["56.0"],"管道操作符":["56.0"],"提案阶段的特性":["56.0"],"引入了管道操作符":["56.0"],"可以将表达式的结果作为参数传递给下一个表达式":["56.0"],"简化了函数调用和方法链的写法":["56.0"],"使用微任务":["57.0"],"本次":["57.0"],"轮询就可以获取到更新的":["57.0"],"如果使用宏任务":["57.0"],"要到下一次":["57.0"],"中":["57.0","93.0"],"才能获取到更新的":["57.0"],"domnode":["57.0"],"process":["57.0"],"执行顺序早于微任务":["57.0"],"return":["58.0","106.0","111.0","116.1","116.2","117.0","118.0"],"对于obj":["58.0"],"函数的调用":["58.0"],"它的外层作用域是window":["58.0"],"因为对象obj不属于作用域":["58.0"],"所以会打印window":["58.0"],"第一个this":["58.0"],"name指向的就是调用者obj":["58.0"],"返回的匿名函数是一个箭头函数":["58.0"],"this由外层函数决定":["58.0"],"所以和foo函数的this一样":["58.0"],"指向obj":["58.0"],"来阻止默认事件":["59.0"],"事件委托是利用了事件的冒泡原理实现的":["59.1"],"当我们为最外层的节点添加点击事件":["59.1"],"那么里面的":["59.1"],"ul":["59.1"],"li":["59.1"],"的点击事件会冒泡到最外层节点上":["59.1"],"委托它代为执行事件":["59.1"],"这个变量在块级作用域外无法被访问":["60.3"],"会在每次迭代中创建一个新的块级作用域":["60.6"],"并在这个作用域内声明一个新的变量":["60.6"],"不会污染外部作用域":["60.6"],"所以在每个回调函数中都能访问到正确的":["60.6"],"值":["60.6","91.12"],"函数创建的对象":["61.3"],"该函数":["61.3"],"this":["63.1","93.0","121.0"],"这三个属性":["63.1"],"引擎从当前栈中移除全局执行上下文":["63.3"],"就是全局对象":["63.5"],"日期对象":["64.1"],"date":["64.1"],"数据类型的主要作用就是为对象添加独一无二的属性名":["64.2"],"类型的属性也适合作为对象的私有属性":["64.3"],"使用":["64.5","76.0","82.0","92.8","93.3"],"void":["64.5"],"对表达式求值":["64.5"],"所以误判为对象":["64.6"],"tostring":["64.8"],"call":["64.8","93.0"],"constructor":["64.8"],"支持基本数据类型":["64.8"],"方法判断一个值是否为数组":["64.9"],"然后判断是否等于":["64.10"],"将结果四舍五入到指定的精度":["64.11"],"将相加的结果和右边相减":["64.11"],"如果相减的结果小于一个极小数":["64.11"],"就可以认定结果是相等的":["64.11"],"更准确":["64.12"],"方法同":["64.17"],"get":["64.17"],"status":["65.0"],"console":["65.0"],"responsetxml":["65.0"],"如拦截请求和响应":["65.1"],"转换数据":["65.1"],"取消请求等":["65.1"],"负载较小":["66.0"],"因此提高了服务器响应速度":["66.0"],"实际上":["66.0"],"的工作过程要更复杂":["66.0"],"为了便于理解":["66.0"],"上面只是简述":["66.0"],"我们从用户访问一个":["66.0"],"url":["66.0"],"地址说起":["66.0"],"访问url":["66.0"],"cname指向的cdn专用dns服务器对url解析":["66.0"],"负载均衡设备根据解析的ip地址和内容选择一台缓存服务器":["66.0"],"返回缓存服务器ip地址给用户":["66.0"],"地址给本地服务器":["67.0"],"本地服务器缓存解析结果":["67.0"],"返回解析结果给用户":["67.0"],"不是幂等的":["68.0"],"浏览器一般不会缓存":["68.0"],"请求":["68.0"],"需要向":["69.0"],"ca":["69.0"],"申请数字证书":["69.0"],"保证服务器的身份是可信的":["69.0"],"使得不能篡改通信内容":["69.1"],"通过数字证书保证服务器的合法性":["69.1"],"session":["69.3"],"key":["69.3"],"用来加密接下来的整个对话过程":["69.3"],"混合加密主要是为了解决":["69.4"],"但是它并不能保证数据的完整性":["69.4"],"也就是说在传输的时候数据是有可能被第三方篡改的":["69.4"],"比如完全替换掉":["69.4"],"所以说它并不能校验数据的完整性":["69.4"],"如果需要做到这一点就需要使用到数字签名":["69.4"],"中带上":["69.5"],"后端用同样的算法解密":["69.5"],"头字段每个组成要求都没有被固定死":["70.1"],"允许开发人员自定义和扩展":["70.1"],"所以":["70.3"],"管道解决了请求的队头阻塞":["70.3"],"但是没有解决响应的队头阻塞":["70.3"],"经过有损压缩压缩之后的数据":["70.4"],"解压之后和原始数据不同但是非常相近":["70.4"],"有损压缩主要将次要的数据舍弃":["70.4"],"通过牺牲一些质量来减少数据量":["70.4"],"提高压缩比":["70.4"],"常用于压缩多媒体数据":["70.4"],"比如音视频":["70.4"],"图片":["70.4"],"可以通过":["70.4"],"请求头部中的":["70.4"],"字段中的":["70.4"],"q":["70.4"],"质量因子":["70.4"],"告诉服务器期望的资源质量":["70.4"],"压缩比较高的是":["70.4"],"webp":["70.4"],"格式":["70.4"],"握手":["70.6"],"慢启动以及":["70.6"],"tls":["70.6"],"握手过程":["70.6"],"这些都是很耗时的":["70.6"],"服务器主动推送资源":["70.6"],"客户端发起的请求":["70.6"],"必须使用的是奇数号":["70.6"],"服务器主动的推送":["70.6"],"使用的是偶数号":["70.6"],"服务器在推送资源时":["70.6"],"会通过":["70.6"],"push":["70.6","77.3","88.1","111.0","118.0"],"promise":["70.6","90.5"],"帧传输":["70.6"],"并通过帧中的":["70.6"],"promised":["70.6"],"id":["70.6"],"字段告知客户端":["70.6"],"接下来会在哪个偶数号":["70.6"],"中发送包体":["70.6"],"说明数据的压缩方法":["71.0"],"表示服务器返回的数据使用了什么格式":["71.0"],"不利于重构":["72.0"],"因为涉及到的系统很多":["72.0"],"要重构必须要兼容所有的系统":["72.0"],"可能很耗时":["72.0"],"无人看守桌面":["72.0"],"因为只需要登录一次":["72.0"],"所有的授权的应用系统都可以访问":["72.0"],"可能导致一些很重要的信息泄露":["72.0"],"交由网络接口层":["73.2"],"网络接口层":["73.2"],"在":["73.2"],"报文的前面加上":["73.2"],"mac":["73.2"],"头部":["73.2"],"封装成数据帧发送到网络上":["73.2"],"表示今后不会再有数据发送":["73.3"],"希望断开连接":["73.3"],"服务端接收到应答报文后":["73.5"],"也处于":["73.5"],"至此建立连接":["73.5"],"只有第三次可以携带数据":["73.5"],"并不会立即关闭连接":["73.6"],"而是先发送一个":["73.6"],"包先告诉客户端收到关闭连接的请求":["73.6"],"只有当服务器的所有报文发送完毕之后":["73.6"],"才发送":["73.6"],"报文断开连接":["73.6"],"因此需要四次挥手":["73.6"],"解密以后":["73.7"],"就能够获取上次对话的信息":["73.7"],"就不用重新生成对话秘钥了":["73.7"],"是面向连接的可靠性传输":["73.8"],"是不可靠的":["73.8"],"而是其中的一部分":["74.1"],"重定向已经存在的缓存文件":["74.2"],"也叫做缓存重定向":["74.2"],"暂时无法响应客户端":["74.4"],"option":["75.0"],"通过该请求来查询服务端是否允许跨域请求":["75.0"],"协议的缺点是在服务器端的配置比较复杂":["76.0"],"是一个全双工的协议":["76.0"],"也就是通信双方是平等的":["76.0"],"可以相互发送消息":["76.0"],"在命中强缓存失败的情况下":["77.0"],"才会走协商缓存":["77.0"],"绕开了浏览器":["77.1"],"设置了":["77.1"],"后":["77.1"],"每一次发起请求的时候都不会去询问浏览器的缓存情况":["77.1"],"而是直接向服务端去确认资源是否过期":["77.1"],"就是不使用任何缓存策略":["77.1"],"只允许直接向服务端发送请求":["77.1"],"并下载完整的响应":["77.1"],"优先级高于":["77.2"],"但是":["77.2"],"的生成过程需要服务器付出开销":["77.2"],"会影响服务端的性能":["77.2"],"不能替代":["77.2"],"只是对其的补充":["77.2"],"要求协议必须是":["77.3"],"https":["77.3"],"是指":["77.3"],"http2":["77.3"],"阶段存在的缓存":["77.3"],"有哪些字段":["77.5"],"不和服务器发起通信":["77.7"],"css":["77.9"],"图片等不需要业务服务器进行计算就可以得到的资源":["77.9"],"动态资源就是需要后端实时动态生成的资源":["77.9"],"来获取元素的大小以及相对于视口的位置":["78.0"],"js":["78.0"],"用户始终看不到网页上的内容":["79.0"],"用户一直在等":["79.0"],"但是服务端渲染模式下":["79.0"],"服务器给客户端的已经是一个直接可以拿来呈现给用户的网页":["79.0"],"中间环节早在服务端就帮我们做掉了":["79.0"],"给每个节点所应该出现在屏幕上的精确坐标":["79.1"],"得到基于渲染树的布局渲染树":["79.1"],"绘制渲染树":["79.1"],"遍历渲染树":["79.1"],"每个节点将使用":["79.1"],"ui":["79.1"],"后端层来绘制":["79.1"],"整个过程叫做绘制渲染树":["79.1"],"defer":["79.2"],"的加载是异步的":["79.2"],"执行是被推迟的":["79.2"],"等整个文档解析完成":["79.2"],"被标记了":["79.2"],"的":["79.2","91.9"],"文件才会开始依次执行":["79.2"],"可以保证脚本的执行顺序":["79.2"],"操作完之后再":["79.3"],"block":["79.3"],"webpack":["80.0","88.9"],"去优化":["80.0"],"其它":["80.2"],"原理也一样":["80.2"],"dll相关配置":["80.3"],"dllreferenceplugin":["80.3"],"manifest就是我们第一步中打包出来的json文件":["80.3"],"中即可":["80.4"],"这个方法":["80.5"],"这是一个异步的方法":["80.5"],"在打包时":["80.5"],"会被单独打成一个文件":["80.5"],"只有在我们跳转到这个路由的时候":["80.5"],"这个异步方法的回调才会生效":["80.5"],"才会真正的去获取这个组件的内容":["80.5"],"这就是按需加载":["80.5"],"存在":["80.6"],"压缩操作":["80.6"],"就是在构建的过程中去做一些服务器的工作":["80.6"],"为服务器分压":["80.6"],"种颜色":["80.7"],"颜色对比强烈的图像时":["80.8"],"人为压缩导致的图片模糊会非常明显":["80.8"],"而且不支持透明":["80.8"],"一般用于呈现小的":["80.9"],"logo":["80.9"],"颜色简单且对比强烈的图片或背景":["80.9"],"很灵活":["80.10"],"缺点是渲染成本比较高":["80.10"],"有一定的学习成本":["80.10"],"常用于图标":["80.10"],"图片的实际尺寸很小":["80.11"],"一般小于":["80.11"],"2kb":["80.11"],"图片没有办法以雪碧图的形式和其它小图结合":["80.11"],"图片的更新频率非常低":["80.11"],"不需要重复编码和修改文件内容":["80.11"],"维护成本低":["80.11"],"返回":["80.12"],"格式的图片":["80.12"],"否则返回原图":["80.12"],"头":["81.0"],"orm":["82.0"],"框架或查询构建器":["82.0"],"对用户输入进行输入验证和过滤":["82.0"],"security":["83.0"],"policy":["83.0"],"csp":["83.0"],"所以并不能确保服务器合法的身份":["84.2"],"客户端使用之前生成的随机":["84.3"],"进行解密数据":["84.3"],"但是传输的数据已经被监听":["84.4"],"客户端却无法得知":["84.4"],"保护网站资源免受滥用":["86.0"],"这样数组中对象发生变化时也会通知数据更新":["87.0"],"如果要在数据变化的同时进行异步操作或者是比较大的开销":["87.1"],"那么":["87.1"],"为最佳选择":["87.1"],"计算属性时":["87.2"],"先进行其他的依赖收集":["87.2"],"在初始化时直接调用回调函数":["87.3"],"可以通过在":["87.3"],"created":["87.3"],"阶段手动调用回调函数实现相同的效果":["87.3"],"方法":["88.1"],"获取动态参数":["88.2"],"不会触发":["88.4"],"事件":["88.4"],"这时我们需要手动触发页面跳转":["88.4"],"虽然美观":["88.4"],"但是刷新会出现":["88.4"],"需要后端进行配置":["88.4"],"则根据其所处深度":["88.5"],"deep":["88.5"],"在匹配数组结果中找到对应的路由并获取组件":["88.5"],"最终将其渲染出来":["88.5"],"popstate":["88.6"],"事件所监听":["88.6"],"而后面三者可以":["88.6"],"且用户点击浏览器前进后退键时也可以":["88.6"],"guards":["88.8"],"队列按顺序执行用户注册的守卫钩子函数":["88.8"],"如果没有通过验证逻辑则会取消原有的导航":["88.8"],"vue":["88.9"],"可以做":["88.9"],"代码分块":["88.9"],"定义两个全局变量":["88.10"],"route":["88.10"],"组件内可以访问当前路由和路由器实例":["88.10"],"省去了众多":["89.0"],"hack":["89.0"],"减少代码量等于减少了维护成本":["89.0"],"的回调函数只会被执行":["89.2"],"不会传递参数":["89.2"],"也是十分友好的":["89.3"],"更多新功能":["89.4"],"ref":["89.6"],"reactive":["89.6"],"比":["89.6"],"usestate":["89.6"],"难理解":["89.6"],"大大增加了代码的逻辑组织和代码复用能力":["89.7"],"更容易维护":["89.7"],"typescript":["89.7","95.3"],"模块化":["89.7"],"更容易扩展":["89.7"],"独立的响应化模块":["89.7"],"因此整体体积更小":["89.8"],"加载更快":["89.8"],"ssr":["89.8","92.8"],"渲染以字符串方式渲染":["89.8"],"注意":["89.9"],"不创造":["89.9"],"响应式":["89.9"],"而是":["89.9"],"延续":["89.9"],"方法相当于调用":["90.1"],"options":["90.1"],"mutationstype":["90.1"],"actionstype":["90.1"],"这样就很容易理解两者使用上的不同了":["90.1"],"用起来略繁琐":["90.2"],"一般用于":["90.2"],"插件中":["90.2"],"内部的实现就是通过订阅":["90.3"],"变化做统一处理":["90.3"],"通过插件的选项控制哪些需要持久化":["90.3"],"中每个":["90.4"],"store":["90.4","92.25"],"都是独立的":["90.4"],"互相不影响":["90.4"],"体积非常小":["90.4"],"只有":["90.4"],"1kb":["90.4"],"左右":["90.4"],"支持插件来扩展自身功能":["90.4"],"支持服务端渲染":["90.4"],"类似":["90.5"],"但需要注意它可能是异步的":["90.5"],"需要返回一个":["90.5"],"给用户以处理异步结果":["90.5"],"dom":["91.1","91.7"],"节点":["91.1"],"里面有":["91.1"],"标签名":["91.1"],"子节点":["91.1"],"文本等等":["91.1"],"对象一次性":["91.3"],"attach":["91.3"],"到":["91.3"],"树上":["91.3"],"避免大量的无谓计算":["91.3"],"数组中如果元素是对象类型也会进行递归劫持":["91.4"],"notify":["91.5"],"的话":["91.6"],"发现新旧节点的标签都是":["91.6"],"就会复用":["91.6"],"将第一个的复选框的值改成第二个的":["91.6"],"第二个的复用第三个的":["91.6"],"然后将第三个删除":["91.6"],"更新的时候采用虚拟":["91.7"],"的方式进行":["91.7"],"diff":["91.7"],"算法更新":["91.7"],"更新子节点时又分了几种情况":["91.8"],"新的子节点是文本":["91.8"],"老的子节点是数组则清空":["91.8"],"并设置文本":["91.8"],"老的子节点是文本则直接更新文本":["91.8"],"新的子节点是数组":["91.8"],"老的子节点是文本则清空文本":["91.8"],"并创建新子节点数组中的子元素":["91.8"],"老的子节点也是数组":["91.8"],"那么比较两组子节点":["91.8"],"更新细节":["91.8"],"中引入的更新策略":["91.8"],"静态节点标记等":["91.8"],"重新编写了这一部分的实现":["91.9"],"利用":["91.9"],"代理要响应化的数据":["91.9"],"它有很多好处":["91.9"],"编程体验是一致的":["91.9"],"不需要使用特殊":["91.9"],"初始化性能和内存消耗都得到了大幅改善":["91.9"],"另外由于响应化的实现代码抽取为独立的":["91.9"],"reactivity":["91.9"],"包":["91.9"],"使得我们可以更灵活的使用它":["91.9"],"第三方的扩展开发起来更加灵活了":["91.9"],"同时首次执行渲染函数会创建它内部响应式数据之间和组件更新函数之间的依赖关系":["91.10"],"这使得以后数据变化时会执行对应的更新函数":["91.10"],"异步清空":["91.11"],"队列":["91.11"],"的后面":["91.12"],"这样等队列内部的更新函数都执行完毕":["91.12"],"所有":["91.12"],"操作也就结束了":["91.12"],"自然能够获取到最新的":["91.12"],"在内部为不同的输入元素使用不同的属性并抛出不同的事件":["91.13"],"提高性能":["92.0"],"必须是一个函数":["92.1"],"节点增加与删除":["92.2"],"如果需要非常频繁的切换":["92.2"],"则使用":["92.2"],"较好":["92.2"],"如果在运行时条件很少改变":["92.2"],"移动到容器元素上":["92.3"],"或者外面包一层":["92.3"],"template":["92.3"],"方便复用":["92.6"],"csr":["92.7"],"方式":["92.7"],"首屏采用服务端渲染的方式":["92.7"],"后续交互采用客户端渲染方式":["92.7"],"lru":["92.9"],"最近最少使用":["92.9"],"算法":["92.9"],"选择最近最久未使用的组件予以淘汰":["92.9"],"依赖问题":["92.12"],"数据来源问题":["92.12"],"有某些操作":["92.13"],"就要响应这些操作":["92.13"],"所以可以说它是":["92.13"],"for":["92.13"],"则直接遍历":["92.14"],"创建或更新":["92.14"],"比如":["92.15"],"router":["92.15"],"view":["92.15"],"就是一个函数式组件":["92.15"],"高阶组件":["92.15"],"用于接收一个组件作为参数":["92.15"],"返回一个被包装过的组件":["92.15"],"mutation":["92.16"],"这样使得我们可以方便地跟踪每一个状态的变化":["92.16"],"根据组件之间关系讨论组件通信最为清晰有效":["92.16"],"父子组件":["92.16"],"跨层级关系":["92.16"],"也可以起到扩展组件的目的":["92.17"],"emit":["92.18"],"一个事件让父组件去做这个变更":["92.18"],"注意虽然我们不能直接修改一个传入的对象或者数组类型的":["92.18"],"但是我们还是能够直接改内嵌的对象或属性":["92.18"],"的业务模块":["92.19"],"它的目标是":["92.19"],"件":["92.19"],"plugin":["92.19"],"是用来增强你的技术栈的功能模块":["92.19"],"本身":["92.19"],"简单来说":["92.19"],"插件就是对":["92.19"],"的功能的增强或补充":["92.19"],"只能用一次":["92.20"],"可以有多个":["92.20"],"需要做的事多点":["92.21"],"输出完整":["92.21"],"除了":["92.21"],"complier":["92.21"],"vnode":["92.21"],"还需如数据获取填充至":["92.21"],"hydration":["92.21"],"缓存等等":["92.21"],"相比于其他模板引擎":["92.21"],"ejs":["92.21"],"jade":["92.21"],"等":["92.21"],"最终要实现的目的是一样的":["92.21"],"性能上可能要差点":["92.21"],"怎么理解":["92.21"],"的单向数据流":["92.21"],"数据总是从父组件传到子组件":["92.21"],"子组件没有权利修改父组件传过来的数据":["92.21"],"只能请求父组件对原始数据进行修改":["92.21"],"这样会":["92.21"],"防止从子组件意外改变父级组件的状态":["92.21"],"从而导致你的应用的数据流向难以理解":["92.21"],"open":["92.23"],"被执行时":["92.24"],"它会对":["92.24"],"中的每个语言块用单独的":["92.24"],"链处理":["92.24"],"最后将这些单独的块装配成最终的组件模块":["92.24"],"components":["92.25"],"用来放项目通用组件":["92.25"],"layout":["92.25"],"用来放项目的布局":["92.25"],"用来放项目的路由配置":["92.25"],"用来放状态管理":["92.25"],"的配置":["92.25"],"utils":["92.25"],"用来放项目中的工具方法类":["92.25"],"views":["92.25"],"用来放项目的页面文件":["92.25"],"实例销毁之后发生":["93.0"],"此阶段组件已被拆解":["93.0"],"数据绑定被卸除":["93.0"],"监听被移出":["93.0"],"子组件实例也被销毁":["93.0"],"在编写生命周期函数的时候不用使用箭头函数":["93.0"],"因为底层代码":["93.0"],"callhook":["93.0"],"使用了":["93.0"],"apply":["93.0","112.0","121.0"],"改变了":["93.0"],"指向":["93.0"],"释放资源和避免内存泄露":["93.1"],"destroyed":["93.2"],"生成新的":["94.0"],"module":["95.1"],"exports":["95.1","96.2"],"es6":["95.3"],"转换成":["95.3"],"es5":["95.3"],"ts":["95.3"],"将":["95.3"],"递归遍历所有依赖图谱的模块":["97.1"],"组装成一个个包含多个模块的":["97.1"],"chunk":["97.1"],"块":["97.1"],"最后将生成的文件输出到":["97.1"],"output":["97.1"],"的目录中":["97.1"],"则":["98.0"],"不变":["98.0"],"值传给浏览器":["99.1"],"用于下次热更新使用":["99.1"],"浏览器拿到更新后的模块后":["99.1"],"用新模块替换掉旧的模块":["99.1"],"实现局部刷新":["99.1"],"error":["100.0"],"send":["100.0"],"如果绑定的是构造函数":["101.0"],"那么需要继承构造函数原型属性和方法":["101.0"],"实现继承的方式":["101.0"],"使用object":["101.0"],"create":["101.0"],"object":["101.0"],"function":["104.0"],"new":["104.0"],"删除最久未被访问的数据":["105.0"],"keys":["105.0"],"next":["105.0"],"否则返回新对象":["106.0"],"else":["107.2","111.0"],"foreach":["112.0"],"使用apply将参数传递给回调函数":["112.0"],"子数组进行递归操作":["113.0"],"child":["113.0"],"appendchild":["113.0"],"reverse":["114.0","115.0"],"只要发生了一次交换":["116.0"],"就修改标志位":["116.0"],"true":["116.0"],"若一次交换也没发生":["116.0"],"则说明数组有序":["116.0"],"直接放过":["116.0"],"的正确索引":["116.2"],"将枢轴元素放到左边界的位置":["116.3"],"完成一次分区操作":["116.3"],"返回枢轴元素的最终索引位置":["116.3"],"concat":["116.4"],"indexof":["117.0"],"settimeout":["121.1"]}]'},t={"0.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录后端知识点!
:::
`,l:"BackEnd/index.html",a:"编程踩坑积累与总结"},"1.0":{t:"test1",p:"",l:"Fragments/Frag1/1.html",a:"test1"},"2.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录突发奇想!
:::
`,l:"Fragments/index.html",a:"编程踩坑积累与总结"},"3.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录框架相关知识点！
:::
`,l:"Framework/index.html",a:"编程踩坑积累与总结"},"4.0":{t:"testdddd",p:"",l:"Framework/Vue/test.html",a:"testdddd"},"5.0":{t:"移动端响应式",p:`什么是响应式？
响应式就是将界面设计成能够适应不同的设备。&quot;如果将屏幕看成是容器，那么内容就像水一样&quot;
为什么要设计响应式？
首先，电脑、笔记本、手机、平板等智能设备在不断增加，其 ...`,l:"FrontEnd/CSS/响应式.html",a:"移动端响应式"},"5.1":{t:"响应式布局常用方法",p:`

使用 vm 定制 rem 自适应布局
移动端使用 rem 布局需要通过 JS 设置不同屏幕宽高比的 font-size，结合 vm 单位和 calc()可以脱离 JS 的控制
适用于 rem 布局 ...`,l:"FrontEnd/CSS/响应式.html#响应式布局常用方法",a:"响应式布局常用方法"},"6.0":{t:"css-常见布局",p:"\r",l:"FrontEnd/CSS/常见布局.html",a:"css-常见布局"},"6.1":{t:"水平布局",p:"\r",l:"FrontEnd/CSS/常见布局.html#水平布局",a:"水平布局"},"6.2":{t:"文本、行内元素、行内块级元素",p:`使用 text-align：center

优点：兼容性比较好
缺点：只对行内元素有效，且属性会继承，会影响后代行内内容，如果子元素宽度大于父元素宽度就会失效。
注意：只控制行内内容如何相对父元素对齐 ...`,l:"FrontEnd/CSS/常见布局.html#文本、行内元素、行内块级元素",a:"文本、行内元素、行内块级元素"},"6.3":{t:"单个块级元素",p:`margin:0 auto

必须定宽
优点：兼容性好
缺点：必须顶宽，值不能为 auto，宽度要小于父元素，否则无效

.son {
  width: 100px;
  margin: 0 auto ...`,l:"FrontEnd/CSS/常见布局.html#单个块级元素",a:"单个块级元素"},"6.4":{t:"多个块级元素",p:`#parent {
  text-align: center;
}
.son {
  display: inline-block; /*改为行内或者行内块级形式，以达到text-align对其生效*/ ...`,l:"FrontEnd/CSS/常见布局.html#多个块级元素",a:"多个块级元素"},"6.5":{t:"使用绝对定位",p:`#parent {
  height: 200px;
  width: 200px; /*定宽*/
  position: relative; /*父相*/
  background-color: # ...`,l:"FrontEnd/CSS/常见布局.html#使用绝对定位",a:"使用绝对定位"},"6.6":{t:"任意个元素",p:`#parent {
  display: flex;
  justify-content: center;
}


优点：简单，容易理解
缺点：PC 端兼容性不好

`,l:"FrontEnd/CSS/常见布局.html#任意个元素",a:"任意个元素"},"6.7":{t:"垂直居中",p:"\r",l:"FrontEnd/CSS/常见布局.html#垂直居中",a:"垂直居中"},"6.8":{t:"单行、行内、行内块",p:`#parent {
  height: 150px;
  line-height: 150px; /*与height等值*/
}


优点：兼容性好
缺点：只能用于单行行内内容，需要知道高度的值

`,l:"FrontEnd/CSS/常见布局.html#单行、行内、行内块",a:"单行、行内、行内块"},"6.9":{t:"多行文本、行内元素、行内块级元素",p:`#parent {
  /*或者用span把所有文字包裹起来，设置display：inline-block转换成图片的方式解决*/
  height: 150px;
  line-height: 30 ...`,l:"FrontEnd/CSS/常见布局.html#多行文本、行内元素、行内块级元素",a:"多行文本、行内元素、行内块级元素"},"6.10":{t:"单个块元素",p:`#parent {
  display: table-cell;
  vertical-align: middle;
}
- 使用 table-cell、使用绝对定位、使用 flex

/_原理：子绝 ...`,l:"FrontEnd/CSS/常见布局.html#单个块元素",a:"单个块元素"},"6.11":{t:"任意个元素",p:`#parent {
  display: flex;
  align-items: center;
}

或 #parent {
  display: flex;
}
.son {
  align-s ...`,l:"FrontEnd/CSS/常见布局.html#任意个元素",a:"任意个元素"},"6.12":{t:"水平垂直居中",p:"\r",l:"FrontEnd/CSS/常见布局.html#水平垂直居中",a:"水平垂直居中"},"6.13":{t:"行内、行内块级、图片",p:`#parent {
  height: 150px;
  line-height: 150px; /*行高的值与height相等*/
  text-align: center;
  font-size ...`,l:"FrontEnd/CSS/常见布局.html#行内、行内块级、图片",a:"行内、行内块级、图片"},"6.14":{t:"tabel-cell",p:`#parent {
  height: 150px;
  width: 200px;
  display: table-cell;
  vertical-align: middle;
  /*text ...`,l:"FrontEnd/CSS/常见布局.html#tabel-cell",a:"tabel-cell"},"6.15":{t:"绝对定位",p:`#parent {
  position: relative;
}
#son {
  position: absolute;
  top: 50%;
  left: 50%;
  /*定宽高时等同于m ...`,l:"FrontEnd/CSS/常见布局.html#绝对定位",a:"绝对定位"},"6.16":{t:"绝对居中",p:`#parent {
  position: relative;
}
#son {
  position: absolute;
  margin: auto;
  width: 100px;
  hei ...`,l:"FrontEnd/CSS/常见布局.html#绝对居中",a:"绝对居中"},"6.17":{t:"flex",p:`#parent {
  display: flex;
}
#son {
  margin: auto;
}

或 #parent {
  display: flex;
  justify-conten ...`,l:"FrontEnd/CSS/常见布局.html#flex",a:"flex"},"6.18":{t:"两列布局",p:`左列定宽，右列自适应
`,l:"FrontEnd/CSS/常见布局.html#两列布局",a:"两列布局"},"6.19":{t:"float-margin",p:`&lt;body
  &gt; &lt;div
  id=&quot;left&quot;
  &gt; 左列定宽&lt;/div
  &gt; &lt;div
  id=&quot;right&qu ...`,l:"FrontEnd/CSS/常见布局.html#float-margin",a:"float-margin"},"6.20":{t:"float-overflow",p:`&lt;body&gt;
  &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt;
  &lt;div id=&quot;right&quot;&gt;右列自 ...`,l:"FrontEnd/CSS/常见布局.html#float-overflow",a:"float-overflow"},"6.21":{t:"绝对定位",p:`&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; ...`,l:"FrontEnd/CSS/常见布局.html#绝对定位",a:"绝对定位"},"6.22":{t:"flex",p:`&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; ...`,l:"FrontEnd/CSS/常见布局.html#flex",a:"flex"},"6.23":{t:"float-overflow",p:`&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;左列不定宽&lt;/div&gt ...`,l:"FrontEnd/CSS/常见布局.html#float-overflow",a:"float-overflow"},"6.24":{t:"flex",p:`&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;左列不定宽&lt;/div&gt ...`,l:"FrontEnd/CSS/常见布局.html#flex",a:"flex"},"6.25":{t:"三列布局",p:`两列定宽，一列自适应
`,l:"FrontEnd/CSS/常见布局.html#三列布局",a:"三列布局"},"6.26":{t:"float-margin",p:`&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; ...`,l:"FrontEnd/CSS/常见布局.html#float-margin",a:"float-margin"},"6.27":{t:"flex",p:`&lt;body&gt;
  &lt;div id=&quot;parent&quot;&gt;
    &lt;div id=&quot;left&quot;&gt;左列定宽&lt;/div&gt; ...`,l:"FrontEnd/CSS/常见布局.html#flex",a:"flex"},"7.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录前端基础知识
:::
`,l:"FrontEnd/index.html",a:"编程踩坑积累与总结"},"9.0":{t:"_300ms-延迟解决的是双击缩放。双击缩放-手指在屏幕快速点击两次。safari-浏览器就会将网页缩放至原始比例。当用户点击屏幕一次之后-浏览器并不会判断用户确实要打开至这个链接-还是想要进行双击操作-所以-safair-浏览器会等待-300ms-用来判断是否再次点击了屏幕。",p:`怎么解决？

禁止缩放，设置 meta 标签 user-scalable=no
fastclick.js 原理是检查到 touched 事件的时候，会通过 dom 自定义事件立即发出 click 事件 ...`,l:"Interview/Browser/300ms延迟.html",a:"_300ms-延迟解决的是双击缩放。双击缩放-手指在屏幕快速点击两次。safari-浏览器就会将网页缩放至原始比例。当用户点击屏幕一次之后-浏览器并不会判断用户确实要打开至这个链接-还是想要进行双击操作-所以-safair-浏览器会等待-300ms-用来判断是否再次点击了屏幕。"},"10.0":{t:"css-加载不会阻塞-dom-树的解析",p:`
css 加载会阻塞 DOM 树的渲染
css 加载会阻塞后面 js 语句的执行

原理：


HTML 解析文件，生成 DOM Tree，解析 CSS 文件生成 CSSOM Tree


将 Dom ...`,l:"Interview/Browser/CSS加载会造成阻塞吗.html",a:"css-加载不会阻塞-dom-树的解析"},"11.0":{t:"cdn-缓存方便",p:`
突破浏览器并发限制
解压 cookie 带宽

`,l:"Interview/Browser/为什么利用多个域名存储网站资源更有效.html",a:"cdn-缓存方便"},"12.0":{t:"是浏览器的核心部分-主要分为两个部分-渲染引擎和-javascript-引擎",p:`渲染引擎：负责解析网页的 HTML、图像等内容，负责处理网页的布局、计算、绘制等任务，将其转化成可视化的网页形式。常见的有 webkit、Blink
JavaScript 引擎：解析执行 JavaSc ...`,l:"Interview/Browser/对浏览器内核的理解.html",a:"是浏览器的核心部分-主要分为两个部分-渲染引擎和-javascript-引擎"},"13.0":{t:"用户输入-url-并回车",p:`

浏览器进程检查 url，组装协议，构成完整的 url


浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程


网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果 ...`,l:"Interview/Browser/输入URL到页面呈现发生了什么.html",a:"用户输入-url-并回车"},"14.0":{t:"什么是并行处理",p:`并行处理就是同一时刻处理多个任务。
`,l:"Interview/Browser/进程问题.html",a:"什么是并行处理"},"14.1":{t:"线程-vs-进程",p:"进程：一个进程就是一个程序的运行实例。启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码，运行中的数据和一个执行任务的主线程，这样一个运行环境叫做进程。（管理任务和资源分配的基本单位）。 ...",l:"Interview/Browser/进程问题.html#线程-vs-进程",a:"线程-vs-进程"},"14.2":{t:"多进程架构",p:`
浏览器进程：主要负责界面显示、用户交互、子进程管理、同时提供存储功能
渲染进程：将 HTML、CSS、JS 转换为用户可以与之交互的网页。
GPU 进程：绘制
网络进程：负责页面的网络资源加载。
插 ...`,l:"Interview/Browser/进程问题.html#多进程架构",a:"多进程架构"},"15.0":{t:"是匹配元素之后的选择器",p:`+是匹配相邻元素的选择器
`,l:"Interview/CSS/+和~选择器有什么不同.html",a:"是匹配元素之后的选择器"},"16.0":{t:"是什么",p:`块级格式化上下文，BFC 是一个独立的渲染区域，其中的元素按照特定规则进行排布，与其他区域相互隔离，不会影响到外部布局。
`,l:"Interview/CSS/BFC.html",a:"是什么"},"16.1":{t:"触发条件",p:`
根元素（HTML）或包含根元素的元素
浮动元素： 元素的 float 属性不为 none。
绝对定位元素： 元素的 position 属性为 absolute 或 fixed。
display 属性 ...`,l:"Interview/CSS/BFC.html#触发条件",a:"触发条件"},"16.2":{t:"作用",p:`
清除浮动： 当一个元素的子元素都是浮动元素时，它将会塌陷，不会正常地包裹子元素。创建一个 BFC 可以解决这个问题，因为 BFC 的边界会包裹浮动元素。
垂直外边距重叠： 在同一个 BFC 中的元素 ...`,l:"Interview/CSS/BFC.html#作用",a:"作用"},"17.0":{t:"怎么修改-chrome-记住密码后自动填充表单的黄色背景",p:"\r",l:"Interview/CSS/Chrome自动填充问题.html",a:"怎么修改-chrome-记住密码后自动填充表单的黄色背景"},"17.1":{t:"产生原因",p:`由于 Chrome 默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的
`,l:"Interview/CSS/Chrome自动填充问题.html#产生原因",a:"产生原因"},"17.2":{t:"解决方案",p:`
在form标签上直接关闭了表单的自动填充：autocomplete=&quot;off&quot;
input:-webkit-autofill { background-color: transp ...`,l:"Interview/CSS/Chrome自动填充问题.html#解决方案",a:"解决方案"},"18.0":{t:"css-里的-visibility-属性有个-collapse-属性值-在不同浏览器下有什么区别",p:`通常用于表格的行和列
当用于行上的时候：该行会被隐藏，并且不会占据任何空间，相邻的行自动合并
当用于列上的时候：该列会被隐藏，但任会占据空间，不会导致相邻元素合并
当一个元素的 visibility  ...`,l:"Interview/CSS/collapse属性.html",a:"css-里的-visibility-属性有个-collapse-属性值-在不同浏览器下有什么区别"},"19.0":{t:"_1-新增伪类和伪元素-通用选择器",p:`
新增盒子模型
圆角边框、边框图像
flex 弹性盒子布局
媒体查询

`,l:"Interview/CSS/CSS3新特性.html",a:"_1-新增伪类和伪元素-通用选择器"},"20.0":{t:"合并压缩-css-文件",p:`
使用字体图标和 SVG 图标
减少选择器的复杂性
避免使用！important
使用缓存
使用精灵图
使用硬件加速

`,l:"Interview/CSS/CSS优化.html",a:"合并压缩-css-文件"},"21.0":{t:"inline",p:`

使元素变成行内元素，拥有行内元素的特性，可以和其它行内元素共占一行，不会独占一行；不能改变 height、weight，大小由内容撑开，


可以使用 padding，margin 上下不生效

 ...`,l:"Interview/CSS/Display.html",a:"inline"},"21.1":{t:"block",p:`
使元素变成块级元素，独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度
能够改变元素的 height、weight
可以使用 padding，margin

`,l:"Interview/CSS/Display.html#block",a:"block"},"21.2":{t:"inline-block",p:`
可以和其他元素共占一行
可以设置 weight、height
可以设置 padding、margin

`,l:"Interview/CSS/Display.html#inline-block",a:"inline-block"},"21.3":{t:"none",p:`不显示
`,l:"Interview/CSS/Display.html#none",a:"none"},"21.4":{t:"flex",p:`弹性盒子布局
`,l:"Interview/CSS/Display.html#flex",a:"flex"},"22.0":{t:"flex-实际上是-flex-grow-1-、-flex-shrink-1-和-flex-basis-0-三个属性的缩写。",p:`

flex-grow：定义项目的的放大比例；

默认为0，如果存在剩余空间，元素也不会放大，设置为 1，代表会放大，等分剩余空间
flex-grow为n的项目，占据的空间（放大的比例）是flex-g ...`,l:"Interview/CSS/flex1.html",a:"flex-实际上是-flex-grow-1-、-flex-shrink-1-和-flex-basis-0-三个属性的缩写。"},"23.0":{t:"采用-flex-布局的元素-称为-flex-容器-它的所有子元素自动成为容器成员-容器中默认存在两条轴-主轴和交叉轴-项目默认沿主轴排列",p:"\r",l:"Interview/CSS/flex布局.html",a:"采用-flex-布局的元素-称为-flex-容器-它的所有子元素自动成为容器成员-容器中默认存在两条轴-主轴和交叉轴-项目默认沿主轴排列"},"23.1":{t:"容器属性",p:`
flex-direction：决定主轴的方向，row-reverse：主轴为水平方向，起点在左端，column：主轴为垂直方向，起点在上沿，column-reverse：主轴为垂直方向，起点在下沿
 ...`,l:"Interview/CSS/flex布局.html#容器属性",a:"容器属性"},"23.2":{t:"容器成员属性",p:`
order：项目排列顺序，数值越小越靠前，默认为 0
flex-grow：如果不换行，容器宽度不够分的情况，弹性元素会根据这个来决定，项目的放大比例，默认为 0，即使存在剩余空间，也不放大，如果所有 ...`,l:"Interview/CSS/flex布局.html#容器成员属性",a:"容器成员属性"},"24.0":{t:"_1-import-是-css-提供的语法规则-只有导入样式表的作用-link-是-html-提供的标签-不仅可以加载-css-文件-还可以定义-rss、rel-连接属性等。",p:`
加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。
@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作 ...`,l:"Interview/CSS/link和@import.html",a:"_1-import-是-css-提供的语法规则-只有导入样式表的作用-link-是-html-提供的标签-不仅可以加载-css-文件-还可以定义-rss、rel-连接属性等。"},"25.0":{t:"margin-重叠指的是在垂直方向上-两个相邻元素的-margin-发生重叠的情况。",p:`一般来说可以分为四种情形：

第一种是相邻兄弟元素的 marin-bottom 和 margin-top 的值发生重叠。这种情况下我们可以通过设置其中一个元素为 BFC 来解决。
第二种是父元素的 m ...`,l:"Interview/CSS/margin重叠问题.html",a:"margin-重叠指的是在垂直方向上-两个相邻元素的-margin-发生重叠的情况。"},"26.0":{t:"absolute",p:`生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。如果不存在逐级向上查找，直到相对于 body 元素，即相对于浏览器窗口
`,l:"Interview/CSS/Position.html",a:"absolute"},"26.1":{t:"fixed",p:`生成绝对定位的元素，相对于浏览器窗口进行定位
`,l:"Interview/CSS/Position.html#fixed",a:"fixed"},"26.2":{t:"relative",p:`生成相对定位的元素，相对于其正常位置进行定位
`,l:"Interview/CSS/Position.html#relative",a:"relative"},"26.3":{t:"static",p:`默认值，没有定位
`,l:"Interview/CSS/Position.html#static",a:"static"},"26.4":{t:"inherit",p:`规定应该从父元素继承 position 的值
`,l:"Interview/CSS/Position.html#inherit",a:"inherit"},"27.0":{t:"rem-单位是根据根元素的-font-size-来计算",p:`
em：单位是根据自身元素的 font-size 大小来计算
vh：viewport width 视口的宽
vw：viewport height 视口的高

`,l:"Interview/CSS/rem-em-vw-vh.html",a:"rem-单位是根据根元素的-font-size-来计算"},"28.0":{t:"图像质量-svg-使用矢量图形-可以无限放大而不失真-canvas-使用像素图形-图像不可以无限放大不失真",p:`
编辑和修改：SVG 使用 XML 文档来描述图形，可以通过 JavaScript 和 CSS 来修改和操作，而 Canvas 使用 JavaScript 来绘制图形，需要重新绘制才能进行修改
适用场 ...`,l:"Interview/CSS/SVG - Canvas.html",a:"图像质量-svg-使用矢量图形-可以无限放大而不失真-canvas-使用像素图形-图像不可以无限放大不失真"},"29.0":{t:"transition",p:`只能定义两个状态：开始状态和结束状态，不能定义中间的状态

不能重复执行动画，除非一再触发动画

需要在特定状态触发后才能执行

animation
可以用@keyframes定义动画序列

可以设置 ...`,l:"Interview/CSS/transition-animation.html",a:"transition"},"30.0":{t:"一栏固定宽度-右边一栏宽度自适应-1-利用浮动-左边元素定宽-200px-向左浮动-float-left-右边元素-margin-left-200px-宽度设置为-auto-默认为-auto-撑满整个盒子",p:`.left {
  width: 200px;
  float: left;
  background-color: tomato;
}

.right {
  margin-left: 200px; ...`,l:"Interview/CSS/两栏布局.html",a:"一栏固定宽度-右边一栏宽度自适应-1-利用浮动-左边元素定宽-200px-向左浮动-float-left-右边元素-margin-left-200px-宽度设置为-auto-默认为-auto-撑满整个盒子"},"31.0":{t:"伪类",p:`用于当已有元素处于某个状态时，为其添加对应的部分，这个状态是根据用户行为而动态变化的，比如说，当用户悬停在指定的元素时，我们可以通过：hover 来描述这个元素的状态。双冒号，不会生成新的元素
伪元素 ...`,l:"Interview/CSS/伪类-伪元素.html",a:"伪类"},"32.0":{t:"_1-display-none-把元素隐藏起来-使元素完全从渲染树中消失-不占据任何空间-会改变页面布局-可以理解为在页面中把该元素删掉-非继承属性-子孙节点消失是因为元素本身从渲染树中消失-修改子孙节点的属性无法使其显示-会导致重排-读屏器不会读取-display-none-元素的内容",p:`
visibility:hidden 把元素隐藏起来，不会使元素从渲染树中消失，不会改变页面布局，不会触发该元素已经绑定的事件 继承属性，子孙节点消失是继承了 hidden 属性，可以通过设置 vis ...`,l:"Interview/CSS/使元素消失的方法.html",a:"_1-display-none-把元素隐藏起来-使元素完全从渲染树中消失-不占据任何空间-会改变页面布局-可以理解为在页面中把该元素删掉-非继承属性-子孙节点消失是因为元素本身从渲染树中消失-修改子孙节点的属性无法使其显示-会导致重排-读屏器不会读取-display-none-元素的内容"},"33.0":{t:"_1-display-table-cell-vertial-align-middle",p:`
flex 布局，align-item：center
绝对定位中，bottom：0，top：0，margin：auto
绝对定位中，固定宽高时设置 top：50%，margin-top 为-1/2he ...`,l:"Interview/CSS/垂直居中.html",a:"_1-display-table-cell-vertial-align-middle"},"34.0":{t:"dns-预解析",p:`TCP 预连接
骨架屏
资源预加载
接口预加载
接口合并
`,l:"Interview/CSS/怎么减少白屏时间.html",a:"dns-预解析"},"35.0":{t:"fouc-指的是在页面加载过程中-由于外部样式表加载较慢或延迟-导致页面先以无样式的方式显示-然后突然闪烁出样式的现象",p:`解决：

将样式表放在文档的 head 中：通过将样式表放在文档头部，确保浏览器在渲染页面内容之前先加载和解析样式表，从而避免了页面一开始的无样式状态
使用内联样式：关键样式直接写在 HTML 标签的 ...`,l:"Interview/CSS/怎么避免FOUC.html",a:"fouc-指的是在页面加载过程中-由于外部样式表加载较慢或延迟-导致页面先以无样式的方式显示-然后突然闪烁出样式的现象"},"36.0":{t:"多数显示屏默认频率是-60hz-就是-1s-刷新-60-次-所以理论上最小时间是-16-7ms-1-60-1000-如果需要手写编写动画-可以将最小时间间隔设置为-16-7ms-这样可以确保每帧动画能够在显示器刷新之前完成-如果时间间隔小于-16-7ms-则会导致某些帧在显示器刷新之后才能呈现-造成不连续的动画效果-出现跳帧现象",p:"",l:"Interview/CSS/手写动画最小间隔.html",a:"多数显示屏默认频率是-60hz-就是-1s-刷新-60-次-所以理论上最小时间是-16-7ms-1-60-1000-如果需要手写编写动画-可以将最小时间间隔设置为-16-7ms-这样可以确保每帧动画能够在显示器刷新之前完成-如果时间间隔小于-16-7ms-则会导致某些帧在显示器刷新之后才能呈现-造成不连续的动画效果-出现跳帧现象"},"37.0":{t:"单行",p:`div {
  width: 200px;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

多行
di ...`,l:"Interview/CSS/文字溢出.html",a:"单行"},"38.0":{t:"_1-子绝父相-transform",p:`.box {
  background-color: red;
  width: 100%;
  height: 100vh;
  position: relative;
}

.son {
  ba ...`,l:"Interview/CSS/水平垂直居中.html",a:"_1-子绝父相-transform"},"39.0":{t:"_1-元素为行内元素-设置父元素-text-align-center",p:`
如果元素宽度固定，可以设置左右 margin 为 auto
如果元素宽度固定，通过使用绝对定位，以及设置元素 margin-left 为其宽度的一半
如果元素为绝对定位，设置父元素 position ...`,l:"Interview/CSS/水平居中.html",a:"_1-元素为行内元素-设置父元素-text-align-center"},"40.0":{t:"为什么要清除浮动",p:"为什么要清除浮动？ 浮动元素脱离了标准文档流，变成了浮动元素，不再向父元素汇报高度。所以父元素在计算高度的时候并没有将浮动元素的高度计算出来，因此就造就了高度塌陷的问题。解决高度塌陷的问题就叫做清除浮 ...",l:"Interview/CSS/浮动.html",a:"为什么要清除浮动"},"40.1":{t:"怎么清除",p:`

clear 属性

在浮动元素后添加一个空元素，对其设置 clear：both
优点：简单、代码少，浏览器兼容性好
缺点：需要添加大量无语义的代码，代码不够优雅，后期不容易维护



原理：元素的 ...`,l:"Interview/CSS/浮动.html#怎么清除",a:"怎么清除"},"41.0":{t:"原理",p:`相邻边框连接处的均分原理，将元素的宽高设置为 0，只设置 border，把任意三边隐藏掉，剩下的就是一个三角形
`,l:"Interview/CSS/画三角形.html",a:"原理"},"41.1":{t:"实现",p:`.test {
  width: 0;
  height: 0;
  border-top: 50px solid transparent;
  border-right: 50px solid tr ...`,l:"Interview/CSS/画三角形.html#实现",a:"实现"},"42.0":{t:"在标准的-css-盒子模型中-每个-html-元素被表示为一个矩形盒子",p:`盒子包括四个部分：

内存区域 content
内边距区域 padding
边框区域 border
外边距区域 margin

标准盒模型
计算宽高时，只包括内容区域
IE 盒模型
计算宽高时，包含内 ...`,l:"Interview/CSS/盒模型.html",a:"在标准的-css-盒子模型中-每个-html-元素被表示为一个矩形盒子"},"43.0":{t:"原因",p:`由于 HTML 中的换行符和空格字符引起的，这些空白字符会被解析为文本节点，而文本节点默认会应用一定的样式，导致 li 之间产生间隔
`,l:"Interview/CSS/空白间隔问题.html",a:"原因"},"43.1":{t:"解决",p:`

删除 HTML 代码中的空白字符


使用 flex 布局，将 ul 设置为 flex 容器，使 li 自动排列在一行内，间隔消失


父元素设置 font-size:0，子元素重新设置字体大小和 ...`,l:"Interview/CSS/空白间隔问题.html#解决",a:"解决"},"44.0":{t:"id-选择器",p:`类选择器
标签选择器
属性选择器
伪类选择器
伪元素选择器
后代选择器
相邻后代选择器
兄弟选择器
通配符选择器
`,l:"Interview/CSS/选择器.html",a:"id-选择器"},"44.1":{t:"优先级",p:`
同一级别：就近原则 后写的覆盖先写的
不同级别：
!important &gt; 内联样式 &gt; ID选择器 &gt; 类选择器 = 属性选择器 = 伪类选择器 &gt; 标签选择器 = 伪元素 ...`,l:"Interview/CSS/选择器.html#优先级",a:"优先级"},"45.0":{t:"前者是标准浏览器中的用法-后者-ie8-以下",p:`
addEventListener可有冒泡，可有捕获；attachEvent只有冒泡，没有捕获。
前者事件名不带on，后者带on
前者回调函数中的this指向当前元素，后者指向window
第三个参数 ...`,l:"Interview/HTML/addEventListener-attachEvent.html",a:"前者是标准浏览器中的用法-后者-ie8-以下"},"46.0":{t:"为什么需要-async-和-defer",p:`js 是单线程的,如果没有 defer 或 async 属性,浏览器会立即加载并执行相应的脚本,不会等到后续加载的文档元素,读取到就会开始和执行,会阻塞后续文档的加载
defer 和 async 都是 ...`,l:"Interview/HTML/async和defer的区别.html",a:"为什么需要-async-和-defer"},"47.0":{t:"a-元素除了导航外-还有什么作用",p:`创建内部书签链接，在 href 中指定锚点的 ID 来实现
添加 download 属性 变为下载链接
`,l:"Interview/HTML/a标签.html",a:"a-元素除了导航外-还有什么作用"},"48.0":{t:"h5-新特性",p:`
为了更好的实现语义化，新增了 header、footer、nav、aside、article 等语义化标签
为了方便在客户端存储和获取数据，提供了 localStorage、sessionStora ...`,l:"Interview/HTML/H5新特性.html",a:"h5-新特性"},"49.0":{t:"优点",p:`
内容隔离：允许在一个网页中嵌套另一个网页，实现内容隔离，防止嵌套的内容对主页面的影响。
并行加载：允许在主页面加载的时候并行加载嵌套页面，提高页面并发性能。
代码复用：可以将共享的内容嵌套在多个页面 ...`,l:"Interview/HTML/iframe的优缺点.html",a:"优点"},"50.0":{t:"定义表单控件的关系-当用户选择-label-标签时-浏览器会自动将焦点转到和-label-标签相关的表单控件上",p:"&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;m ...",l:"Interview/HTML/label有什么作用.html",a:"定义表单控件的关系-当用户选择-label-标签时-浏览器会自动将焦点转到和-label-标签相关的表单控件上"},"51.0":{t:"相同点",p:`都是告知浏览器提前加载文件(图片、视频、js、css等)，但执行上是有区别的。
区别

prefetch预取：prefetch 是一个资源提示属性，用于告诉浏览器在页面加载完成后，异步地预取指定资源。 ...`,l:"Interview/HTML/prefetch-preload.html",a:"相同点"},"52.0":{t:"src",p:`
src 用于替换的当前元素
src用于指定外部资源的地址，通常用于引入外部文件，如图片、音频、视频、脚本等，指向的内容会嵌入到文档中当前标签所在的位置。
常用于&lt;img&gt;, &lt;sc ...`,l:"Interview/HTML/src和href的区别.html",a:"src"},"53.0":{t:"怎么实现浏览器内多个标签的通信",p:"\r",l:"Interview/HTML/浏览器内多个标签通信.html",a:"怎么实现浏览器内多个标签的通信"},"53.1":{t:"websocket",p:`

建立 WebSocket 连接，const socket = new WebSocket('ws://your-server-url')


监听消息事件：socket.addEventListe ...`,l:"Interview/HTML/浏览器内多个标签通信.html#websocket",a:"websocket"},"53.2":{t:"localstorage",p:`使用 localStorage，在一个标签页内使用 localStorage.setItem(key,value)内容，在另一个标签页里面监听 storage 事件
// 标签页1
&lt;input ...`,l:"Interview/HTML/浏览器内多个标签通信.html#localstorage",a:"localstorage"},"53.3":{t:"cookie-setinterval",p:`将要传递的消息存储在 cookie 中，每隔一段时间读取 cookie 信息
// 页面1
&lt;input id=&quot;name&quot;&gt;
&lt;input type=&quot ...`,l:"Interview/HTML/浏览器内多个标签通信.html#cookie-setinterval",a:"cookie-setinterval"},"54.0":{t:"对语义化的理解",p:"\r",l:"Interview/HTML/语义化的理解.html",a:"对语义化的理解"},"54.1":{t:"你是怎么理解语义化的-语义化的好处",p:`我认为 html 语义化主要指的是我们应该用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页内容的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。
这样不仅有利于开发者 ...`,l:"Interview/HTML/语义化的理解.html#你是怎么理解语义化的-语义化的好处",a:"你是怎么理解语义化的-语义化的好处"},"54.2":{t:"常见的语义化标签有哪些",p:`
header：页眉，网站标题、导航菜单等
nav：导航部分，通常包含网站的主要导航链接
main：主要内容区域
article：内容块、比如新闻文章、博客帖子等
aside：侧边栏
footer：页 ...`,l:"Interview/HTML/语义化的理解.html#常见的语义化标签有哪些",a:"常见的语义化标签有哪些"},"55.0":{t:"面试",p:`:::tip
面试题总结与归纳!
:::
`,l:"Interview/index.html",a:"面试"},"56.0":{t:"_1-块级作用域-引入-let-和-const-关键字-允许在块级作用域中声明变量-解决了变量提升和作用域污染的问题。",p:`
箭头函数：使用箭头(=&gt;)定义函数，简化了函数的书写，并且自动绑定了this。
模板字符串：使用反引号（\`）包裹字符串，可以在字符串中使用变量和表达式，实现更灵活的字符串拼接和格式化。
解构赋 ...`,l:"Interview/JavaScript/ES6.html",a:"_1-块级作用域-引入-let-和-const-关键字-允许在块级作用域中声明变量-解决了变量提升和作用域污染的问题。"},"57.0":{t:"作为浏览器脚本语言-javascript-的主要用途是和用户交互以及操作-dom-所以只能是单线程-如果不是单线程-会带来很复杂的同步问题-比如一个线程在-dom-节点上添加内容-另一个线程删除节点-此时浏览器不知道以那个为准。",p:`同一个时间只能做一件事。所有任务都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着
所有任务可以分成两种，一种是宏任务，另一种是微任务
宏任务指的是，在 ...`,l:"Interview/JavaScript/EventLoop.html",a:"作为浏览器脚本语言-javascript-的主要用途是和用户交互以及操作-dom-所以只能是单线程-如果不是单线程-会带来很复杂的同步问题-比如一个线程在-dom-节点上添加内容-另一个线程删除节点-此时浏览器不知道以那个为准。"},"58.0":{t:"this-的绑定方式",p:`
默认绑定，非严格模式下 this 指向全局对象，严格模式下函数内的 this 指向 undefined，但是不会改变全局中 this 的指向
隐式绑定，当函数引用有上下文对象的时候，比如 obj.f ...`,l:"Interview/JavaScript/this.html",a:"this-的绑定方式"},"59.0":{t:"如何阻止事件冒泡和默认事件",p:`
标准的 DOM 对象中可以使用事件对象的 stopPropagation()方法来阻止冒泡，在 IE8 以下中 IE 的事件对象通过设置事件对象的 cancleBubble 属性为 true 来阻止 ...`,l:"Interview/JavaScript/事件.html",a:"如何阻止事件冒泡和默认事件"},"59.1":{t:"事件捕获和冒泡",p:`事件捕获阶段 处于目标阶段 事件冒泡阶段
事件流是一个事件沿着特定数据结构传播的过程。冒泡和捕获是事件流在 DOM 中两种不同的传播方法

事件捕获：当鼠标点击或者触发 dom 事件时，浏览器会从根节 ...`,l:"Interview/JavaScript/事件.html#事件捕获和冒泡",a:"事件捕获和冒泡"},"60.0":{t:"什么是作用域",p:`作用域就是可访问变量的集合，做大的作用就是隔离变量，不同作用域下同名变量不会冲突
`,l:"Interview/JavaScript/作用域闭包.html",a:"什么是作用域"},"60.1":{t:"作用域的类型",p:`全局作用域、函数作用域和块级作用域
`,l:"Interview/JavaScript/作用域闭包.html#作用域的类型",a:"作用域的类型"},"60.2":{t:"函数作用域",p:`指的是声明在函数内部的变量，函数的作用域在函数定义的时候决定的
`,l:"Interview/JavaScript/作用域闭包.html#函数作用域",a:"函数作用域"},"60.3":{t:"块作用域",p:`块作用域由 {}包括，if 和 for 语句中的{}也属于块作用域
在块级作用域中，可以通过 let 和 const 声明变量，这个变量在块级作用域外无法被访问
`,l:"Interview/JavaScript/作用域闭包.html#块作用域",a:"块作用域"},"60.4":{t:"var-let-const-区别",p:`var：没有块级作用域概念，可以跨块访问，会变量提升
let：只能在块作用域中访问，不能跨块访问，也不能跨函数访问，没有变量提升，不能重复声明
const：用来定义常量，声明时必须赋值，只能在块级作用 ...`,l:"Interview/JavaScript/作用域闭包.html#var-let-const-区别",a:"var-let-const-区别"},"60.5":{t:"作用域链",p:"当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级的执行上下文的变量对象中查找，如果还没有找到，一直找到全局上下文的变量对象，也就是全局对象。这种由多个执行上下文的变量对象构 ...",l:"Interview/JavaScript/作用域闭包.html#作用域链",a:"作用域链"},"60.6":{t:"闭包",p:`有权访问另外一个函数作用域中的变量的函数，主要的就两点，一是是一个函数，二是能访问另外一个函数作用域中的变量
闭包的特性：

可以访问当前函数以外的变量
即使外部函数已经返回，闭包仍然能访问外部函数定 ...`,l:"Interview/JavaScript/作用域闭包.html#闭包",a:"闭包"},"61.0":{t:"原型的作用",p:`原型被定义为给其它对象提供共享属性的对象，函数的实例可以共享原型上的属性和方法
`,l:"Interview/JavaScript/原型-原型链.html",a:"原型的作用"},"61.1":{t:"原型链",p:"作用就是当你在访问一个对象上的属性的时候，如果该对象内部不存在这个属性，那么就会去它的proto属性所指向的原型对象上查找，如果依旧不存在，就会去原型的proto属性所指向的原型对象上去查找，直到找到 ...",l:"Interview/JavaScript/原型-原型链.html#原型链",a:"原型链"},"61.2":{t:"原型链和作用域链的区别",p:`原型链是查找对象上的属性，作用域链是查找当前上下文中的变量
`,l:"Interview/JavaScript/原型-原型链.html#原型链和作用域链的区别",a:"原型链和作用域链的区别"},"61.3":{t:"proto、prototype、constructor",p:`
js 对象分为两种，普通对象和函数对象
proto 和 constructor 是对象独有的，prototype 是函数对象独有的，作用是给特定类型的所有实例提供共享的属性和方法，但是在 js 中， ...`,l:"Interview/JavaScript/原型-原型链.html#proto、prototype、constructor",a:"proto、prototype、constructor"},"62.0":{t:"什么是内存泄漏",p:`
内存泄漏是指应当被回收的对象没有被正常回收,导致内存占用越来越高,会导致应用程序速度变慢,高延时,奔溃等问题

`,l:"Interview/JavaScript/垃圾回收.html",a:"什么是内存泄漏"},"62.1":{t:"内存泄漏的常见原因",p:`
创建全局变量
被遗忘的计时器或回调函数
闭包
脱离 DOM 的引用

JavaScript 有自动的垃圾回收机制，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内 ...`,l:"Interview/JavaScript/垃圾回收.html#内存泄漏的常见原因",a:"内存泄漏的常见原因"},"62.2":{t:"标记清除方法",p:`
标记阶段：垃圾回收器从根对象开始遍历，每一个可以从根对象访问到的对象都会被添加一个标识，这个对象被标记为可到达对象
清除阶段：垃圾回收器对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达 ...`,l:"Interview/JavaScript/垃圾回收.html#标记清除方法",a:"标记清除方法"},"62.3":{t:"引用计数法",p:`将资源被引用的次数保存起来,当被引用次数为零时释放,局限性是当出现循环引用时,互相引用的对象不会被回收
`,l:"Interview/JavaScript/垃圾回收.html#引用计数法",a:"引用计数法"},"62.4":{t:"怎么防止内存泄漏",p:`
及时清除引用
使用 WeakMap 和 WeakSet，因为它们对于值的引用不计入垃圾回收机制

`,l:"Interview/JavaScript/垃圾回收.html#怎么防止内存泄漏",a:"怎么防止内存泄漏"},"63.0":{t:"什么是执行上下文",p:`当前 JavaScript 代码被解析和执行所在环境的抽象概念
JavaScript 代码都是在执行上下文中运行的，执行上下文就是指当前环境中的变量、函数声明、作用域链、this 等信息
`,l:"Interview/JavaScript/执行上下文和执行栈.html",a:"什么是执行上下文"},"63.1":{t:"执行上下文分类",p:`
全局执行上下文：只有一个，浏览器环境下为 window
函数执行上下文：存在无数个，每当一个函数被调用时，都会为该函数创建一个新的上下文
eval 执行上下文：运行在 eval 函数中的代码

对于 ...`,l:"Interview/JavaScript/执行上下文和执行栈.html#执行上下文分类",a:"执行上下文分类"},"63.2":{t:"执行上下文的特点",p:`
单线程，只在主线程上运行
同步执行，从上向下按顺序执行
全局上下文只有一个，也就是 window 对象
函数每调用一次就会产生一个新的执行上下文环境

`,l:"Interview/JavaScript/执行上下文和执行栈.html#执行上下文的特点",a:"执行上下文的特点"},"63.3":{t:"什么是执行栈",p:`是一种先进后出的数据结构，用来存储代码运行的所有执行上下文

当 JS 引擎第一次遇到 js 脚本时，会创建一个全局的执行上下文并压入当前执行栈
每当 JS 引擎调用一个函数的时候，会为该函数创建一个 ...`,l:"Interview/JavaScript/执行上下文和执行栈.html#什么是执行栈",a:"什么是执行栈"},"63.4":{t:"执行上下文的生命周期",p:`主要分为两个阶段：
1.创建阶段：在这个阶段生成变量对象，建立作用域链，确定 this 指向
2.执行阶段：对变量进行赋值，函数引用，执行其它代码
`,l:"Interview/JavaScript/执行上下文和执行栈.html#执行上下文的生命周期",a:"执行上下文的生命周期"},"63.5":{t:"什么是变量对象",p:`变量对象是和执行上下文相关的数据作用域，存储了上下文中定义的变量和函数声明
是一个抽象的概念，在全局执行上下文中，变量对象就是全局对象，在顶层 js 代码中，this 指向全局对象，全局变量会作为该对 ...`,l:"Interview/JavaScript/执行上下文和执行栈.html#什么是变量对象",a:"什么是变量对象"},"64.0":{t:"javascript-是什么语言",p:`JavaScript 是一种弱类型（可以发生隐式类型转换）、动态的语言


动态语言：在运行过程中需要检查数据类型的语言


静态语言：在使用之前就需要确认其变量数据类型的语言


`,l:"Interview/JavaScript/数据类型.html",a:"javascript-是什么语言"},"64.1":{t:"js-都有什么数据类型",p:`基本数据类型：string、number、boolean、null、undefined、symbol（ES6 新增）、bigint（ES10 新增）
引用数据类型：object （普通对象-objec ...`,l:"Interview/JavaScript/数据类型.html#js-都有什么数据类型",a:"js-都有什么数据类型"},"64.2":{t:"为什么要新增-symbol",p:"主要是为了解决全局变量冲突的问题，比如定义了一个全局对象，用来缓存数据，现在有两个 js 文件需要往这个对象中添加键名，由于 js 文件在不同模块，所以可能添加相同的键名，就会出现冲突的问题，所以 S ...",l:"Interview/JavaScript/数据类型.html#为什么要新增-symbol",a:"为什么要新增-symbol"},"64.3":{t:"如果想要复用一个-symbol-该怎么操作",p:`使用Symbol.for('字符串')，传入相同的字符串，一定会返回相同的 symbol 类型的值
使用 symbol 值作为对象的属性名，通过 for in、Object.keys 都是获取不到的， ...`,l:"Interview/JavaScript/数据类型.html#如果想要复用一个-symbol-该怎么操作",a:"如果想要复用一个-symbol-该怎么操作"},"64.4":{t:"为什么要新增-bigint-作用是什么",p:`支持比 Number 数据类型支持的范围更大的整数值
创建 bigint，只需要在数字末尾追加 n 或者使用 BigInt()构造函数来创建
`,l:"Interview/JavaScript/数据类型.html#为什么要新增-bigint-作用是什么",a:"为什么要新增-bigint-作用是什么"},"64.5":{t:"null-和-undefined-的区别",p:`

null
空值 语义是表示一个对象被认为的重置为空对象，不是一个变量最原始的状态，使用场景

明确定义的变量在将来是用于保存对象的，就应该将这个变量初始化为 null，有助于区分 null 和 u ...`,l:"Interview/JavaScript/数据类型.html#null-和-undefined-的区别",a:"null-和-undefined-的区别"},"64.6":{t:"null-是对象吗-为什么",p:`typeof null == 'object'
从逻辑上来看，null 值表示一个空对象指针，代表的其实就是一个空对象
在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型 ...`,l:"Interview/JavaScript/数据类型.html#null-是对象吗-为什么",a:"null-是对象吗-为什么"},"64.7":{t:"javascript-数据如何存储",p:`基本数据类型用栈存储，栈内存的特点的分配固定大小的内存空间，可以快速分配和释放，而基本数据类型的值是不可变的，所以可以存储在栈中，可以直接访问和复制
引用数据类型用堆存储，堆内存是动态分配，可以容纳各 ...`,l:"Interview/JavaScript/数据类型.html#javascript-数据如何存储",a:"javascript-数据如何存储"},"64.8":{t:"判断数据类型的方法",p:`
typeof：可以判断除了 null 之外的原始数据类型，判断 null 为 object，对于引用类型，会判断为 function 和 object 两种类型 直接在计算机底层基于数据类型的二进制 ...`,l:"Interview/JavaScript/数据类型.html#判断数据类型的方法",a:"判断数据类型的方法"},"64.9":{t:"怎么判断一个数组",p:`
instanceof方法：使用instanceof运算符判断对象是否为数组，返回布尔值。例如：arr instanceof Array。
constructor方法：使用constructor属性返 ...`,l:"Interview/JavaScript/数据类型.html#怎么判断一个数组",a:"怎么判断一个数组"},"64.10":{t:"如何判断一个对象是否为空",p:`
Object.keys() Object.keys(obj).length === 0
for in 循环，if (obj.hasOwnProperty(key)) {return false}
J ...`,l:"Interview/JavaScript/数据类型.html#如何判断一个对象是否为空",a:"如何判断一个对象是否为空"},"64.11":{t:"为什么没-0-1-0-2-0-3-怎么解决",p:`原因：

当计算机计算 0.1+0.2 的时候，实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。js 中是以 64 位双精度格式 ...`,l:"Interview/JavaScript/数据类型.html#为什么没-0-1-0-2-0-3-怎么解决",a:"为什么没-0-1-0-2-0-3-怎么解决"},"64.12":{t:"isnan-和-number-isnan-函数的区别",p:`isNaN
接收参数后,会尝试将这个参数转换成数值,任何不能被转换成数值的值都会返回 true,因此非数字值传入也会返回 true,会影响 NaN 的判断
Number.isNaN
会首先判断传入参数 ...`,l:"Interview/JavaScript/数据类型.html#isnan-和-number-isnan-函数的区别",a:"isnan-和-number-isnan-函数的区别"},"64.13":{t:"object-is-和-的区别",p:`== 两边类型不一致,会进行强制类型转换再进行比较
=== 如果两边的类型不一致,不会做强制类型转换,直接返回 false
Object.is 一般情况下和===相同,处理了一些特殊的情况 比如-0  ...`,l:"Interview/JavaScript/数据类型.html#object-is-和-的区别",a:"object-is-和-的区别"},"64.14":{t:"为什么",p:`隐式类型转换
转换过程：

[]转换成数字 0
！[]首先转换成布尔值 false，再转换成数字为 0

`,l:"Interview/JavaScript/数据类型.html#为什么",a:"为什么"},"64.15":{t:"如何让-if-a-1-a-2-成立",p:`var a = {
  value: 0,
  valueOf: function () {
    this.value++;
    return this.value;
  },
};

`,l:"Interview/JavaScript/数据类型.html#如何让-if-a-1-a-2-成立",a:"如何让-if-a-1-a-2-成立"},"64.16":{t:"quot-1-quot-quot-2-quot-quot-3-quot-map-parseint-答案是多少",p:`
答案 [1, NaN, NaN] ​
parseInt 第一个参数str，即要解析的字符串
parseInt 第二个参数radix，基数（进制），范围2-36 ，以radix进制的规则去解析str字 ...`,l:"Interview/JavaScript/数据类型.html#quot-1-quot-quot-2-quot-quot-3-quot-map-parseint-答案是多少",a:"quot-1-quot-quot-2-quot-quot-3-quot-map-parseint-答案是多少"},"64.17":{t:"set、weakset、map、weakmap-的区别",p:`Set

成员不能重复
只有健值，没有健名，有点类似数组。
可以遍历，方法有 add, delete,has

WeakSet

成员都是对象
成员都是弱引用，随时可以消失。 可以用来保存 DOM 节 ...`,l:"Interview/JavaScript/数据类型.html#set、weakset、map、weakmap-的区别",a:"set、weakset、map、weakmap-的区别"},"65.0":{t:"ajax",p:`是一种异步通信的方法，通过直接由 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法
用途：无刷新获取服务器数据


优点：

通过异步 ...`,l:"Interview/JavaScript/网络请求.html",a:"ajax"},"65.1":{t:"axios、ajax、fetch-的区别",p:`
ajax 是一种技术统称，基于原生的 XHR 开发，已经有了 fetch 的替代方案。
fetch 是一个原生的 API，用于进行网络请求，支持 Promise API，但在某些方面功能较为简单，需 ...`,l:"Interview/JavaScript/网络请求.html#axios、ajax、fetch-的区别",a:"axios、ajax、fetch-的区别"},"66.0":{t:"_28-cdn",p:"&gt; CDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或者网络中，在用户访问网站的时候，将其指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请 ...",l:"Interview/network/CDN.html",a:"_28-cdn"},"67.0":{t:"检查浏览器中是否缓存过该域名对应的-ip-地址",p:`
如果浏览器缓存中没有命中，将继续查找本级（操作系统）是否缓存过该 IP
向本地域名解析服务系统发起域名解析的请求（一般是本地运营商的机房）
向根域名解析服务器发起域名解析服务请求
根域名服务器返回  ...`,l:"Interview/network/DNS.html",a:"检查浏览器中是否缓存过该域名对应的-ip-地址"},"68.0":{t:"_1-get-是从服务器获取指定的资源-post-是根据请求报文对指定的资源做出处理",p:`
get 请求的参数一般放在 URL 中，浏览器对 URL 的长度有限制；post 请求携带的参数一般是写在 body 报文中，没有限制
get 请求是安全且幂等的，无论操作多少次，服务器上的数据都是 ...`,l:"Interview/network/get-post.html",a:"_1-get-是从服务器获取指定的资源-post-是根据请求报文对指定的资源做出处理"},"69.0":{t:"区别",p:`HTTP 是超文本传输协议，明文传输，存在安全风险的问题，HTTPS 是为了解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TSL 安全协议，使得报文能够密文传输
H ...`,l:"Interview/network/HTTP-HTTPS.html",a:"区别"},"69.1":{t:"https-解决了哪些问题",p:`HTTP 存在的问题：窃听风险：（通信链路上可以获取通信内容，用户信息容易泄露），篡改风险：（强制植入垃圾广告），冒充风险
HTTPS 在 HTTP 和 TCP 之间加入了 SSL/TSL 协议，将信 ...`,l:"Interview/network/HTTP-HTTPS.html#https-解决了哪些问题",a:"https-解决了哪些问题"},"69.2":{t:"混合加密",p:`通过混合加密的方法保证信息的机密性，采用对称加密和非对称加密的方式在通信建立前采用非对称加密的方式交换会话密钥，在通信过程中使用对称加密的方式进行加密明文数据
`,l:"Interview/network/HTTP-HTTPS.html#混合加密",a:"混合加密"},"69.3":{t:"https-握手过程",p:`
第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法
第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数
第三步 ...`,l:"Interview/network/HTTP-HTTPS.html#https-握手过程",a:"https-握手过程"},"69.4":{t:"对称加密和非对称加密",p:`
对称加密： 对称加密指的就是加密和解密使用同一个秘钥，所以叫做对称加密。对称加密只有一个秘钥。
非对称加密: 加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才 ...`,l:"Interview/network/HTTP-HTTPS.html#对称加密和非对称加密",a:"对称加密和非对称加密"},"69.5":{t:"怎么实现-token-加密",p:`
需要一个 secret（随机数）
后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码) 生成一个字符串(token)，返回前端
前端每次 request  ...`,l:"Interview/network/HTTP-HTTPS.html#怎么实现-token-加密",a:"怎么实现-token-加密"},"70.0":{t:"http1-1",p:"\r",l:"Interview/network/HTTP1.html",a:"http1-1"},"70.1":{t:"优点",p:`简单、灵活和好扩展、应用广泛和跨平台
简单：HTTP 的基本报文格式就是 header+body，头部信息也是 key-value 简单文本的形式，易于理解，学习和使用的门槛低
灵活和易于扩展：HTT ...`,l:"Interview/network/HTTP1.html#优点",a:"优点"},"70.2":{t:"缺点",p:`无状态、明文传输、不安全：浏览器不会记录 HTTP 的状态，当要完成有关联性的操作时会麻烦，可以使用 cookie 解决；明文传输，内容很容易被窃取；
`,l:"Interview/network/HTTP1.html#缺点",a:"缺点"},"70.3":{t:"性能",p:`基于 TCP/IP，使用请求-应答的通信模式
在 HTTP 1.0 中，每次发起一个请求，都要新建一次 TCP 链接，而且是串行请求，TCP 的连接和断开，增加了通信开销
HTTP1.0 为了解决这个 ...`,l:"Interview/network/HTTP1.html#性能",a:"性能"},"70.4":{t:"如何优化",p:`主要从以下三个方面来进行考虑：

尽量避免发送 HTTP 请求
在需要发送 HTTP 请求的时候，考虑如何减少 HTTP 请求数
减少服务器的 HTTP 响应的数据大小

避免发送 HTTP 请求
对 ...`,l:"Interview/network/HTTP1.html#如何优化",a:"如何优化"},"70.5":{t:"http2",p:"\r",l:"Interview/network/HTTP1.html#http2",a:"http2"},"70.6":{t:"有什么优点",p:"HTTP2 的出现是为了解决 HTTP1.1 存在的问题，HTTP1.1 中存在以下问题：并发连接有限（比如谷歌浏览器的最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TSL 握手的耗时 ...",l:"Interview/network/HTTP1.html#有什么优点",a:"有什么优点"},"71.0":{t:"host-客户端发送请求的时候-用于指定服务器的域名",p:`
Connection：用于客户端要求服务器使用 HTTP 长连接机制
Content-length：服务器在返回数据的时候，表示本次回应的数据长度
Content-Type：用于服务器回应时，告诉客 ...`,l:"Interview/network/HTTP常见字段有哪些.html",a:"host-客户端发送请求的时候-用于指定服务器的域名"},"72.0":{t:"概念",p:`当用户在身份认证服务器上登录过一次之后，即可获取访问单点登录系统中的其它关联系统和应用软件的权限。
实现机制：

当用户第一次访问应用系统 1 的时候，因为还没有登录，会被引导到认证系统中进行登录；根 ...`,l:"Interview/network/SSO单点登录.html",a:"概念"},"73.0":{t:"为什么会有-tcp-ip-协议",p:`同一台设备进程之间进行通信，可以通过管道、共享内存、信号、消息队列等方式，而不同的设备之间想要进行通信，就需要网络进行通信，但是设备是多样性的，为了兼容多种设备，就协商出了一套通用的网络协议
`,l:"Interview/network/TCP-IP.html",a:"为什么会有-tcp-ip-协议"},"73.1":{t:"什么是-tcp",p:`面向连接的、可靠的、基于字节流的传输层通信协议
面向连接：一对一
可靠的：保证一个报文一定能到达接收端
字节流
`,l:"Interview/network/TCP-IP.html#什么是-tcp",a:"什么是-tcp"},"73.2":{t:"tcp-ip-网络模型有几层",p:`应用层：
应用层处于最上层，用户能够直接接触到的就是应用层，比如手机和电脑上的软件。应用层的作用主要就是产生数据，将数据传给传输层。应用层工作在系统的用户态，而传输层之下的工作在内核态
传输层：
应用 ...`,l:"Interview/network/TCP-IP.html#tcp-ip-网络模型有几层",a:"tcp-ip-网络模型有几层"},"73.3":{t:"tcp-头格式有哪些",p:`序列号：在建立连接的时候由计算机生成的随意数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就累加一次该数据字节数的大小。用来解决网络包乱序的问题
确认应答号：指下一次期望收到的数据的序 ...`,l:"Interview/network/TCP-IP.html#tcp-头格式有哪些",a:"tcp-头格式有哪些"},"73.4":{t:"为什么需要-tcp-协议-工作在那一层",p:`IP 层是不可靠的，不能保证网络包的交付，不保证网络包的按序交付，不保证网络包中数据的完整性。如果需要保证网络数据包的可靠性，需要 TCP 来负责，工作在传输层
`,l:"Interview/network/TCP-IP.html#为什么需要-tcp-协议-工作在那一层",a:"为什么需要-tcp-协议-工作在那一层"},"73.5":{t:"三次握手",p:`一开始，客户端和服务端都是 CLOSE 状态，先是服务端主动监听某个端口，处于 LISTEN 状态
客户端随机初始化序列号，把 SYN 标志置为 1，表示当前报文为 SYN 报文，然后把第一个 SYN ...`,l:"Interview/network/TCP-IP.html#三次握手",a:"三次握手"},"73.6":{t:"四次挥手",p:`
第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文 ...`,l:"Interview/network/TCP-IP.html#四次挥手",a:"四次挥手"},"73.7":{t:"ssl-断开连接后如何恢复",p:`通过 session ID：
使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以 ...`,l:"Interview/network/TCP-IP.html#ssl-断开连接后如何恢复",a:"ssl-断开连接后如何恢复"},"73.8":{t:"tcp-和-udp-区别",p:`
TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接
TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失， 不重复，且按序到达;UDP 尽最大努力交付，即 ...`,l:"Interview/network/TCP-IP.html#tcp-和-udp-区别",a:"tcp-和-udp-区别"},"74.0":{t:"_1xx",p:`提示信息，表示目前是协议处理的中间状态，还需要后续的操作
`,l:"Interview/network/常见状态码.html",a:"_1xx"},"74.1":{t:"_2xx",p:`成功，报文已经收到并且被正常处理
* 200 OK 最常见的成功状态码，表示一切正常
* 204  No Content  成功，但是响应头没有body数据
* 206 Partial Content ...`,l:"Interview/network/常见状态码.html#_2xx",a:"_2xx"},"74.2":{t:"_3xx",p:`表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向
* 301 Moved Permanently 永久重定向，说明请求的资源已经不存在了，需要用新的URL再 ...`,l:"Interview/network/常见状态码.html#_3xx",a:"_3xx"},"74.3":{t:"_4xx",p:`表示客户端发送的报文有误，服务器无法处理
* 400 表示客户端请求的报文有错误
* 403 Forbidden 表示服务器禁止访问资源，不是客户端的请求出错
* 404 Not Found 请求的资 ...`,l:"Interview/network/常见状态码.html#_4xx",a:"_4xx"},"74.4":{t:"_5xx",p:`客户端请求正确，但是服务器内部发生了错误
* 500 服务器发生错误
* 501 表示客户端请求的功能还不支持
* 502 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服 ...`,l:"Interview/network/常见状态码.html#_5xx",a:"_5xx"},"75.0":{t:"简单请求",p:`
GET
HEAD
POST
Content-Type： text / plain 、multipart / form-data 、application / x-www-form-urlencode ...`,l:"Interview/network/简单请求和复杂请求.html",a:"简单请求"},"76.0":{t:"短沦陷",p:`
浏览器每隔一段时间向服务器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应。
这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端 ...`,l:"Interview/network/长短轮询.html",a:"短沦陷"},"77.0":{t:"缓存",p:`缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单，效果显著的前端性能优化手段。
通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端和服务器之间进行多次往返通信，这会延迟浏 ...`,l:"Interview/Performance/存储篇.html",a:"缓存"},"77.1":{t:"强缓存",p:"强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目 ...",l:"Interview/Performance/存储篇.html#强缓存",a:"强缓存"},"77.2":{t:"协商缓存",p:`协商缓存依赖于浏览器和服务端之间的通信，协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源
如果服务端提示资源未改动，304 No ...`,l:"Interview/Performance/存储篇.html#协商缓存",a:"协商缓存"},"77.3":{t:"决策指南",p:"当我们的资源不可复用的时候，之间为 Cache-Control 为 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，设置为 no-cache，否则考虑该 ...",l:"Interview/Performance/存储篇.html#决策指南",a:"决策指南"},"77.4":{t:"本地存储",p:"\r",l:"Interview/Performance/存储篇.html#本地存储",a:"本地存储"},"77.5":{t:"cookie",p:`HTTP 是一个无状态协议，服务器接收客户端的请求，返回一个响应，然后就结束了，服务器没有记录任何关于客户端的任何信息，下次请求的时候，不知道客户端是谁
cookie 就是一个存储在浏览器中的很小的一 ...`,l:"Interview/Performance/存储篇.html#cookie",a:"cookie"},"77.6":{t:"localstorage",p:`持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法就是手动删除；常用于存储一些内容稳定的资源
`,l:"Interview/Performance/存储篇.html#localstorage",a:"localstorage"},"77.7":{t:"sessionstorage",p:"会话级别的存储，当会话结束（页面被关闭的时候）存储内容也会随之被释放；即便是相同域名下的两个窗口，只要不在同一个浏览器窗口中打开，那么它们的 SessionStorage 无法共享。存储只适用于当前会 ...",l:"Interview/Performance/存储篇.html#sessionstorage",a:"sessionstorage"},"77.8":{t:"indexdb",p:`运行在浏览器上的非关系型数据库。一般来说是没有存储上限的，不仅可以存储字符串，也可以存储二进制数据。
当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，可以使用 IndexDB
`,l:"Interview/Performance/存储篇.html#indexdb",a:"indexdb"},"77.9":{t:"cdn-的缓存和回源机制",p:`内容分发网络指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，所有服务器可以根据哪些服务器和用户距离最近，来满足数据的请求。
缓存、本都存储带来的性能提升，都是只能在拿到数据后存起来这件事 ...`,l:"Interview/Performance/存储篇.html#cdn-的缓存和回源机制",a:"cdn-的缓存和回源机制"},"78.0":{t:"懒加载",p:"针对图片加载时机的优化，在一些图片量比较大的网站，如果尝试在用户打开页面的时候，就把所有的图片资源加载完毕，那么很可能会造成白屏、卡顿等现象，因为图片太多了，浏览器可能做不到一次性处理那么多的任务。实 ...",l:"Interview/Performance/应用篇.html",a:"懒加载"},"78.1":{t:"防抖与节流",p:`本质上都是闭包
节流:通过在一段时间内无视后来产生的回调请求来实现的
防抖:在一段时间内,无论调用多少次,只执行最后一次
`,l:"Interview/Performance/应用篇.html#防抖与节流",a:"防抖与节流"},"79.0":{t:"服务端渲染",p:`首先是客户端渲染，在客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，生成相应的 DOM，这种特性使得客户端代码渲染的源代码很简洁。
服务端渲 ...`,l:"Interview/Performance/渲染篇.html",a:"服务端渲染"},"79.1":{t:"浏览器",p:`渲染过程：简单来说就是渲染引擎根据 HTML 文件描述构建相应的数学模型了。调用浏览器各个模块，将网页资源代码转换成图像结果，这个过程就是渲染过程。


HTML 解释器：将 HTML 文档经过词法分 ...`,l:"Interview/Performance/渲染篇.html#浏览器",a:"浏览器"},"79.2":{t:"css-优化",p:`
避免使用通配符，只对需要用到的元素进行选择
关注可以通过继承实现的属性，避免重复匹配重复定义
少用标签选择器
减少嵌套

CSS 是阻塞渲染的资源，DOM 树和 CSSOM 合并构建成渲染树，浏览器 ...`,l:"Interview/Performance/渲染篇.html#css-优化",a:"css-优化"},"79.3":{t:"dom-优化",p:`减少 DOM 操作 ⭐⭐
回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来，这个过程就叫回流 ...`,l:"Interview/Performance/渲染篇.html#dom-优化",a:"dom-优化"},"80.0":{t:"在网络层面进行优化-有三个地方可以进行优化-分别是-dns-解析、tcp-连接和-http-请求-响应-对于-dns-和-tcp-连接这两个步骤-前端可以做的非常有限-核心是在-http-连接上进行优化。",p:`HTTP 优化有两个大方向：减少请求次数和减少单次请求所花费的时间。主要通过 webpack 去优化：
`,l:"Interview/Performance/网络篇.html",a:"在网络层面进行优化-有三个地方可以进行优化-分别是-dns-解析、tcp-连接和-http-请求-响应-对于-dns-和-tcp-连接这两个步骤-前端可以做的非常有限-核心是在-http-连接上进行优化。"},"80.1":{t:"webpack",p:"\r",l:"Interview/Performance/网络篇.html#webpack",a:"webpack"},"80.2":{t:"不要让-loader-做太多事情",p:"不要让 loader 做太多事情，比如说 babel-loader，babel-loader 功能很强大，但是也很慢，可以使用 include 或 exclude 帮我们避免不必要的转译，或者通过开启 ...",l:"Interview/Performance/网络篇.html#不要让-loader-做太多事情",a:"不要让-loader-做太多事情"},"80.3":{t:"处理第三方库",p:`使用 DllPlugin，这个插件会把第三方库单独打包到一个文件中，这个文件就是一个单纯的依赖库。这个依赖库不会跟着你的业务代码一起被打包，只有当依赖自身发生版本变化时才会重新打包。
使用 DllPl ...`,l:"Interview/Performance/网络篇.html#处理第三方库",a:"处理第三方库"},"80.4":{t:"使用-happypack-将-loder-由单进程转换成多进程",p:"webpack 是单线程的，如果同一时刻存在多个任务，只能排队一个一个的等待处理，但是 CPU 是多核的，Happypack 会充分释放 CPU 在多核并发方面的优势，帮我们把任务分解给多个子进程去并 ...",l:"Interview/Performance/网络篇.html#使用-happypack-将-loder-由单进程转换成多进程",a:"使用-happypack-将-loder-由单进程转换成多进程"},"80.5":{t:"构建结果体积压缩",p:`将文件结果可视化，找出导致体积过大的原因
包组成可视化工具：webpack-bundle-analyer，配置方式和普通 plugin 一样，能够以矩形树图的形式将包内各个模块的大小和依赖关系呈现出来 ...`,l:"Interview/Performance/网络篇.html#构建结果体积压缩",a:"构建结果体积压缩"},"80.6":{t:"gzip-压缩",p:"在请求头中通过 accept-encoding：gzip 来开启 Gzip 压缩，服务端压缩，客户端解压，一般情况下，如果处理的是具备一定规模的项目，压缩后通常能减少响应 70%左右的大小。Gzip  ...",l:"Interview/Performance/网络篇.html#gzip-压缩",a:"gzip-压缩"},"80.7":{t:"图片优化",p:`图片在所有资源中所占的比重是非常大的，当下应用比较广泛的 Web 图片格式有 JPEG/JPG、PNG、WebP、Base64、SVG 等。
首先，在计算机中，像素是用二进制表示的，不同的图片格式中像 ...`,l:"Interview/Performance/网络篇.html#图片优化",a:"图片优化"},"80.8":{t:"jpeg-jpg",p:`有损压缩、体积小、加载快、不支持透明
最大的特点就是有损压缩，这种压缩算法很高效，所有 JPG 是一种非常轻巧的图片格式，JPG 格式有 24 位存储单个图，可以呈现多达 1600 万中颜色，一般场景 ...`,l:"Interview/Performance/网络篇.html#jpeg-jpg",a:"jpeg-jpg"},"80.9":{t:"png",p:"是一种无损压缩的高保真的图片格式，8 和 24 代表的是二进制的位数，PNG-8 最多支持 256 种颜色，PNG-24 最多支持 1600 万种颜色，PNG 图片具有比 JPG 更强的色彩表现力，对 ...",l:"Interview/Performance/网络篇.html#png",a:"png"},"80.10":{t:"svg",p:`文本文件、体积小、不失真、兼容性好
SVG 是一种基于 XML 语法的图像格式，SVG 对图像的处理不是基于像素点，而是基于对图像的形状描述。对比 PNG 和 JPG，文件体积更小，可压缩性更强。最显 ...`,l:"Interview/Performance/网络篇.html#svg",a:"svg"},"80.11":{t:"base64",p:`文本文件、依赖编码、小图标解决方案
和精灵图一样，都是用于解决小图标的，精灵图就是将小图标合并到一张图片上，然后利用 CSS 的背景定位来显示其中每一部分的技术。Base64 的出现，也是为了减少加载 ...`,l:"Interview/Performance/网络篇.html#base64",a:"base64"},"80.12":{t:"webp",p:`Google 开发的旨在加快图片加载速度的图片格式，支持有损压缩和无损压缩。
优点：具备 JPG、PNG 一样的优点，可以显示动态图片。
缺点：对除 Chrome 之外的浏览器兼容性较差，会增加服务端 ...`,l:"Interview/Performance/网络篇.html#webp",a:"webp"},"81.0":{t:"跨站伪造请求",p:`

防护原理：

使用CSRF Token进行验证
验证请求来源
验证HTTP Referer头



`,l:"Interview/Safe/SCRF.html",a:"跨站伪造请求"},"82.0":{t:"就是通过把-sql-命令插入到-web-表单递交或输入域名或页面请求的查询字符串-最终达到欺骗服务器执行恶意的-sql-命令",p:`

总的来说有以下几点

永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等
永远不要使用动态拼装 SQL，可以使用参数化 ...`,l:"Interview/Safe/SQl注入.html",a:"就是通过把-sql-命令插入到-web-表单递交或输入域名或页面请求的查询字符串-最终达到欺骗服务器执行恶意的-sql-命令"},"83.0":{t:"xss-cross-site-scripting-攻击指的是攻击者往-web-页面里插入恶意-html-标签或者-javascript-代码。比如-攻击者在论坛中放一个看似安全的链接-骗取用户点击后-窃取-cookie-中的用户私密信息-或者攻击者在论坛中加一个恶意表单-当用户提交表单的时候-却把信息传送到攻击者的服务器中-而不是用户原本以为的信任站点",p:`

防护原理：

对用户输入进行合适的转义和过滤
使用安全的模板引擎或自动转义函数
使用 HTTP 头部中的 Content Security Policy (CSP)



`,l:"Interview/Safe/XSS.html",a:"xss-cross-site-scripting-攻击指的是攻击者往-web-页面里插入恶意-html-标签或者-javascript-代码。比如-攻击者在论坛中放一个看似安全的链接-骗取用户点击后-窃取-cookie-中的用户私密信息-或者攻击者在论坛中加一个恶意表单-当用户提交表单的时候-却把信息传送到攻击者的服务器中-而不是用户原本以为的信任站点"},"84.0":{t:"http-是明文传输-https-是加密传输-https-http-tls-ssl",p:"\r",l:"Interview/Safe/中间人攻击.html",a:"http-是明文传输-https-是加密传输-https-http-tls-ssl"},"84.1":{t:"tsl-中的加密",p:`
对称加密：两边拥有相同的密钥，两边都知道如何将密文加密解密
非对称解密：有公钥和私钥之分，公钥所有人都知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私有只有分发公钥的一方才知道

`,l:"Interview/Safe/中间人攻击.html#tsl-中的加密",a:"tsl-中的加密"},"84.2":{t:"对称密钥加密和非对称密钥加密有什么区别",p:`
对称密钥加密是最简单的一种加密方式，加解密都是相同的密钥，好处是加解密效率快，但是不安全，如果有人拿到了这个密钥谁都可以进行解密
非对称密钥会有两把密钥，一把是私钥，只有自己才有；一把是公钥，可以发 ...`,l:"Interview/Safe/中间人攻击.html#对称密钥加密和非对称密钥加密有什么区别",a:"对称密钥加密和非对称密钥加密有什么区别"},"84.3":{t:"https-加密过程",p:`
客户端请求网址，例如www.baidu.com
服务端存储着公钥和私钥
服务器把 CA 数字证书（包含公钥）响应给客户端
客户端解析证书拿到公钥，生成随机的 KEY
客户端把解密后的 KEY 传递给 ...`,l:"Interview/Safe/中间人攻击.html#https-加密过程",a:"https-加密过程"},"84.4":{t:"中间人攻击的过程",p:`
客户端请求被劫持，将所有的请求发送到中间人的服务器
中间人服务器返回自己的证书
客户端创建随机数，使用中间人证书中的公钥进行加密发送给中间人服务器，中间人使用私钥对随机数解密并构造对称加密，对之后传 ...`,l:"Interview/Safe/中间人攻击.html#中间人攻击的过程",a:"中间人攻击的过程"},"84.5":{t:"怎么预防中间人攻击",p:`使用正规厂商的证书，慎用免费的
`,l:"Interview/Safe/中间人攻击.html#怎么预防中间人攻击",a:"怎么预防中间人攻击"},"85.0":{t:"防护原理",p:`
验证文件类型和大小
存储上传的文件在非 Web 可访问目录下
生成唯一且安全的文件名

`,l:"Interview/Safe/文件上传漏洞.html",a:"防护原理"},"86.0":{t:"区分用户是人还是机器",p:`

防止恶意破解：通过要求用户输入验证码，可以防止用户使用自动化程序对密码、账号不断尝试


防止刷票和灌水：可以阻止自动化程序大规模注册账号、刷屏或在论坛上发布大量无意义的帖子，保护网站资源免受滥用 ...`,l:"Interview/Safe/验证码.html",a:"区分用户是人还是机器"},"87.0":{t:"watch-的-deep-true-是怎么实现的",p:"当用户知道了 watch 中的 depp 属性为 true 时，如果当前监控的值是数组类型。会对对象中的每一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也 ...",l:"Interview/Vue/Computed-Watch.html",a:"watch-的-deep-true-是怎么实现的"},"87.1":{t:"computed-和-watch-的区别",p:`
Computed本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入 ...`,l:"Interview/Vue/Computed-Watch.html#computed-和-watch-的区别",a:"computed-和-watch-的区别"},"87.2":{t:"computed-的实现",p:`
初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。
初始化 computed, 遍历 computed 里的每个属性，每个 com ...`,l:"Interview/Vue/Computed-Watch.html#computed-的实现",a:"computed-的实现"},"87.3":{t:"watch-原理",p:`watch 本质上是为每个监听属性 setter 创建了一个 watcher，当被监听的属性更新时，调用传入的回调函数。常见的配置选项有 deep 和 immediate，对应原理如下

deep：深 ...`,l:"Interview/Vue/Computed-Watch.html#watch-原理",a:"watch-原理"},"88.0":{t:"vue-路由传参",p:`
使用 query 方法传入的参数使用this.$route.query接收
使用 params 方法传入的参数使用this.$route.params接收

`,l:"Interview/Vue/vue-router.html",a:"vue-路由传参"},"88.1":{t:"route-和-router-的区别",p:`
route：当前 router 跳转对象，里面可以获取 name、path、query、params 等
router：是 vue-router 的实例，想要导航到不同 URL，使用 router. ...`,l:"Interview/Vue/vue-router.html#route-和-router-的区别",a:"route-和-router-的区别"},"88.2":{t:"怎么定义动态路由-怎么获取传过来的参数",p:`在 router 目录下的 index.js 文件中，对 path 属性加上 /:id，使用 router 对象的 params.if 获取动态参数
`,l:"Interview/Vue/vue-router.html#怎么定义动态路由-怎么获取传过来的参数",a:"怎么定义动态路由-怎么获取传过来的参数"},"88.3":{t:"vue-里面-router-link-在电脑上有用-安卓上没反应怎么解决",p:`在安卓上有问题是 babel 的问题，安装 babel polypill 插件解决
`,l:"Interview/Vue/vue-router.html#vue-里面-router-link-在电脑上有用-安卓上没反应怎么解决",a:"vue-里面-router-link-在电脑上有用-安卓上没反应怎么解决"},"88.4":{t:"hash-和-history-路由模式实现原理",p:`**hash**模式
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL中 # 后面的内容。比如下面这个网站，它的 lo ...`,l:"Interview/Vue/vue-router.html#hash-和-history-路由模式实现原理",a:"hash-和-history-路由模式实现原理"},"88.5":{t:"router-view-和-router-link-是怎么起作用的",p:`
vue-router中两个重要组件router-link和router-view，分别起到路由导航作用和组件内容渲染作用
使用中router-link默认生成一个a标签，设置to属性定义跳转path ...`,l:"Interview/Vue/vue-router.html#router-view-和-router-link-是怎么起作用的",a:"router-view-和-router-link-是怎么起作用的"},"88.6":{t:"了解-history-有哪些方法吗",p:"history 这个对象在html5的时候新加入两个api history.pushState() 和 history.repalceState() 这两个API可以在不进行刷新的情况下，操作浏览器的 ...",l:"Interview/Vue/vue-router.html#了解-history-有哪些方法吗",a:"了解-history-有哪些方法吗"},"88.7":{t:"怎么监听-pushstate-和-replacestate-的变化",p:`利用自定义事件new Event()创建这两个事件，并全局监听
`,l:"Interview/Vue/vue-router.html#怎么监听-pushstate-和-replacestate-的变化",a:"怎么监听-pushstate-和-replacestate-的变化"},"88.8":{t:"vue-router-如何保护路由",p:`
vue-router中保护路由的方法叫做路由守卫，主要用来通过跳转或取消的方式守卫导航。
路由守卫有三个级别：全局、路由独享、组件级。影响范围由大到小，例如全局的router.beforeEach( ...`,l:"Interview/Vue/vue-router.html#vue-router-如何保护路由",a:"vue-router-如何保护路由"},"88.9":{t:"怎么实现路由懒加载",p:`
当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。利用路由懒加载我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样会更加高效，是一种优化手段 ...`,l:"Interview/Vue/vue-router.html#怎么实现路由懒加载",a:"怎么实现路由懒加载"},"88.10":{t:"怎么从零开始实现一个-vue-路由",p:`一个SPA应用的路由需要解决的问题是页面跳转内容改变同时不刷新，同时路由还需要以插件形式存在，所以：

首先我会定义一个createRouter函数，返回路由器实例，实例内部做几件事


保存用户传入 ...`,l:"Interview/Vue/vue-router.html#怎么从零开始实现一个-vue-路由",a:"怎么从零开始实现一个-vue-路由"},"89.0":{t:"proxy-与-object-defineproperty-优劣对比",p:`Object.defineProperty()存在的问题：

不能监听数组的变化：无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应
必须遍历对象的每个属性：只能劫持对象的属性，从而需要 ...`,l:"Interview/Vue/Vue2-Vue3.html",a:"proxy-与-object-defineproperty-优劣对比"},"89.1":{t:"ref-和-reactive-的区别",p:`reactive 用于处理对象类型的数据响应式，底层采用 new Proxy（）
ref 通常用于处理单值的响应式问题，底层采用的是 Object.defineProperty()
`,l:"Interview/Vue/Vue2-Vue3.html#ref-和-reactive-的区别",a:"ref-和-reactive-的区别"},"89.2":{t:"watch-和-watcheffect-的区别",p:`
watch 需要手动指定要监视的数据和回调函数，具有更高的灵活性和定制性。watchEffect 会自动追踪函数内部使用的响应式数据，不需要显示指定
watch 可以监视多个数据，可以在回调函数中处 ...`,l:"Interview/Vue/Vue2-Vue3.html#watch-和-watcheffect-的区别",a:"watch-和-watcheffect-的区别"},"89.3":{t:"composition-api-和-options-api-有什么不同",p:`
在逻辑组织和逻辑复用方面，Composition API是优于Options API
因为Composition API几乎是函数，会有更好的类型推断。
Composition API对 tree- ...`,l:"Interview/Vue/Vue2-Vue3.html#composition-api-和-options-api-有什么不同",a:"composition-api-和-options-api-有什么不同"},"89.4":{t:"vue3-对-vue2-有什么优势",p:`
性能更好（编译优化、使用proxy等）
体积更小
更好的TS支持
更好的代码组织
更好的逻辑抽离
更多新功能

`,l:"Interview/Vue/Vue2-Vue3.html#vue3-对-vue2-有什么优势",a:"vue3-对-vue2-有什么优势"},"89.5":{t:"vue3-和-vue2-生命周期有什么区别",p:`Options API​生命周期

beforeDestroy改为beforeUnmount
destroyed改为umounted
其他沿用vue2生命周期

`,l:"Interview/Vue/Vue2-Vue3.html#vue3-和-vue2-生命周期有什么区别",a:"vue3-和-vue2-生命周期有什么区别"},"89.6":{t:"composition-api-和-react-hooks-的区别",p:`
Composition API的setup(相当于created、beforeCreate的合集)只会调用一次，而React Hooks函数在渲染过程中会被多次调用
Composition API无 ...`,l:"Interview/Vue/Vue2-Vue3.html#composition-api-和-react-hooks-的区别",a:"composition-api-和-react-hooks-的区别"},"89.7":{t:"vue3-新特性",p:`
api层面Vue3新特性主要包括：Composition API、SFC Composition API语法糖、Teleport传送门、Fragments 片段、Emits选项、自定义渲染器、SFC ...`,l:"Interview/Vue/Vue2-Vue3.html#vue3-新特性",a:"vue3-新特性"},"89.8":{t:"vue3-速度快的原因",p:`Vue3.0 性能提升体现在哪些方面

代码层面性能优化主要体现在全新响应式API，基于Proxy实现，性能更好（获取到哪一层才触发响应式get，不是像vue2一次性递归监听数据）
编译层面做了更多编 ...`,l:"Interview/Vue/Vue2-Vue3.html#vue3-速度快的原因",a:"vue3-速度快的原因"},"89.9":{t:"为什么需要-ref、toref、torefs",p:`为什么需要用 ref

返回值类型，会丢失响应式
如在setup、computed、合成函数，都有可能返回值类型
Vue如不定义ref，用户将制造ref，反而更混乱

为何 ref 需要.value  ...`,l:"Interview/Vue/Vue2-Vue3.html#为什么需要-ref、toref、torefs",a:"为什么需要-ref、toref、torefs"},"89.10":{t:"setup-如何获取组件实例",p:`
在setup和其他composition API中没有this
通过getCurrentInstance获取当前实例
若使用options API可以照常使用this

`,l:"Interview/Vue/Vue2-Vue3.html#setup-如何获取组件实例",a:"setup-如何获取组件实例"},"90.0":{t:"从-vuex-中获取的数据能直接更改吗",p:`不能直接更改，需要浅拷贝对象之后更改，否则会报错
`,l:"Interview/Vue/Vuex.html",a:"从-vuex-中获取的数据能直接更改吗"},"90.1":{t:"vuex-中-actions-和-mutations-有什么区别",p:`
改 Vuex 的 store 中的状态的唯一方法是提交 mutation，mutation 非常类似于事件：每个 mutation 都有一个字符串的类型 (type)和一个 回调函数 (handle ...`,l:"Interview/Vue/Vuex.html#vuex-中-actions-和-mutations-有什么区别",a:"vuex-中-actions-和-mutations-有什么区别"},"90.2":{t:"怎么监听-vuex-数据的变化",p:`
可以通过watch选项或者watch方法监听状态
可以使用vuex提供的 API：store.subscribe()


watch选项方式，可以以字符串形式监听$store.state.xx；su ...`,l:"Interview/Vue/Vuex.html#怎么监听-vuex-数据的变化",a:"怎么监听-vuex-数据的变化"},"90.3":{t:"vuex-页面刷新数据丢失怎么解决",p:`
vuex只是在内存保存状态，刷新之后就会丢失，如果要持久化就要存起来
localStorage就很合适，提交mutation的时候同时存入localStorage，store中把值取出作为state ...`,l:"Interview/Vue/Vuex.html#vuex-页面刷新数据丢失怎么解决",a:"vuex-页面刷新数据丢失怎么解决"},"90.4":{t:"pinia-有什么优点",p:`1. pinia 是什么？


在Vue3中，可以使用传统的Vuex来实现状态管理，也可以使用最新的pinia来实现状态管理，我们来看看官网如何解释pinia的：Pinia 是 Vue 的存储库，它允 ...`,l:"Interview/Vue/Vuex.html#pinia-有什么优点",a:"pinia-有什么优点"},"90.5":{t:"从零开始实现一个-vuex-说说思路",p:`
官方说vuex是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个vuex


要实现一个Store存储全局状态
要提供修改状态所需 API：commit(type, paylo ...`,l:"Interview/Vue/Vuex.html#从零开始实现一个-vuex-说说思路",a:"从零开始实现一个-vuex-说说思路"},"91.0":{t:"数据绑定机制",p:`采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，
在数据变动时发布消息给订阅者，触发相应的监听回调。
`,l:"Interview/Vue/原理.html",a:"数据绑定机制"},"91.1":{t:"template-编译",p:`
转换成 AST 树，得到 render 函数返回 VNode
首先，通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree 即 源代码的抽 ...`,l:"Interview/Vue/原理.html#template-编译",a:"template-编译"},"91.2":{t:"怎么监听对象或数组某个属性的变化",p:`$set
`,l:"Interview/Vue/原理.html#怎么监听对象或数组某个属性的变化",a:"怎么监听对象或数组某个属性的变化"},"91.3":{t:"什么是虚拟-dom-作用是什么",p:`只是一层真实 DOM 的抽象,以 JavaScript 对象作为基础的树.用对象的属性来描述节点,最终可以通过一系列操作使这棵树映射到真实环境上.
创建虚拟 DOM 是为了更好将虚拟的节点渲染到页面视 ...`,l:"Interview/Vue/原理.html#什么是虚拟-dom-作用是什么",a:"什么是虚拟-dom-作用是什么"},"91.4":{t:"vue-怎么检测数组的变化",p:`vue2 中并没有使用 defineProperty 来检测数组（性能差），vue2 采用重写数组的方法来实现（7 个变异的方法，能改变原数组的方法）
通过原型链 + 函数劫持的方式实现的（缺陷是不能 ...`,l:"Interview/Vue/原理.html#vue-怎么检测数组的变化",a:"vue-怎么检测数组的变化"},"91.5":{t:"vue-怎么进行依赖收集",p:`依赖收集的目的是等数据变化了可以自动更新视图
每个属性都有自己的 dep 属性，存放所依赖的 watcher，当属性变化后会通知自己对应的 watcher 去更新，默认在初始化的时候会调用 rende ...`,l:"Interview/Vue/原理.html#vue-怎么进行依赖收集",a:"vue-怎么进行依赖收集"},"91.6":{t:"vue-中-key-的作用和原理",p:`key 给每一个 vnode 一个唯一的 id，可以依靠 key，更准确、更快的拿到 oldVnode 中对应的节点，更新组件时判断两个节点是否相同，相同就复用，不相同就删除旧的创建新的
vue 和  ...`,l:"Interview/Vue/原理.html#vue-中-key-的作用和原理",a:"vue-中-key-的作用和原理"},"91.7":{t:"new-vue-过程做了什么",p:`
内部会初始化组件绑定的事件，初始化组件的父子关系$parent $children $root
初始化响应式数据 data、computed、props、watch、method，同时也初始化了 p ...`,l:"Interview/Vue/原理.html#new-vue-过程做了什么",a:"new-vue-过程做了什么"},"91.8":{t:"diff-算法原理",p:`DOM操作是非常昂贵的，因此我们需要尽量地减少DOM操作。这就需要找出本次DOM必须更新的节点来更新，其他的不更新，这个找出的过程，就需要应用 diff 算法

vue的diff算法是平级比较，不考虑 ...`,l:"Interview/Vue/原理.html#diff-算法原理",a:"diff-算法原理"},"91.9":{t:"响应式数据原理",p:`Vue2
数据劫持 + 观察者模式
对象内部通过 defineReactive 方法，使用 Object.defineProperty 来劫持各个属性的 setter、getter（只会劫持已经存在的 ...`,l:"Interview/Vue/原理.html#响应式数据原理",a:"响应式数据原理"},"91.10":{t:"vue-实例挂载的过程中发生了什么",p:`
挂载过程指的是app.mount()过程，这个过程中整体上做了两件事：初始化和建立更新机制
初始化会创建组件实例、初始化组件状态，创建各种响应式数据
建立更新机制这一步会立即执行一次组件更新函数，这 ...`,l:"Interview/Vue/原理.html#vue-实例挂载的过程中发生了什么",a:"vue-实例挂载的过程中发生了什么"},"91.11":{t:"为什么-vue-采用异步渲染",p:`
Vue 是组件级更新，如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能， Vue 会在本轮数据更新后，在异步更新视图。核心思想 nextTick

当数据发生了变化时，首 ...`,l:"Interview/Vue/原理.html#为什么-vue-采用异步渲染",a:"为什么-vue-采用异步渲染"},"91.12":{t:"nexttick-实现原理",p:`主要是使用了宏任务和微任务，定义一个异步方法，多次调用 nextTick 会将方法存入到队列中，通过这个异步方法清空当前队列

nextTick 中的回调是在下次 DOM 更新循环结束之后执行延迟回调 ...`,l:"Interview/Vue/原理.html#nexttick-实现原理",a:"nexttick-实现原理"},"91.13":{t:"v-model-实现原理",p:"我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖（可以看成是value + ...",l:"Interview/Vue/原理.html#v-model-实现原理",a:"v-model-实现原理"},"91.14":{t:"diff-算法的时间复杂度",p:`两个树的完全 diff 算法是一个时间复杂度为 O(n3)，Vue 进行了优化，转换成了 O(n)复杂度的问题（只比较同级不考虑跨级问题）
`,l:"Interview/Vue/原理.html#diff-算法的时间复杂度",a:"diff-算法的时间复杂度"},"92.0":{t:"谈谈对-vue-的理解",p:`
vue 是一套用于构建用户界面的渐进式框架，核心库只关心视图层
是一个声明式框架，更关注结果
收到 MVVM 模式启发，简化了映射关系
采用虚拟 DOM，比较新旧虚拟节点，找到变化再进行更新，提高性 ...`,l:"Interview/Vue/基础知识.html",a:"谈谈对-vue-的理解"},"92.1":{t:"为什么-vue-组件中-data-必须是函数",p:`
根实例对象 data 可以是对象也可以是函数，因为根实例是单例，不会产生数据污染情况
组件实例对象 data 必须是函数，.vue 文件在使用的时候实际上会转换成一个 class，一个组件被复用多次 ...`,l:"Interview/Vue/基础知识.html#为什么-vue-组件中-data-必须是函数",a:"为什么-vue-组件中-data-必须是函数"},"92.2":{t:"v-show-和-v-if-的区别",p:`区别

v-show 隐藏则是为该元素添加 css-display:none，dom元素依旧还在，v-if显示隐藏是将dom元素整个添加或删除
编译过程：v-if 切换有一个局部编译/缺陷的过程，切换 ...`,l:"Interview/Vue/基础知识.html#v-show-和-v-if-的区别",a:"v-show-和-v-if-的区别"},"92.3":{t:"为什么-v-if-和-v-for-不建议一起使用",p:`
在 vue2 中，v-for 的优先级是高于 v-if 的，把它们放在一起，输出的渲染函数中可以看出会先执行循环再判断条件，哪怕只渲染列表中一小部分元素，也得在每次重新渲染的时候遍历整个列表，这会比 ...`,l:"Interview/Vue/基础知识.html#为什么-v-if-和-v-for-不建议一起使用",a:"为什么-v-if-和-v-for-不建议一起使用"},"92.4":{t:"怎么获取-dom",p:`使用 ref 和 refs
先给标签设置一个 ref 值，再通过this.$refs.domName 来获取
`,l:"Interview/Vue/基础知识.html#怎么获取-dom",a:"怎么获取-dom"},"92.5":{t:"vue-初始化页面闪动问题",p:`在 vue 初始化之前，由于 div 是不归 vue 管的，所以写的代码在还没有解析的情况下会容易出现花屏现象，看到类似{{message}}的字样
可以在 css 里加
[v-cloak] {
   ...`,l:"Interview/Vue/基础知识.html#vue-初始化页面闪动问题",a:"vue-初始化页面闪动问题"},"92.6":{t:"ajax-请求应该放在-methods-还是-vuex-中",p:`
如果请求来的数据不是要被其它组件共用，仅仅在请求的组件内使用，就不需要放入 vuex 的 state 中
如果被其它地方复用，就放在 action 中，方便复用

`,l:"Interview/Vue/基础知识.html#ajax-请求应该放在-methods-还是-vuex-中",a:"ajax-请求应该放在-methods-还是-vuex-中"},"92.7":{t:"对-spa-页面的理解-优缺点",p:"SPA，单页面应用，只在 web 页面初始化的时候加载相应的 HTML、CSS 和 JavaScript，一旦页面加载完成，SPA 不会因为用户的操作进行页面的重新加载或跳转，而是利用路由机制实现 H ...",l:"Interview/Vue/基础知识.html#对-spa-页面的理解-优缺点",a:"对-spa-页面的理解-优缺点"},"92.8":{t:"spa-首屏加载慢怎么解决",p:`什么叫首屏加载时间：浏览器从响应用户输入网站地址,到首屏内容渲染完成的时间,整个网页不一定要全部渲染完成,但是需要展示当前视窗需要的内容
加载慢的原因：

网络延时问题
资源文件体积过大
是否发生重复 ...`,l:"Interview/Vue/基础知识.html#spa-首屏加载慢怎么解决",a:"spa-首屏加载慢怎么解决"},"92.9":{t:"对-keep-alive-的理解",p:`
keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。一般结合路由和动态组件一起使用，用于缓存组件
提供 include 和 exclude 属性， ...`,l:"Interview/Vue/基础知识.html#对-keep-alive-的理解",a:"对-keep-alive-的理解"},"92.10":{t:"vue-observable-有了解过吗",p:`让一个对象变成响应式数据,Vue 内部会用它来处理 data 函数返回的对象
使用场景: 实现非父子组件通信
`,l:"Interview/Vue/基础知识.html#vue-observable-有了解过吗",a:"vue-observable-有了解过吗"},"92.11":{t:"既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-检测差异",p:"vue 设计的每一个组件一个 watcher，没有采用一个属性对应一个 watcher，这样会导致大量的 watcher 的产生而浪费内存，如果粒度过低也无法精准检测变化，所以采用 diff 算法+组 ...",l:"Interview/Vue/基础知识.html#既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-检测差异",a:"既然-vue-通过数据劫持可以精准探测数据变化-为什么还需要虚拟-dom-进行-diff-检测差异"},"92.12":{t:"vue-mixin-使用场景和原理",p:`
在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始 ...`,l:"Interview/Vue/基础知识.html#vue-mixin-使用场景和原理",a:"vue-mixin-使用场景和原理"},"92.13":{t:"对-mvvm-的理解",p:"MVVM是Model-View-ViewModel缩写，也就是把MVC中的Controller演变成ViewModel。Model层代表数据模型（也就是前端声明的静态数据或者是通过网络请求获取的数据） ...",l:"Interview/Vue/基础知识.html#对-mvvm-的理解",a:"对-mvvm-的理解"},"92.14":{t:"vue-组件为什么只有一个根元素",p:`
vue2中组件确实只能有一个根，但vue3中组件已经可以多根节点了。
之所以需要这样是因为vdom是一颗单根树形结构，patch方法在遍历的时候从根节点开始遍历，它要求只有一个根节点。组件也会转换为 ...`,l:"Interview/Vue/基础知识.html#vue-组件为什么只有一个根元素",a:"vue-组件为什么只有一个根元素"},"92.15":{t:"函数式组件的优势和原理",p:`
函数式组件需要在声明组件是指定 functional:true
不需要实例化，所以没有this,this通过render函数的第二个参数context来代替
没有生命周期钩子函数，不能使用计算属性， ...`,l:"Interview/Vue/基础知识.html#函数式组件的优势和原理",a:"函数式组件的优势和原理"},"92.16":{t:"组件之间通信方式有哪些",p:`

props / $emit 适用 父子组件通信

父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的



ref 与 $parent / $ ...`,l:"Interview/Vue/基础知识.html#组件之间通信方式有哪些",a:"组件之间通信方式有哪些"},"92.17":{t:"vue-如何扩展一个组件",p:`
常见的组件扩展方法有：mixins，slots，extends等
混入mixins是分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的 ...`,l:"Interview/Vue/基础知识.html#vue-如何扩展一个组件",a:"vue-如何扩展一个组件"},"92.18":{t:"子组件可以直接改父组件的数据吗",p:`
所有的 prop 都使得其父子之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。 ...`,l:"Interview/Vue/基础知识.html#子组件可以直接改父组件的数据吗",a:"子组件可以直接改父组件的数据吗"},"92.19":{t:"组件和插件有什么区别",p:`1. 组件是什么
组件就是把图形、非图形的各种逻辑均抽象为一个统一的概念（组件）来实现开发的模式，在 Vue 中每一个.vue 文件都可以视为一个组件
组件的优势

降低整个系统的耦合度，在保持接口不 ...`,l:"Interview/Vue/基础知识.html#组件和插件有什么区别",a:"组件和插件有什么区别"},"92.20":{t:"sync-和-v-model-的区别",p:`

.sync修饰符可以实现父子组件之间的双向绑定，并且可以实现子组件同步修改父组件的值，相比较与v-model来说,sync修饰符就简单很多了


一个组件上可以有多个.sync修饰符


相同点
 ...`,l:"Interview/Vue/基础知识.html#sync-和-v-model-的区别",a:"sync-和-v-model-的区别"},"92.21":{t:"ssr-的理解",p:`
Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏 ...`,l:"Interview/Vue/基础知识.html#ssr-的理解",a:"ssr-的理解"},"92.22":{t:"delete-和-vue-delete-删除数组的区别",p:`
delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。
Vue.delete直接删除了数组 改变了数组的键值。

`,l:"Interview/Vue/基础知识.html#delete-和-vue-delete-删除数组的区别",a:"delete-和-vue-delete-删除数组的区别"},"92.23":{t:"vue-ref-的作用",p:`
获取dom元素this.$refs.box
获取子组件中的data this.$refs.box.msg
调用子组件中的方法this.$refs.box.open()

`,l:"Interview/Vue/基础知识.html#vue-ref-的作用",a:"vue-ref-的作用"},"92.24":{t:"vue-loader-是什么-有什么作用",p:`
vue-loader是用于处理单文件组件（SFC，Single-File Component）的webpack loader
因为有了vue-loader，我们就可以在项目中编写SFC格式的Vue组 ...`,l:"Interview/Vue/基础知识.html#vue-loader-是什么-有什么作用",a:"vue-loader-是什么-有什么作用"},"92.25":{t:"从-0-到-1-自己构架一个-vue-项目-有哪些步骤-哪些重要插件、目录结构怎么组织",p:`
从0创建一个项目我大致会做以下事情：项目构建、引入必要插件、代码规范、提交规范、常用库和组件
目前vue3项目我会用vite或者create-vue创建项目
接下来引入必要插件：路由插件vue-ro ...`,l:"Interview/Vue/基础知识.html#从-0-到-1-自己构架一个-vue-项目-有哪些步骤-哪些重要插件、目录结构怎么组织",a:"从-0-到-1-自己构架一个-vue-项目-有哪些步骤-哪些重要插件、目录结构怎么组织"},"93.0":{t:"对生命周期的理解",p:"Vue 的生命周期即一个 Vue 实例从被创建到被销毁的过程 可以分为 8 个阶段： beforeCreate：实例创建前 created：实例创建完成 beforeMount：挂载前 mounted ...",l:"Interview/Vue/生命周期.html",a:"对生命周期的理解"},"93.1":{t:"什么时候使用-beforedestory",p:`在 vue 实例销毁之前被调用，可以执行一些清理和释放资源的工作

清理定时器，避免内存泄露和不必要的开销
取消异步操作，确保在销毁实例时不会触发不必要的回调或产生不稳定的行为
清理订阅，如果使用了观 ...`,l:"Interview/Vue/生命周期.html#什么时候使用-beforedestory",a:"什么时候使用-beforedestory"},"93.2":{t:"vue-的父组件和子组件生命周期钩子函数执行顺序",p:`

加载渲染过程
父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&g ...`,l:"Interview/Vue/生命周期.html#vue-的父组件和子组件生命周期钩子函数执行顺序",a:"vue-的父组件和子组件生命周期钩子函数执行顺序"},"93.3":{t:"在那个生命周期中调用异步请求",p:"可以在 created 和 mounted 生命周期中调用异步请求，如果需要在组件实例被创建时立即获取数据并且不依赖于 DOM 元素，可以使用 created；如果需要等待 DOM 准备好才执行一些操 ...",l:"Interview/Vue/生命周期.html#在那个生命周期中调用异步请求",a:"在那个生命周期中调用异步请求"},"94.0":{t:"babel-主要用于将新版本的代码转换为向后兼容的-js-语法-​-polyfill-方式-以便能够运行在各版本的浏览器或其他环境中",p:`基本原理
首先将源码转成抽象语法树，然后对语法树进行处理生成新的语法树，最后将新语法树生成新的 JS 代码
1）通过babylon将 js 转化成 ast (抽象语法树)
2）通过babel-trav ...`,l:"Interview/工程化/babel原理.html",a:"babel-主要用于将新版本的代码转换为向后兼容的-js-语法-​-polyfill-方式-以便能够运行在各版本的浏览器或其他环境中"},"95.0":{t:"loader-是什么",p:`webpack 只能处理 js 格式的资源，任何非 js 文件都必须被对应的 loader 处理转换成 js 代码
`,l:"Interview/工程化/loader.html",a:"loader-是什么"},"95.1":{t:"手写一个-loader",p:`// 作用：将css内容，通过style标签插入到页面中
// source为要处理的css源文件
function loader(source) {
  let style = \`
    let  ...`,l:"Interview/工程化/loader.html#手写一个-loader",a:"手写一个-loader"},"95.2":{t:"loader-的执行顺序",p:`相同优先级的 loader 链，执行顺序为从右到左，从下到上
`,l:"Interview/工程化/loader.html#loader-的执行顺序",a:"loader-的执行顺序"},"95.3":{t:"常见的-loader",p:`
style-loader：把 css 注入到 JavaScript 中，通过 DOM 操作去加载 css
css-loader：加载 css
sass-loader：把 sass/scss 代码转换 ...`,l:"Interview/工程化/loader.html#常见的-loader",a:"常见的-loader"},"96.0":{t:"扩展-webpack-功能",p:"\r",l:"Interview/工程化/Plugin.html",a:"扩展-webpack-功能"},"96.1":{t:"工作原理",p:`webpack 通过内部的事件流机制保证了插件的有序性，底层是利用发布订阅模式，webpack 在运行过程中会广播事件，插件只需要监听它所关系的事件，在特定的时间对资源做处理
`,l:"Interview/工程化/Plugin.html#工作原理",a:"工作原理"},"96.2":{t:"编写一个插件",p:`// 自定义一个名为MyPlugin插件，该插件在打包完成后，在控制台输出&quot;打包已完成&quot;
class MyPlugin {
  // 原型上需要定义apply 的方法
  appl ...`,l:"Interview/工程化/Plugin.html#编写一个插件",a:"编写一个插件"},"97.0":{t:"webpack-构建流程",p:`1. 从入口文件开始解析
2. 查找入口文件引入了哪些js文件，找到依赖关系
3. 递归遍历引入的其它js，生成最终的依赖关系图
4. 将ES6语法转化成ES5
5. 最终生成一个可以在浏览器加载执行 ...`,l:"Interview/工程化/Webpack构建流程.html",a:"webpack-构建流程"},"97.1":{t:"完整版",p:"1. webpack 从项目的`entry`入口文件开始递归分析，调用所有配置的 `loader`对模块进行编译（因为 webpack 默认只能识别 js 代码，所以如 css 文件、.vue 结尾的 ...",l:"Interview/工程化/Webpack构建流程.html#完整版",a:"完整版"},"98.0":{t:"文件指纹是打包后输出的文件名的后缀",p:`
Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改
Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chun ...`,l:"Interview/工程化/文件指纹.html",a:"文件指纹是打包后输出的文件名的后缀"},"99.0":{t:"什么是热更新原理",p:`开发过程中，代码发生变动后，webpack 会重新编译，编译后浏览器替换修改的模块，局部刷新，无需刷新整个页面
好处：节省开发时间，提升开发体验
`,l:"Interview/工程化/热更新原理.html",a:"什么是热更新原理"},"99.1":{t:"原理",p:`主要是通过 webscoket 实现，建立本地服务器和浏览器的双向通信，当代码变化后，重新编译后，通知浏览器请求更新的模块，替换原有的模块

通过 webpack-dev-server 开启 serv ...`,l:"Interview/工程化/热更新原理.html#原理",a:"原理"},"100.0":{t:"js",p:`const getJSON = function (url) {
return new Promise((resolve, reject) =&gt; {
const xhr = new XMLHtt ...`,l:"Interview/手写/AJAX.html",a:"js"},"101.0":{t:"js",p:`// call
Function.prototype.myCall = function(context,...args){
context = context || window
context.f ...`,l:"Interview/手写/call-apply-bind.html",a:"js"},"102.0":{t:"接收多个函数为参数-由右向左依次执行函数",p:`function compose(...fns) {
  // 首先需要判断参数是否为空
  if (fns.length === 0) {
    throw new Error(&quot;必须传 ...`,l:"Interview/手写/compose.html",a:"接收多个函数为参数-由右向左依次执行函数"},"103.0":{t:"js",p:`function myInstanceof(obj, constructor) {
if (typeof obj !== &quot;object&quot; || obj === null) ret ...`,l:"Interview/手写/instanceof.html",a:"js"},"104.0":{t:"js",p:`class _LazyMan {
constructor(name) {
this.tasks = [];
const task = () =&gt; {
console.log(Hi! This i ...`,l:"Interview/手写/LazyMan.html",a:"js"},"105.0":{t:"js",p:`// 缓存淘汰策略，移除最近最少被访问的数据项
class LRUCache {
constructor(capacity) {
this.map = new Map();
this.capacity ...`,l:"Interview/手写/LRU.html",a:"js"},"106.0":{t:"_1-创建一个对象-该对象的原型指向构造函数的原型",p:`
调用该构造函数，构造函数的 this 指向新生成的对象
判断构造函数是否有返回值，如果有返回值且返回值是一个对象或方法，就返回这个值，否则返回新生成的对象

function myNew(const ...`,l:"Interview/手写/new.html",a:"_1-创建一个对象-该对象的原型指向构造函数的原型"},"107.0":{t:"promise",p:`class Promise {
  constructor(fn) {
    // resolve时的回调函数列表
    this.resolveTask = [];
    // reject时 ...`,l:"Interview/手写/Promise.html",a:"promise"},"107.1":{t:"race-all",p:`class Promise {
  // race静态方法，返回promises列表中第一个执行完的结果
  static race(promises) {
    return new Promis ...`,l:"Interview/手写/Promise.html#race-all",a:"race-all"},"107.2":{t:"retry",p:`/*
 * @param {function} fn - 方法名
 * @param {number} delay - 延迟的时间
 * @param {number} times - 重发的次数
  ...`,l:"Interview/手写/Promise.html#retry",a:"retry"},"108.0":{t:"settimeout-模拟实现-setinterval",p:`function mySetInterval(callback, delay) {
  function interval() {
    callback(); // 首先执行回调函数
    ti ...`,l:"Interview/手写/setTimeout-setInterval.html",a:"settimeout-模拟实现-setinterval"},"109.0":{t:"js",p:`function sleep(ms) {
return new Promise((resolve) =&gt; setTimeout(resolve, ms));
}

`,l:"Interview/手写/sleep.html",a:"js"},"110.0":{t:"js",p:`function curry(fn) {
return function curried(...args) {
if (args.length &lt; fn.length) {
return fun ...`,l:"Interview/手写/函数柯里化.html",a:"js"},"111.0":{t:"js",p:`[
{
id: 1,
text: '节点1',
parentId: 0 //这里用0表示为顶级节点
},
{
id: 2,
text: '节点1_1',
parentId: 1 //通过这个字段来确定 ...`,l:"Interview/手写/列表转成树形结构.html",a:"js"},"112.0":{t:"js",p:`class EventEmitter {
constructor() {
// 创建一个空对象存储事件和对应的回调函数
this.events = {};
}
// 实现订阅
on(type, cal ...`,l:"Interview/手写/发布订阅.html",a:"js"},"113.0":{t:"js",p:`{
tag: 'DIV',
attrs:{
id:'app'
},
children: [
{
tag: 'SPAN',
children: [
{ tag: 'A', children: [] }
 ...`,l:"Interview/手写/将虚拟dom转换成真实dom.html",a:"js"},"114.0":{t:"js",p:`// 递归的方法
function flat(arr) {
let res = [];
for (let i = 0; i &lt; arr.length; i++) {
if (Array.isAr ...`,l:"Interview/手写/并行限制的Promise调度器.html",a:"js"},"115.0":{t:"js",p:`// 递归的方法
function flat(arr) {
let res = [];
for (let i = 0; i &lt; arr.length; i++) {
if (Array.isAr ...`,l:"Interview/手写/扁平化.html",a:"js"},"116.0":{t:"冒泡",p:`function bubbleSort(arr) {
  // 缓存数组长度
  const len = arr.length;
  // 外层循环用于控制从头到尾的比较+交换到底有多少轮
  for ...`,l:"Interview/手写/排序.html",a:"冒泡"},"116.1":{t:"选择排序",p:` 循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部，然后缩小排序范围，重复，直到数组完全有序

function selectSort(arr) {
  // 缓存数组长度
  co ...`,l:"Interview/手写/排序.html#选择排序",a:"选择排序"},"116.2":{t:"插入排序",p:` 找到元素在它前面那个序列中的正确位置

function insertSort(arr) {
  // 缓存数组长度
  const len = arr.length;
  // temp 用来保存 ...`,l:"Interview/手写/排序.html#插入排序",a:"插入排序"},"116.3":{t:"快速排序",p:`// 定义一个名为sortArray的函数，它接受一个数组nums作为输入参数
var sortArray = function(nums) {
    // 如果数组长度小于2，表示数组已经有序或为 ...`,l:"Interview/手写/排序.html#快速排序",a:"快速排序"},"116.4":{t:"归并排序",p:` 将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，重复以上操作，直到单个子数组只有一个元素为止

 从粒度最小的子数组开始，两两合并，确保每次合并出来的数组都是有序的

 ...`,l:"Interview/手写/排序.html#归并排序",a:"归并排序"},"117.0":{t:"js",p:`// 方法1 使用set
[...new Set(arr)];
// 方法2 使用includes
let uniArr = [];
for (const item of arr) {
if (!un ...`,l:"Interview/手写/数组去重.html",a:"js"},"118.0":{t:"js",p:`[
{
id: 1,
text: '节点1',
parentId: 0,
children: [
{
id:2,
text: '节点1_1',
parentId:1
}
]
}
]
转成
[
{
id ...`,l:"Interview/手写/树形结构转换成列表.html",a:"js"},"119.0":{t:"js",p:`function deepClone(obj, hash = new WeakMap()) {
if (!(typeof obj === &quot;object&quot; &amp;&amp; o ...`,l:"Interview/手写/深拷贝.html",a:"js"},"120.0":{t:"js",p:`function pipe(...functions) {
return function (input) {
return functions.reduce((value, func) =&gt;  ...`,l:"Interview/手写/管道函数.html",a:"js"},"121.0":{t:"节流",p:`某个函数在一定时间间隔内只执行一次，在规定的延迟时间内无视后来产生的函数调用请求，也不会延长时间
控制函数执行频率的技术，确保函数在一定时间间隔内最多执行一次，以减轻高频率触发函数的性能问题。一般情况 ...`,l:"Interview/手写/防抖节流.html",a:"节流"},"121.1":{t:"防抖",p:`是指某个函数在规定的时间段内，无论触发多少次回调，只执行最后
一般用于处理需要等待一段时间后稳定下来的事件，比如输入框的输入事件、滚动事件、窗口大小调
核心思想就是当函数被触发后，设置一个定时器，在一 ...`,l:"Interview/手写/防抖节流.html#防抖",a:"防抖"},"122.0":{t:"数组",p:"",l:"Problem/Graphical/数组.html",a:"数组"},"123.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录编程遇到的问题，已经解决方案，以便以后回顾或找到更优解!
:::
`,l:"Problem/index.html",a:"编程踩坑积累与总结"},"124.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录项目中的关键技术!
:::
`,l:"Project/index.html",a:"编程踩坑积累与总结"},"125.0":{t:"测试-1",p:"",l:"Project/project1/1.html",a:"测试-1"},"126.0":{t:"编程踩坑积累与总结",p:`::: tip
这里主要记录面试遇到的真题!
:::
`,l:"Relay/index.html",a:"编程踩坑积累与总结"},"127.0":{t:"测试-1",p:"",l:"Relay/relay1/1.html",a:"测试-1"}},n={previewLength:100,buttonLabel:"搜索",placeholder:"情输入关键词"},r={INDEX_DATA:e,PREVIEW_LOOKUP:t,Options:n};export{r as default};
