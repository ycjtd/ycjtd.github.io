import{_ as e,c as a,o as i,d as l}from"./app.ba5af232.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"什么是内存泄漏？","slug":"什么是内存泄漏","link":"#什么是内存泄漏","children":[]},{"level":3,"title":"内存泄漏的常见原因：","slug":"内存泄漏的常见原因","link":"#内存泄漏的常见原因","children":[]},{"level":3,"title":"标记清除方法：","slug":"标记清除方法","link":"#标记清除方法","children":[]},{"level":3,"title":"引用计数法：","slug":"引用计数法","link":"#引用计数法","children":[]},{"level":3,"title":"怎么防止内存泄漏？","slug":"怎么防止内存泄漏","link":"#怎么防止内存泄漏","children":[]}],"relativePath":"Interview/JavaScript/垃圾回收.md"}'),t={name:"Interview/JavaScript/垃圾回收.md"},r=l('<h3 id="什么是内存泄漏" tabindex="-1">什么是内存泄漏？ <a class="header-anchor" href="#什么是内存泄漏" aria-hidden="true">#</a></h3><ul><li>内存泄漏是指应当被回收的对象没有被正常回收,导致内存占用越来越高,会导致应用程序速度变慢,高延时,奔溃等问题</li></ul><h3 id="内存泄漏的常见原因" tabindex="-1">内存泄漏的常见原因： <a class="header-anchor" href="#内存泄漏的常见原因" aria-hidden="true">#</a></h3><ul><li>创建全局变量</li><li>被遗忘的计时器或回调函数</li><li>闭包</li><li>脱离 DOM 的引用</li></ul><p>JavaScript 有自动的垃圾回收机制，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存</p><h3 id="标记清除方法" tabindex="-1">标记清除方法： <a class="header-anchor" href="#标记清除方法" aria-hidden="true">#</a></h3><ul><li>标记阶段：垃圾回收器从根对象开始遍历，每一个可以从根对象访问到的对象都会被添加一个标识，这个对象被标记为可到达对象</li><li>清除阶段：垃圾回收器对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作</li></ul><p>缺点：垃圾收集后可能会造成大量的内存碎片</p><h3 id="引用计数法" tabindex="-1">引用计数法： <a class="header-anchor" href="#引用计数法" aria-hidden="true">#</a></h3><p>将资源被引用的次数保存起来,当被引用次数为零时释放,局限性是当出现循环引用时,互相引用的对象不会被回收</p><h3 id="怎么防止内存泄漏" tabindex="-1">怎么防止内存泄漏？ <a class="header-anchor" href="#怎么防止内存泄漏" aria-hidden="true">#</a></h3><ul><li>及时清除引用</li><li>使用 WeakMap 和 WeakSet，因为它们对于值的引用不计入垃圾回收机制</li></ul>',12),n=[r];function d(h,c,s,_,o,u){return i(),a("div",null,n)}const v=e(t,[["render",d]]);export{f as __pageData,v as default};
