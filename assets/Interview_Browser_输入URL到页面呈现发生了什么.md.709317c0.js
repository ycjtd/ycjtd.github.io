import{_ as l,c as i,o as t,d as r}from"./app.eeaca755.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Interview/Browser/输入URL到页面呈现发生了什么.md"}'),e={name:"Interview/Browser/输入URL到页面呈现发生了什么.md"},_=r("<ul><li><p>用户输入 url 并回车</p></li><li><p>浏览器进程检查 url，组装协议，构成完整的 url</p></li><li><p>浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程</p></li><li><p>网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</p></li><li><p><strong>如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下</strong>：</p><ul><li>进行 DNS 解析，获取服务器 ip 地址，端口（端口是通过 dns 解析获取的吗？这里有个疑问）</li><li>利用 ip 地址和服务器建立 tcp 连接</li><li>构建请求头信息</li><li>发送请求头信息</li><li>服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li></ul></li><li><p><strong>网络进程解析响应流程</strong>；</p><ul><li>检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 （301/302 跳转也会读取本地缓存吗？这里有个疑问），如果是 200，则继续处理请求。</li><li>200 响应处理：检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。</li></ul></li><li><p><strong>准备渲染进程</strong></p><ul><li>浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li></ul></li><li><p><strong>传输数据、更新状态</strong></p><ul><li>渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”</li><li>渲染进程接收完数据后，向浏览器发送“确认提交”</li><li>浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面</li></ul></li></ul><p><strong>渲染流程</strong></p><ul><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。</li><li>创建布局树，并计算元素的布局信息。</li><li>对布局树进行分层，并生成分层树。</li><li>为每个图层生成绘制列表，并将其提交到合成线程。</li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上</li></ul>",3),o=[_];function s(n,p,a,u,c,d){return t(),i("div",null,o)}const S=l(e,[["render",s]]);export{m as __pageData,S as default};
