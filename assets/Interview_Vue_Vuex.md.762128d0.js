import{_ as e,c as o,o as c,d}from"./app.ba5af232.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"从 vuex 中获取的数据能直接更改吗","slug":"从-vuex-中获取的数据能直接更改吗","link":"#从-vuex-中获取的数据能直接更改吗","children":[]},{"level":3,"title":"vuex 中 actions 和 mutations 有什么区别","slug":"vuex-中-actions-和-mutations-有什么区别","link":"#vuex-中-actions-和-mutations-有什么区别","children":[]},{"level":3,"title":"怎么监听 vuex 数据的变化","slug":"怎么监听-vuex-数据的变化","link":"#怎么监听-vuex-数据的变化","children":[]},{"level":3,"title":"vuex 页面刷新数据丢失怎么解决","slug":"vuex-页面刷新数据丢失怎么解决","link":"#vuex-页面刷新数据丢失怎么解决","children":[]},{"level":3,"title":"pinia 有什么优点","slug":"pinia-有什么优点","link":"#pinia-有什么优点","children":[]},{"level":3,"title":"从零开始实现一个 vuex，说说思路","slug":"从零开始实现一个-vuex-说说思路","link":"#从零开始实现一个-vuex-说说思路","children":[]}],"relativePath":"Interview/Vue/Vuex.md"}'),i={name:"Interview/Vue/Vuex.md"},t=d('<h3 id="从-vuex-中获取的数据能直接更改吗" tabindex="-1">从 vuex 中获取的数据能直接更改吗 <a class="header-anchor" href="#从-vuex-中获取的数据能直接更改吗" aria-hidden="true">#</a></h3><p>不能直接更改，需要浅拷贝对象之后更改，否则会报错</p><h3 id="vuex-中-actions-和-mutations-有什么区别" tabindex="-1">vuex 中 actions 和 mutations 有什么区别 <a class="header-anchor" href="#vuex-中-actions-和-mutations-有什么区别" aria-hidden="true">#</a></h3><ol><li>改 <code>Vuex</code> 的 <code>store</code> 中的状态的唯一方法是提交 <code>mutation</code>，<code>mutation</code> 非常类似于事件：每个 <code>mutation</code> 都有一个字符串的类型 (<code>type</code>)和一个 回调函数 (<code>handler</code>) 。<code>Action</code> 类似于 <code>mutation</code>，不同在于：<code>Action</code>可以包含任意异步操作，但它不能修改状态， 需要提交<code>mutation</code>才能变更状态</li><li>开发时，包含异步操作或者复杂业务组合时使用<code>action</code>；需要直接修改状态则提交<code>mutation</code>。但由于<code>dispatch</code>和<code>commit</code>是两个<code>API</code>，容易引起混淆，实践中也会采用统一使用<code>dispatch action</code>的方式。调用<code>dispatch</code>和<code>commit</code>两个<code>API</code>时几乎完全一样，但是定义两者时却不甚相同，<code>mutation</code>的回调函数接收参数是<code>state</code>对象。<code>action</code>则是与<code>Store</code>实例具有相同方法和属性的上下文<code>context</code>对象，因此一般会解构它为<code>{commit, dispatch, state}</code>，从而方便编码。另外<code>dispatch</code>会返回<code>Promise</code>实例便于处理内部异步结果</li><li>实现上<code>commit(type)</code>方法相当于调用<code>options.mutations[type](state)</code>；<code>dispatch(type)</code>方法相当于调用<code>options.actions[type](store)</code>，这样就很容易理解两者使用上的不同了</li></ol><h3 id="怎么监听-vuex-数据的变化" tabindex="-1">怎么监听 vuex 数据的变化 <a class="header-anchor" href="#怎么监听-vuex-数据的变化" aria-hidden="true">#</a></h3><ul><li>可以通过<code>watch</code>选项或者<code>watch</code>方法监听状态</li><li>可以使用<code>vuex</code>提供的 API：<code>store.subscribe()</code></li></ul><ol start="2"><li><code>watch</code>选项方式，可以以字符串形式监听<code>$store.state.xx</code>；<code>subscribe</code>方式，可以调用<code>store.subscribe(cb)</code>,回调函数接收<code>mutation</code>对象和<code>state</code>对象，这样可以进一步判断<code>mutation.type</code>是否是期待的那个，从而进一步做后续处理。</li><li><code>watch</code>方式简单好用，且能获取变化前后值，首选；<code>subscribe</code>方法会被所有<code>commit</code>行为触发，因此还需要判断<code>mutation.type</code>，用起来略繁琐，一般用于<code>vuex</code>插件中</li></ol><h3 id="vuex-页面刷新数据丢失怎么解决" tabindex="-1">vuex 页面刷新数据丢失怎么解决 <a class="header-anchor" href="#vuex-页面刷新数据丢失怎么解决" aria-hidden="true">#</a></h3><ol><li><code>vuex</code>只是在内存保存状态，刷新之后就会丢失，如果要持久化就要存起来</li><li><code>localStorage</code>就很合适，提交<code>mutation</code>的时候同时存入<code>localStorage</code>，<code>store</code>中把值取出作为<code>state</code>的初始值即可。</li><li>这里有两个问题，不是所有状态都需要持久化；如果需要保存的状态很多，编写的代码就不够优雅，每个提交的地方都要单独做保存处理。这里就可以利用<code>vuex</code>提供的<code>subscribe</code>方法做一个统一的处理。甚至可以封装一个<code>vuex</code>插件以便复用。</li><li>类似的插件有<code>vuex-persist</code>、<code>vuex-persistedstate</code>，内部的实现就是通过订阅<code>mutation</code>变化做统一处理，通过插件的选项控制哪些需要持久化</li></ol><h3 id="pinia-有什么优点" tabindex="-1">pinia 有什么优点 <a class="header-anchor" href="#pinia-有什么优点" aria-hidden="true">#</a></h3><p><strong>1. pinia 是什么？</strong></p><blockquote><ul><li>在<code>Vue3</code>中，可以使用传统的<code>Vuex</code>来实现状态管理，也可以使用最新的<code>pinia</code>来实现状态管理，我们来看看官网如何解释<code>pinia</code>的：<code>Pinia</code> 是 <code>Vue</code> 的存储库，它允许您跨组件/页面共享状态。</li><li>实际上，<code>pinia</code>就是<code>Vuex</code>的升级版，官网也说过，为了尊重原作者，所以取名<code>pinia</code>，而没有取名<code>Vuex</code>，所以大家可以直接将<code>pinia</code>比作为<code>Vue3</code>的<code>Vuex</code></li></ul></blockquote><p><strong>2. 为什么要使用 pinia？</strong></p><ul><li><code>Vue2</code>和<code>Vue3</code>都支持，这让我们同时使用<code>Vue2</code>和<code>Vue3</code>的小伙伴都能很快上手。</li><li><code>pinia</code>中只有<code>state</code>、<code>getter</code>、<code>action</code>，抛弃了<code>Vuex</code>中的<code>Mutation</code>，<code>Vuex</code>中<code>mutation</code>一直都不太受小伙伴们的待见，<code>pinia</code>直接抛弃它了，这无疑减少了我们工作量。</li><li><code>pinia</code>中<code>action</code>支持同步和异步，<code>Vuex</code>不支持</li><li>良好的<code>Typescript</code>支持，毕竟我们<code>Vue3</code>都推荐使用<code>TS</code>来编写，这个时候使用<code>pinia</code>就非常合适了</li><li>无需再创建各个模块嵌套了，<code>Vuex</code>中如果数据过多，我们通常分模块来进行管理，稍显麻烦，而<code>pinia</code>中每个<code>store</code>都是独立的，互相不影响。</li><li>体积非常小，只有<code>1KB</code>左右。</li><li><code>pinia</code>支持插件来扩展自身功能。</li><li>支持服务端渲染</li></ul><h3 id="从零开始实现一个-vuex-说说思路" tabindex="-1">从零开始实现一个 vuex，说说思路 <a class="header-anchor" href="#从零开始实现一个-vuex-说说思路" aria-hidden="true">#</a></h3><ol><li>官方说<code>vuex</code>是一个状态管理模式和库，并确保这些状态以可预期的方式变更。可见要实现一个<code>vuex</code></li></ol><ul><li>要实现一个<code>Store</code>存储全局状态</li><li>要提供修改状态所需 API：<code>commit(type, payload), dispatch(type, payload)</code></li></ul><ol start="2"><li>实现<code>Store</code>时，可以定义<code>Store</code>类，构造函数接收选项<code>options</code>，设置属性<code>state</code>对外暴露状态，提供<code>commit</code>和<code>dispatch</code>修改属性<code>state</code>。这里需要设置<code>state</code>为响应式对象，同时将<code>Store</code>定义为一个<code>Vue</code>插件</li><li><code>commit(type, payload)</code>方法中可以获取用户传入<code>mutations</code>并执行它，这样可以按用户提供的方法修改状态。 <code>dispatch(type, payload)</code>类似，但需要注意它可能是异步的，需要返回一个<code>Promise</code>给用户以处理异步结果</li></ol>',18),a=[t];function l(u,n,s,r,p,x){return c(),o("div",null,a)}const m=e(i,[["render",l]]);export{v as __pageData,m as default};
