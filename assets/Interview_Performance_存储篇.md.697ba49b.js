import{_ as e,c as a,o as i,a as r}from"./app.d0de5917.js";const f=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"缓存","slug":"缓存","link":"#缓存","children":[{"level":3,"title":"强缓存","slug":"强缓存","link":"#强缓存","children":[]},{"level":3,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[]},{"level":3,"title":"决策指南","slug":"决策指南","link":"#决策指南","children":[]}]},{"level":2,"title":"本地存储","slug":"本地存储","link":"#本地存储","children":[{"level":3,"title":"Cookie","slug":"cookie","link":"#cookie","children":[]},{"level":3,"title":"LocalStorage","slug":"localstorage","link":"#localstorage","children":[]},{"level":3,"title":"SessionStorage","slug":"sessionstorage","link":"#sessionstorage","children":[]},{"level":3,"title":"IndexDB","slug":"indexdb","link":"#indexdb","children":[]},{"level":3,"title":"CDN 的缓存和回源机制","slug":"cdn-的缓存和回源机制","link":"#cdn-的缓存和回源机制","children":[]}]}],"relativePath":"Interview/Performance/存储篇.md"}'),o={name:"Interview/Performance/存储篇.md"},t=r('<h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-hidden="true">#</a></h2><p>缓存可以减少网络 IO 消耗，提高访问速度。浏览器缓存是一种操作简单，效果显著的前端性能优化手段。</p><p>通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端和服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用，所以缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。</p><p>浏览器缓存机制有四个方面，按照获取资源时请求的优先级排序：Memory Cache、Service Worker Cache、HTTP Cache、Push Cache</p><p>HTTP 缓存分为强缓存和协商缓存，强缓存的优先级高于协商缓存，在命中强缓存失败的情况下，才会走协商缓存。</p><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-hidden="true">#</a></h3><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否命中强缓存，如果命中直接从缓存中获取资源，不会再与服务端发起通信，命中强缓存情况下，返回的 HTTP 状态码为 200 form disk cache</p><p>实现强缓存</p><p>过去一直用 expires，当服务器返回响应的时候，在 response headers 中将过期时间写入 expires 字段，expires 是一个时间戳，接下来当再次向服务器请求这个资源的时候，浏览器会先比对本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么直接去缓存中去取这个资源。也正因为如此，expires 是有问题的，因为 expires 会依赖本地时间，如果服务端和客户端的时间设置不同，或者直接去手动改客户端的时间，expires 就会无法达到预期。所以在 HTTP1.1 增加了 Cache-Control 这个字段来代替 expires 字段。在 Cache-Control 中，使用 max-age 来控制资源的有效期，max-age 不再是一个时间戳，而是一个时间长度，意味着该资源在当前时间长度内都是有效的，这就完美规避了时间戳带来的潜在问题。Cache-Control 相对于 expires 更加准确，优先级也更高，两者同时出现，以 Cache-Control 为准。</p><p>s-maxgae：优先级高于 max-age，如果 s-maxage 未过期，向代理服务器请求缓存内容，只在代理服务器中生效，客户端只考虑 max-age</p><p>public 和 private：如果为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存，如果设置了 private，则只能被浏览器缓存。private 为默认值，一般情况下，public 不需要单独设置，因为一般情况下会同时写 max-age 和 s-maxage，这就表明是可以被浏览器和代理服务器缓存的</p><p>no-store 和 no-cache：no-cache 绕开了浏览器，设置了 no-cache 后，每一次发起请求的时候都不会去询问浏览器的缓存情况，而是直接向服务端去确认资源是否过期；no-store 就是不使用任何缓存策略，只允许直接向服务端发送请求，并下载完整的响应。</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a></h3><p>协商缓存依赖于浏览器和服务端之间的通信，协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源</p><p>如果服务端提示资源未改动，304 Not Modified，资源会被重定向到浏览器缓存。</p><p>实现协商缓存：</p><p>Last-Modified 是一个时间戳，如果我们启用了协商缓存，会在首次请求时随着 Reponse headers 返回，随后每次请求时，都会带上一个叫 If-Modified-Since 的时间戳字段，值是上一次返回的 last-modified 值，服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了改变。如果发生了变化，就会返回一个完整的响应内容，并在 response headers 中添加新的 last-modified 值，否则，返回 304，response headers 不会再添加 last-modified 字段</p><p>使用 last-modified 会有两个弊端：比如我们编辑了文件，但是文件的内容没有改变，服务端并不知道我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当作新资源，进而引发一次完整的响应—不该重新请求的时候，也会重新请求；当我们修改文件的速度过快时，由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以是感知不到这个改动的—该请求的时候没有请求。</p><p>所以使用 last-modified，可能会有一个 bug，那就是服务器并没有正确感知文件的变化。为了解决这个问题，Etag 出现了</p><p>Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，对应的 Etag 就是不同的，所以 Etag 能精准的感知文件的变化。</p><p>当首次请求的时候，会在响应头里获取到一个最初的标识字符串，那么在下一次请求的时候，请求头中就会带有一个值相同的、名为 if-None-Match 的字符串供服务端比对了。</p><p>Etag 优先级高于 Last-Modified，但是 Etag 的生成过程需要服务器付出开销，会影响服务端的性能，所以 Etag 不能替代 Last-Modified，只是对其的补充。</p><h3 id="决策指南" tabindex="-1">决策指南 <a class="header-anchor" href="#决策指南" aria-hidden="true">#</a></h3><p>当我们的资源不可复用的时候，之间为 Cache-Control 为 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，设置为 no-cache，否则考虑该资源是否可以被服务器代理缓存，根据其结果决定是设置为 private 还是 public，然后考虑资源的过期时间，设置对应的 max-age 和 s-maxage，最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。</p><p><strong>MemoryCache</strong></p><p>是指存在内存中的缓存，优先级最高，浏览器会最先去命中的一种缓存，也是响应速度最快的一种缓存。但是当 tab 关闭的时候，内存中的数据也会消失。</p><p>Base64 格式的图片，几乎都是放进 MemoryCache 的，体积不大的 JS、CSS 也可以放进去，但是较大的 JS、CSS 就不可以了，因为内存资源是有限的</p><p><strong>Service Worker Cache</strong></p><p>独立于主线程之外的 JavaScript 线程，脱离于浏览器窗体，所以无法直接访问 DOM，可以帮我们实现离线缓存、消息推送和网络代理等功能。借助 Service Worker 实现的离线缓存就是 Service Worker Cache。生命周期包括 install、active、working。一旦被 install，将始终存在，在 active 和 working 之间切换。Server Worker 要求协议必须是 https</p><p><strong>Push Cache</strong></p><p>是指 HTTP2 在 server push 阶段存在的缓存</p><h2 id="本地存储" tabindex="-1">本地存储 <a class="header-anchor" href="#本地存储" aria-hidden="true">#</a></h2><h3 id="cookie" tabindex="-1">Cookie <a class="header-anchor" href="#cookie" aria-hidden="true">#</a></h3><p>HTTP 是一个无状态协议，服务器接收客户端的请求，返回一个响应，然后就结束了，服务器没有记录任何关于客户端的任何信息，下次请求的时候，不知道客户端是谁</p><p>cookie 就是一个存储在浏览器中的很小的一个文本文件，附着在 HTTP 请求上，在浏览器和服务器之间进行传递，可以携带用户信息，当服务器检查 Cookie 的时候，就可以获取到客户端的状态。</p><p>cookie 有体积上限，最大只能有 4kb，所以只能存少量的信息</p><p>过量的 cookie 会带来巨大的性能浪费，同一个域名下的所有请求，都会携带 cookie。</p><p>cookie 有哪些字段？⭐</p><h3 id="localstorage" tabindex="-1">LocalStorage <a class="header-anchor" href="#localstorage" aria-hidden="true">#</a></h3><p>持久化的本地存储，存储在其中的数据是永远不会过期的，使其消失的唯一办法就是手动删除；常用于存储一些内容稳定的资源</p><h3 id="sessionstorage" tabindex="-1">SessionStorage <a class="header-anchor" href="#sessionstorage" aria-hidden="true">#</a></h3><p>会话级别的存储，当会话结束（页面被关闭的时候）存储内容也会随之被释放；即便是相同域名下的两个窗口，只要不在同一个浏览器窗口中打开，那么它们的 SessionStorage 无法共享。存储只适用于当前会话的信息。</p><p>相同点：存储容量大，可以达到 5-10M，只位于浏览器端，不和服务器发起通信。</p><h3 id="indexdb" tabindex="-1">IndexDB <a class="header-anchor" href="#indexdb" aria-hidden="true">#</a></h3><p>运行在浏览器上的非关系型数据库。一般来说是没有存储上限的，不仅可以存储字符串，也可以存储二进制数据。</p><p>当数据的复杂度和规模上升到了 LocalStorage 无法解决的程度，可以使用 IndexDB</p><h3 id="cdn-的缓存和回源机制" tabindex="-1">CDN 的缓存和回源机制 <a class="header-anchor" href="#cdn-的缓存和回源机制" aria-hidden="true">#</a></h3><p>内容分发网络指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，所有服务器可以根据哪些服务器和用户距离最近，来满足数据的请求。</p><p>缓存、本都存储带来的性能提升，都是只能在拿到数据后存起来这件事情发生之后，首次请求资源的时候，想要提升响应能力，就需要 CDN。</p><p>缓存：把资源 copy 一份到 CDN 服务器上的过程，回源：CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器去要这个资源</p><p>CDN 往往被用来存储静态资源。就是 JS、CSS、图片等不需要业务服务器进行计算就可以得到的资源。动态资源就是需要后端实时动态生成的资源。</p>',51),s=[t];function p(n,d,c,l,h,g){return i(),a("div",null,s)}const C=e(o,[["render",p]]);export{f as __pageData,C as default};
